
%---------------------- about
\hypertarget{about}{\section*{about}}
\subsection*{Compact display of variable type}
\addcontentsline{toc}{section}{about}


\texttt{ABOUT(X)} displays a compact line that describes the class and dimensions of
\texttt{X}.



ABOUT \texttt{X}  as above but this is the command rather than functional form.


\subsection*{Examples}
\begin{Code}
   >> a=1;
   >> about a
   a [double] : 1x1 (8 bytes)

   >> a = rand(5,7);
   >> about a
   a [double] : 5x7 (280 bytes)

\end{Code}

\subsection*{See also}


\hyperlink{whos}{\color{blue} whos}

\vspace{1.5ex}\rule{\textwidth}{1mm}

%---------------------- angdiff
\hypertarget{angdiff}{\section*{angdiff}}
\subsection*{Difference of two angles}
\addcontentsline{toc}{section}{angdiff}


\texttt{ANGDIFF(TH1, TH2)} is the difference between angles \texttt{TH1} and \texttt{TH2}, ie. \texttt{TH1}-\texttt{TH2}
on the circle.  The result is in the interval [-$\pi$ $\pi$).  Either or both
arguments can be a vector:

\begin{itemize}
  \item If \texttt{TH1} is a vector, and \texttt{TH2} a scalar then return a vector where \texttt{TH2} is modulo    subtracted from the corresponding elements of \texttt{TH1}.
  \item If \texttt{TH1} is a scalar, and \texttt{TH2} a vector then return a vector where the    corresponding elements of \texttt{TH2} are modulo subtracted from \texttt{TH1}.
  \item If \texttt{TH1} and \texttt{TH2} are vectors then return a vector whose elements are the modulo    difference of the corresponding elements of \texttt{TH1} and \texttt{TH2}, which must be the
  \item same length.
\end{itemize}


\texttt{ANGDIFF(TH)} as above but \texttt{TH}=[\texttt{TH1} \texttt{TH2}].



\texttt{ANGDIFF(TH)} is the equivalent angle to the scalar \texttt{TH} in the interval [-$\pi$ $\pi$).


\subsection*{Notes}
\begin{itemize}
  \item The MathWorks Robotics Systems Toolbox defines a function with the same name    which computes \texttt{TH2}-\texttt{TH1} rather than \texttt{TH1}-\texttt{TH2}.
  \item If \texttt{TH1} and \texttt{TH2} are both vectors they should have the same    orientation, which the output will assume.
\end{itemize}
\vspace{1.5ex}\rule{\textwidth}{1mm}

%---------------------- angvec2r
\hypertarget{angvec2r}{\section*{angvec2r}}
\subsection*{Convert angle and vector orientation to a rotation matrix}
\addcontentsline{toc}{section}{angvec2r}


\texttt{R = ANGVEC2R(THETA, V)} is an orthonormal rotation matrix ($3 \times 3$)
equivalent to a rotation of \texttt{THETA} about the vector \texttt{V}.


\subsection*{Notes}
\begin{itemize}
  \item Uses Rodrigues\textquotesingle  formula
  \item If \texttt{THETA} == 0 then return identity matrix and ignore \texttt{V}.
  \item If \texttt{THETA} $\ne$ 0 then \texttt{V} must have a finite length.
\end{itemize}

\subsection*{See also}


\hyperlink{angvec2tr}{\color{blue} angvec2tr}, \hyperlink{eul2r}{\color{blue} eul2r}, \hyperlink{rpy2r}{\color{blue} rpy2r}, \hyperlink{tr2angvec}{\color{blue} tr2angvec}, \hyperlink{trexp}{\color{blue} trexp}, \hyperlink{SO3.angvec}{\color{blue} SO3.angvec}

\vspace{1.5ex}\rule{\textwidth}{1mm}

%---------------------- angvec2tr
\hypertarget{angvec2tr}{\section*{angvec2tr}}
\subsection*{Convert angle and vector orientation to a homogeneous transform}
\addcontentsline{toc}{section}{angvec2tr}


\texttt{T = ANGVEC2TR(THETA, V)} is a homogeneous transform matrix ($4 \times 4$) equivalent to a
rotation of \texttt{THETA} about the vector \texttt{V}.


\subsection*{Note}
\begin{itemize}
  \item Uses Rodrigues\textquotesingle  formula
  \item The translational part is zero.
  \item If \texttt{THETA} == 0 then return identity matrix and ignore \texttt{V}.
  \item If \texttt{THETA} $\ne$ 0 then \texttt{V} must have a finite length.
\end{itemize}

\subsection*{See also}


\hyperlink{angvec2r}{\color{blue} angvec2r}, \hyperlink{eul2tr}{\color{blue} eul2tr}, \hyperlink{rpy2tr}{\color{blue} rpy2tr}, \hyperlink{angvec2r}{\color{blue} angvec2r}, \hyperlink{tr2angvec}{\color{blue} tr2angvec}, \hyperlink{trexp}{\color{blue} trexp}, \hyperlink{SO3.angvec}{\color{blue} SO3.angvec}

\vspace{1.5ex}\rule{\textwidth}{1mm}

%---------------------- Animate
\hypertarget{Animate}{\section*{Animate}}
\subsection*{Create an animation}
\addcontentsline{toc}{section}{Animate}


Helper class for creating animations as MP4, animated GIF or a folder of images.


\subsection*{Example}
\begin{Code}
   anim = Animate('movie.mp4');
    for i=1:100
        plot(...);
        anim.add();
    end
    anim.close();

\end{Code}


will save the frames in an MP4 movie file using VideoWriter.



Alternatively, to createa of images in PNG format frames named 0000.png,
0001.png and so on in a folder called \textquotesingle frames\textquotesingle 

\begin{Code}
    anim = Animate('frames');
    for i=1:100
        plot(...);
        anim.add();
    end
    anim.close();

\end{Code}


To convert the image files to a movie you could use a tool like ffmpeg

\begin{Code}
     ffmpeg -r 10 -i frames/%04d.png out.mp4

\end{Code}

\subsection*{Notes}
\begin{itemize}
  \item MP4 movies cannot be generated under Linux, a limitation of MATLAB VideoWriter.
\end{itemize}
\vspace{1.5ex}\hrule

%---------------------- Animate.Animate
\hypertarget{Animate.Animate}{\section*{Animate.Animate}}
\subsection*{Create an animation class}
\addcontentsline{tom}{section}{Animate.Animate}


\texttt{ANIM = ANIMATE(NAME, OPTIONS)} initializes an animation, and creates
a movie file or a folder holding individual frames.



\texttt{ANIM} = ANIMATE($\{$\texttt{NAME}, \texttt{OPTIONS}$\}$) as above but arguments are passed as a cell array,
which allows a single argument to a higher-level option like \textquotesingle movie\textquotesingle ,M to express
options as well as filename.


\subsection*{Options}
\begin{longtable}{lp{120mm}}
\textquotesingle resolution\textquotesingle ,R & Set the resolution of the saved image to R pixels per inch.\\ 
\textquotesingle profile\textquotesingle ,P & See VideoWriter for details\\ 
\textquotesingle fps\textquotesingle ,F & Frame rate (default 30)\\ 
\textquotesingle bgcolor\textquotesingle ,C                     color name. & Set background color of axes, 3 vector or MATLAB\\ 
\textquotesingle inner\textquotesingle  & inner frame of axes; no axes, labels, ticks.\\ 
\end{longtable}\vspace{1ex}


A profile can also be set by the file extension given:

\begin{longtable}{lp{120mm}}
none          0000.png, 0001.png and so on & Create a folder full of frames in PNG format frames named\\ 
.gif & Create animated GIF\\ 
.mp4 & Create MP4 movie (not on Linux)\\ 
.avi & Create AVI movie\\ 
.mj2 & Create motion jpeg file\\ 
\end{longtable}\vspace{1ex}

\subsection*{Notes}
\begin{itemize}
  \item MP4 movies cannot be generated under Linux, a limitation of MATLAB VideoWriter.
  \item if no extension or profile is given a folder full of frames is created.
  \item if a profile is given a movie is created, see VideoWriter for allowable    profiles.
  \item if the file has an extension it specifies the profile.
  \item if an extension of \textquotesingle .gif\textquotesingle  is given an animated GIF is created
  \item if \texttt{NAME} is [] then an Animation object is created but the add() and close()    methods do nothing.
\end{itemize}

\subsection*{See also}


\hyperlink{VideoWriter}{\color{blue} VideoWriter}

\vspace{1.5ex}\hrule

%---------------------- Animate.add
\hypertarget{Animate.add}{\section*{Animate.add}}
\subsection*{Adds current plot to the animation}
\addcontentsline{tom}{section}{Animate.add}


\texttt{A.ADD()} adds the current figure to the animation.



\texttt{A.ADD(FIG)} as above but captures the figure \texttt{FIG}.


\subsection*{Notes}
\begin{itemize}
  \item the frame is added to the output file or as a new sequentially    numbered image in a folder.
  \item if the filename was given as [] in the constructor then no    action is taken.
\end{itemize}

\subsection*{See also}


\hyperlink{print}{\color{blue} print}

\vspace{1.5ex}\hrule

%---------------------- Animate.close
\hypertarget{Animate.close}{\section*{Animate.close}}
\subsection*{Closes the animation}
\addcontentsline{tom}{section}{Animate.close}


\texttt{A.CLOSE()} ends the animation process and closes any output file.


\subsection*{Notes}
\begin{itemize}
  \item if the filename was given as [] in the constructor then no    action is taken.
\end{itemize}
\vspace{1.5ex}\rule{\textwidth}{1mm}
\vspace{1.5ex}\rule{\textwidth}{1mm}

%---------------------- chi2inv\_rtb
\hypertarget{chi2inv\_rtb}{\section*{chi2inv\_rtb}}
\subsection*{Inverse chi-squared function}
\addcontentsline{toc}{section}{chi2inv\_rtb}


\texttt{X = CHI2INV\_RTB(P, N)} is the inverse chi-squared CDF function of \texttt{N}-degrees of freedom.


\subsection*{Notes}
\begin{itemize}
  \item only works for \texttt{N}=2
  \item uses a table lookup with around 6 figure accuracy
  \item an approximation to chi2inv() from the Statistics \& Machine Learning Toolbox
\end{itemize}

\subsection*{See also}


\hyperlink{chi2inv}{\color{blue} chi2inv}

\vspace{1.5ex}\rule{\textwidth}{1mm}

%---------------------- circle
\hypertarget{circle}{\section*{circle}}
\subsection*{Compute points on a circle}
\addcontentsline{toc}{section}{circle}


\texttt{CIRCLE(C, R, OPTIONS)} plots a circle centred at \texttt{C} ($1 \times 2$) with radius \texttt{R} on the current
axes.



\texttt{X = CIRCLE(C, R, OPTIONS)} is a matrix ($2 \times N$) whose columns define the
coordinates [x,y] of points around the circumference of a circle
centred at \texttt{C} ($1 \times 2$) and of radius \texttt{R}.



\texttt{C} is normally $2 \times 1$ but if $3 \times 1$ then the circle is embedded in 3D, and \texttt{X} is $N \times 3$.
The circle is always in the xy-plane with a z-coordinate of \texttt{C}(3).


\subsection*{Options}
\begin{longtable}{lp{120mm}}
\textquotesingle n\textquotesingle ,N & Specify the number of points (default 50)\\ 
\end{longtable}\vspace{1ex}
\vspace{1.5ex}\rule{\textwidth}{1mm}

%---------------------- colnorm
\hypertarget{colnorm}{\section*{colnorm}}
\subsection*{Column-wise norm of a matrix}
\addcontentsline{toc}{section}{colnorm}


\texttt{CN = COLNORM(A)} is a vector ($1 \times M$) comprising the Euclidean norm of each column of the
matrix \texttt{A} ($N \times M$).


\subsection*{See also}


\hyperlink{norm}{\color{blue} norm}

\vspace{1.5ex}\rule{\textwidth}{1mm}

%---------------------- delta2tr
\hypertarget{delta2tr}{\section*{delta2tr}}
\subsection*{Convert differential motion  to $\mbox{SE}(3)$ homogeneous transform}
\addcontentsline{toc}{section}{delta2tr}


\texttt{T = DELTA2TR(D)} is a homogeneous transform ($4 \times 4$) representing differential
motion \texttt{D} ($6 \times 1$).



The vector \texttt{D}=(dx, dy, dz, dRx, dRy, dRz) represents infinitessimal translation
and rotation, and is an approximation to the instantaneous spatial velocity
multiplied by time step.


\subsection*{Reference}
\begin{itemize}
  \item Robotics, Vision \& Control: Second Edition, P. Corke, Springer 2016; p67.
\end{itemize}

\subsection*{See also}


\hyperlink{tr2delta}{\color{blue} tr2delta}, \hyperlink{SE3.delta}{\color{blue} SE3.delta}

\vspace{1.5ex}\rule{\textwidth}{1mm}

%---------------------- e2h
\hypertarget{e2h}{\section*{e2h}}
\subsection*{Euclidean to homogeneous}
\addcontentsline{toc}{section}{e2h}


\texttt{H = E2H(E)} is the homogeneous version ($K+1 \times N$) of the Euclidean
points \texttt{E} ($K \times N$) where each column represents one point in $\mathbb{R}^{K}$.


\subsection*{Reference}
\begin{itemize}
  \item Robotics, Vision \& Control: Second Edition, P. Corke, Springer 2016; p604.
\end{itemize}

\subsection*{See also}


\hyperlink{h2e}{\color{blue} h2e}

\vspace{1.5ex}\rule{\textwidth}{1mm}

%---------------------- eul2jac
\hypertarget{eul2jac}{\section*{eul2jac}}
\subsection*{Euler angle rate Jacobian}
\addcontentsline{toc}{section}{eul2jac}


\texttt{J = EUL2JAC(PHI, THETA, PSI)} is a Jacobian matrix ($3 \times 3$) that maps ZYZ Euler angle rates to
angular velocity at the operating point specified by the Euler angles \texttt{PHI}, \texttt{THETA}, \texttt{PSI}.



\texttt{J = EUL2JAC(EUL)}  as above but the Euler angles are passed as a vector \texttt{EUL}=[\texttt{PHI}, \texttt{THETA}, \texttt{PSI}].


\subsection*{Notes}
\begin{itemize}
  \item Used in the creation of an analytical Jacobian.
  \item Angles in radians, rates in radians/sec.
\end{itemize}

\subsection*{Reference}
\begin{itemize}
  \item Robotics, Vision \& Control: Second Edition, P. Corke, Springer 2016; p232-3.
\end{itemize}

\subsection*{See also}


\hyperlink{rpy2jac}{\color{blue} rpy2jac}, \hyperlink{eul2r}{\color{blue} eul2r}, \hyperlink{SerialLink.jacobe}{\color{blue} SerialLink.jacobe}

\vspace{1.5ex}\rule{\textwidth}{1mm}

%---------------------- eul2r
\hypertarget{eul2r}{\section*{eul2r}}
\subsection*{Convert Euler angles to rotation matrix}
\addcontentsline{toc}{section}{eul2r}


\texttt{R = EUL2R(PHI, THETA, PSI, OPTIONS)} is an $\mbox{SO}(3)$ orthonornal rotation
matrix ($3 \times 3$) equivalent to the specified Euler angles.  These correspond
to rotations about the Z, Y, Z axes respectively. If \texttt{PHI}, \texttt{THETA}, \texttt{PSI} are
column vectors ($N \times 1$) then they are assumed to represent a trajectory and
\texttt{R} is a three-dimensional matrix ($3 \times 3 \times N$), where the last index corresponds
to rows of \texttt{PHI}, \texttt{THETA}, \texttt{PSI}.



\texttt{R = EUL2R(EUL, OPTIONS)} as above but the Euler angles are taken from the
vector ($1 \times 3$)  \texttt{EUL} = [\texttt{PHI} \texttt{THETA} \texttt{PSI}]. If \texttt{EUL} is a matrix ($N \times 3$) then \texttt{R} is a
three-dimensional matrix ($3 \times 3 \times N$), where the last index corresponds to
rows of RPY which are assumed to be [\texttt{PHI},\texttt{THETA},\texttt{PSI}].


\subsection*{Options}
\begin{longtable}{lp{120mm}}
\textquotesingle deg\textquotesingle  & Angles given in degrees (radians default)\\ 
\end{longtable}\vspace{1ex}

\subsection*{Note}
\begin{itemize}
  \item The vectors \texttt{PHI}, \texttt{THETA}, \texttt{PSI} must be of the same length.
\end{itemize}

\subsection*{See also}


\hyperlink{eul2tr}{\color{blue} eul2tr}, \hyperlink{rpy2tr}{\color{blue} rpy2tr}, \hyperlink{tr2eul}{\color{blue} tr2eul}, \hyperlink{SO3.eul}{\color{blue} SO3.eul}

\vspace{1.5ex}\rule{\textwidth}{1mm}

%---------------------- eul2tr
\hypertarget{eul2tr}{\section*{eul2tr}}
\subsection*{Convert Euler angles to homogeneous transform}
\addcontentsline{toc}{section}{eul2tr}


\texttt{T = EUL2TR(PHI, THETA, PSI, OPTIONS)} is an $\mbox{SE}(3)$ homogeneous
transformation matrix ($4 \times 4$) with zero translation and rotation equivalent
to the specified Euler angles. These correspond to rotations about the Z,
Y, Z axes respectively. If \texttt{PHI}, \texttt{THETA}, \texttt{PSI} are column vectors ($N \times 1$) then
they are assumed to represent a trajectory and R is a three-dimensional
matrix ($4 \times 4 \times N$), where the last index corresponds to rows of \texttt{PHI}, \texttt{THETA},
\texttt{PSI}.



\texttt{R = EUL2R(EUL, OPTIONS)} as above but the Euler angles are taken from the
vector ($1 \times 3$)  \texttt{EUL} = [\texttt{PHI} \texttt{THETA} \texttt{PSI}]. If \texttt{EUL} is a matrix ($N \times 3$) then \texttt{R} is a
three-dimensional matrix ($4 \times 4 \times N$), where the last index corresponds to
rows of RPY which are assumed to be [\texttt{PHI},\texttt{THETA},\texttt{PSI}].


\subsection*{Options}
\begin{longtable}{lp{120mm}}
\textquotesingle deg\textquotesingle  & Angles given in degrees (radians default)\\ 
\end{longtable}\vspace{1ex}

\subsection*{Note}
\begin{itemize}
  \item The vectors \texttt{PHI}, \texttt{THETA}, \texttt{PSI} must be of the same length.
  \item The translational part is zero.
\end{itemize}

\subsection*{See also}


\hyperlink{eul2r}{\color{blue} eul2r}, \hyperlink{rpy2tr}{\color{blue} rpy2tr}, \hyperlink{tr2eul}{\color{blue} tr2eul}, \hyperlink{SE3.eul}{\color{blue} SE3.eul}

\vspace{1.5ex}\rule{\textwidth}{1mm}

%---------------------- h2e
\hypertarget{h2e}{\section*{h2e}}
\subsection*{Homogeneous to Euclidean}
\addcontentsline{toc}{section}{h2e}


\texttt{E = H2E(H)} is the Euclidean version ($K-1 \times N$) of the homogeneous
points \texttt{H} ($K \times N$) where each column represents one point in $\mathbb{P}^{K}$.


\subsection*{Reference}
\begin{itemize}
  \item Robotics, Vision \& Control: Second Edition, P. Corke, Springer 2016; p604.
\end{itemize}

\subsection*{See also}


\hyperlink{e2h}{\color{blue} e2h}

\vspace{1.5ex}\rule{\textwidth}{1mm}

%---------------------- homline
\hypertarget{homline}{\section*{homline}}
\subsection*{Homogeneous line from two points}
\addcontentsline{toc}{section}{homline}


\texttt{L = HOMLINE(X1, Y1, X2, Y2)} is a vector ($3 \times 1$) which describes a line in
homogeneous form that contains the two Euclidean points (\texttt{X1},\texttt{Y1}) and (\texttt{X2},\texttt{Y2}).



Homogeneous points X ($3 \times 1$) on the line must satisfy \texttt{L}\textquotesingle *X = 0.


\subsection*{See also}


\hyperlink{plot_homline}{\color{blue} plot\_homline}

\vspace{1.5ex}\rule{\textwidth}{1mm}

%---------------------- homtrans
\hypertarget{homtrans}{\section*{homtrans}}
\subsection*{Apply a homogeneous transformation}
\addcontentsline{toc}{section}{homtrans}


\texttt{P2 = HOMTRANS(T, P)} applies the homogeneous transformation \texttt{T} to the points
stored columnwise in \texttt{P}.

\begin{itemize}
  \item If \texttt{T} is in $\mbox{SE}(2)$ ($3 \times 3$) and
\begin{itemize}
  \item \texttt{P} is $2 \times N$ (2D points) they are considered Euclidean ($\mathbb{R}^{2}$)
  \item \texttt{P} is $3 \times N$ (2D points) they are considered projective ($\mathbb{P}^{2}$)
\end{itemize}
  \item If \texttt{T} is in $\mbox{SE}(3)$ ($4 \times 4$) and
\begin{itemize}
  \item \texttt{P} is $3 \times N$ (3D points) they are considered Euclidean ($\mathbb{R}^{3}$)
  \item \texttt{P} is $4 \times N$ (3D points) they are considered projective ($\mathbb{P}^{3}$)
\end{itemize}
\end{itemize}


\texttt{P2} and \texttt{P} have the same number of rows, ie. if Euclidean points are given
then Euclidean points are returned, if projective points are given then
projective points are returned.



\texttt{TP = HOMTRANS(T, T1)} applies homogeneous transformation \texttt{T} to the
homogeneous transformation \texttt{T1}, that is \texttt{TP}=\texttt{T}*\texttt{T1}.  If \texttt{T1} is a 3-dimensional
transformation then \texttt{T} is applied to each plane as defined by the first two
dimensions, ie. if \texttt{T} is $N \times N$ and \texttt{T1} is $N \times N \times M$ then the result is $N \times N \times M$.


\subsection*{Notes}
\begin{itemize}
  \item If \texttt{T} is a homogeneous transformation defining the pose of $\{$B$\}$ with respect to $\{$A$\}$,    then the points are defined with respect to frame $\{$B$\}$ and are transformed to be
  \item with respect to frame $\{$A$\}$.
\end{itemize}

\subsection*{See also}


\hyperlink{e2h}{\color{blue} e2h}, \hyperlink{h2e}{\color{blue} h2e}, \hyperlink{RTBPose.mtimes}{\color{blue} RTBPose.mtimes}

\vspace{1.5ex}\rule{\textwidth}{1mm}

%---------------------- ishomog
\hypertarget{ishomog}{\section*{ishomog}}
\subsection*{Test if $\mbox{SE}(3)$ homogeneous transformation matrix}
\addcontentsline{toc}{section}{ishomog}


\texttt{ISHOMOG(T)} is true (1) if the argument \texttt{T} is of dimension $4 \times 4$ or $4 \times 4 \times N$, else
false (0).



\texttt{ISHOMOG(T, 'check')} as above, but also checks the validity of the rotation
sub-matrix.


\subsection*{Notes}
\begin{itemize}
  \item A valid rotation sub-matrix has determinant of 1.
  \item The first form is a fast, but incomplete, test for a transform is $\mbox{SE}(3)$.
\end{itemize}

\subsection*{See also}


\hyperlink{isrot}{\color{blue} isrot}, \hyperlink{ishomog2}{\color{blue} ishomog2}, \hyperlink{isvec}{\color{blue} isvec}

\vspace{1.5ex}\rule{\textwidth}{1mm}

%---------------------- ishomog2
\hypertarget{ishomog2}{\section*{ishomog2}}
\subsection*{Test if $\mbox{SE}(2)$ homogeneous transformation matrix}
\addcontentsline{toc}{section}{ishomog2}


\texttt{ISHOMOG2(T)} is true (1) if the argument \texttt{T} is of dimension $3 \times 3$ or $3 \times 3 \times N$, else
false (0).



\texttt{ISHOMOG2(T, 'check')} as above, but also checks the validity of the rotation
sub-matrix.


\subsection*{Notes}
\begin{itemize}
  \item A valid rotation sub-matrix has determinant of 1.
  \item The first form is a fast, but incomplete, test for a transform in $\mbox{SE}(3)$.
\end{itemize}

\subsection*{See also}


\hyperlink{ishomog}{\color{blue} ishomog}, \hyperlink{isrot2}{\color{blue} isrot2}, \hyperlink{isvec}{\color{blue} isvec}

\vspace{1.5ex}\rule{\textwidth}{1mm}

%---------------------- isrot
\hypertarget{isrot}{\section*{isrot}}
\subsection*{Test if $\mbox{SO}(3)$ rotation matrix}
\addcontentsline{toc}{section}{isrot}


\texttt{ISROT(R)} is true (1) if the argument is of dimension $3 \times 3$ or $3 \times 3 \times N$, else false (0).



\texttt{ISROT(R, 'check')} as above, but also checks the validity of the rotation
matrix.


\subsection*{Notes}
\begin{itemize}
  \item A valid rotation matrix has determinant of 1.
\end{itemize}

\subsection*{See also}


\hyperlink{ishomog}{\color{blue} ishomog}, \hyperlink{isrot2}{\color{blue} isrot2}, \hyperlink{isvec}{\color{blue} isvec}

\vspace{1.5ex}\rule{\textwidth}{1mm}

%---------------------- isrot2
\hypertarget{isrot2}{\section*{isrot2}}
\subsection*{Test if $\mbox{SO}(2)$ rotation matrix}
\addcontentsline{toc}{section}{isrot2}


\texttt{ISROT2(R)} is true (1) if the argument is of dimension $2 \times 2$ or $2 \times 2 \times N$, else false (0).



\texttt{ISROT2(R, 'check')} as above, but also checks the validity of the rotation
matrix.


\subsection*{Notes}
\begin{itemize}
  \item A valid rotation matrix has determinant of 1.
\end{itemize}

\subsection*{See also}


\hyperlink{isrot}{\color{blue} isrot}, \hyperlink{ishomog2}{\color{blue} ishomog2}, \hyperlink{isvec}{\color{blue} isvec}

\vspace{1.5ex}\rule{\textwidth}{1mm}

%---------------------- isunit
\hypertarget{isunit}{\section*{isunit}}
\subsection*{Test if vector has unit length}
\addcontentsline{toc}{section}{isunit}


\texttt{ISUNIT(V)} is true if the vector has unit length.


\subsection*{Notes}
\begin{itemize}
  \item A tolerance of 100eps is used.
\end{itemize}
\vspace{1.5ex}\rule{\textwidth}{1mm}

%---------------------- isvec
\hypertarget{isvec}{\section*{isvec}}
\subsection*{Test if vector}
\addcontentsline{toc}{section}{isvec}


\texttt{ISVEC(V)} is true (1) if the argument \texttt{V} is a 3-vector, either a
row- or column-vector.  Otherwise false (0).



\texttt{ISVEC(V, L)} is true (1) if the argument \texttt{V} is a vector of length \texttt{L},
either a row- or column-vector.  Otherwise false (0).


\subsection*{Notes}
\begin{itemize}
  \item Differs from MATLAB builtin function ISVECTOR which returns true    for the case of a scalar, ISVEC does not.
  \item Gives same result for row- or column-vector, ie. $3 \times 1$ or $1 \times 3$ gives true.
\end{itemize}

\subsection*{See also}


\hyperlink{ishomog}{\color{blue} ishomog}, \hyperlink{isrot}{\color{blue} isrot}

\vspace{1.5ex}\rule{\textwidth}{1mm}

%---------------------- lift23
\hypertarget{lift23}{\section*{lift23}}
\subsection*{Lift $\mbox{SE}(2)$ transform to $\mbox{SE}(3)$}
\addcontentsline{toc}{section}{lift23}


\texttt{T3 = SE3(T2)} returns a homogeneous transform ($4 \times 4$) that represents
the same X,Y translation and Z rotation as does \texttt{T2} ($3 \times 3$).


\subsection*{See also}


\hyperlink{SE2}{\color{blue} SE2}, \hyperlink{SE2.SE3}{\color{blue} SE2.SE3}, \hyperlink{transl}{\color{blue} transl}, \hyperlink{rotx}{\color{blue} rotx}

\vspace{1.5ex}\rule{\textwidth}{1mm}

%---------------------- numcols
\hypertarget{numcols}{\section*{numcols}}
\subsection*{Number of columns in matrix}
\addcontentsline{toc}{section}{numcols}


\texttt{NC = NUMCOLS(M)} is the number of columns in the matrix \texttt{M}.


\subsection*{Notes}
\begin{itemize}
  \item Readable shorthand for SIZE(\texttt{M},2);
\end{itemize}

\subsection*{See also}


\hyperlink{numrows}{\color{blue} numrows}, \hyperlink{size}{\color{blue} size}

\vspace{1.5ex}\rule{\textwidth}{1mm}

%---------------------- numrows
\hypertarget{numrows}{\section*{numrows}}
\subsection*{Number of rows in matrix}
\addcontentsline{toc}{section}{numrows}


\texttt{NR = NUMROWS(M)} is the number of rows in the matrix \texttt{M}.


\subsection*{Notes}
\begin{itemize}
  \item Readable shorthand for SIZE(\texttt{M},1);
\end{itemize}

\subsection*{See also}


\hyperlink{numcols}{\color{blue} numcols}, \hyperlink{size}{\color{blue} size}

\vspace{1.5ex}\rule{\textwidth}{1mm}

%---------------------- oa2r
\hypertarget{oa2r}{\section*{oa2r}}
\subsection*{Convert orientation and approach vectors to rotation matrix}
\addcontentsline{toc}{section}{oa2r}


\texttt{R = OA2R(O, A)} is an $\mbox{SO}(3)$ rotation matrix ($3 \times 3$) for the specified
orientation and approach vectors ($3 \times 1$) formed from 3 vectors such that \texttt{R}
= [N \texttt{O} \texttt{A}] and N = \texttt{O} x \texttt{A}.


\subsection*{Notes}
\begin{itemize}
  \item The matrix is guaranteed to be orthonormal so long as \texttt{O} and \texttt{A}    are not parallel.
  \item The vectors \texttt{O} and \texttt{A} are parallel to the Y- and Z-axes of the coordinate    frame respectively.
\end{itemize}

\subsection*{References}
\begin{itemize}
  \item Robot manipulators: mathematics, programming and control    Richard Paul, MIT Press, 1981.
\end{itemize}

\subsection*{See also}


\hyperlink{rpy2r}{\color{blue} rpy2r}, \hyperlink{eul2r}{\color{blue} eul2r}, \hyperlink{oa2tr}{\color{blue} oa2tr}, \hyperlink{SO3.oa}{\color{blue} SO3.oa}

\vspace{1.5ex}\rule{\textwidth}{1mm}

%---------------------- oa2tr
\hypertarget{oa2tr}{\section*{oa2tr}}
\subsection*{Convert orientation and approach vectors to homogeneous transformation}
\addcontentsline{toc}{section}{oa2tr}


\texttt{T = OA2TR(O, A)} is an $\mbox{SE}(3)$ homogeneous tranformation ($4 \times 4$) for the
specified orientation and approach vectors ($3 \times 1$) formed from 3 vectors
such that R = [N \texttt{O} \texttt{A}] and N = \texttt{O} x \texttt{A}.


\subsection*{Notes}
\begin{itemize}
  \item The rotation submatrix is guaranteed to be orthonormal so long as \texttt{O} and \texttt{A}    are not parallel.
  \item The vectors \texttt{O} and \texttt{A} are parallel to the Y- and Z-axes of the coordinate    frame respectively.
  \item The translational part is zero.
\end{itemize}

\subsection*{References}
\begin{itemize}
  \item Robot manipulators: mathematics, programming and control    Richard Paul, MIT Press, 1981.
\end{itemize}

\subsection*{See also}


\hyperlink{rpy2tr}{\color{blue} rpy2tr}, \hyperlink{eul2tr}{\color{blue} eul2tr}, \hyperlink{oa2r}{\color{blue} oa2r}, \hyperlink{SE3.oa}{\color{blue} SE3.oa}

\vspace{1.5ex}\rule{\textwidth}{1mm}

%---------------------- PGraph
\hypertarget{PGraph}{\section*{PGraph}}
\subsection*{Graph class}
\addcontentsline{toc}{section}{PGraph}
\begin{longtable}{lp{120mm}}
g = PGraph() & create a 2D, planar embedded, directed graph\\ 
g = PGraph(n) & create an n-d, embedded, directed graph\\ 
\end{longtable}\vspace{1ex}


Provides support for graphs that:

\begin{itemize}
  \item are directed
  \item are embedded in a coordinate system (2D or 3D)
  \item have multiple unconnected components
  \item have symmetric cost edges (A to B is same cost as B to A)
  \item have no loops (edges from A to A)
\end{itemize}


Graph representation:

\begin{itemize}
  \item vertices are represented by integer vertex ids (vid)
  \item edges are represented by integer edge ids (eid)
  \item each vertex can have arbitrary associated data
  \item each edge can have arbitrary associated data
\end{itemize}

\subsection*{Methods}

\subsection*{Constructing the graph}
\begin{longtable}{lp{120mm}}
g.add\_node(coord) & add vertex\\ 
g.add\_edge(v1, v2) & add edge fbetween vertices\\ 
g.setcost(e, c) & set cost for edge\\ 
g.setedata(e, u) & set user data for edge\\ 
g.setvdata(v, u) & set user data for vertex\\ 
\end{longtable}\vspace{1ex}

\subsection*{Modifying the graph}
\begin{longtable}{lp{120mm}}
g.clear() & remove all vertices and edges from the graph\\ 
g.delete\_edge(e) & remove edge\\ 
g.delete\_node(v) & remove vertex\\ 
g.setcoord(v) & set coordinate of vertex\\ 
\end{longtable}\vspace{1ex}

\subsection*{Information from graph}
\begin{longtable}{lp{120mm}}
g.about() & summary information about node\\ 
g.component(v) & component id for vertex\\ 
g.componentnodes(c) & vertices in component\\ 
g.connectivity() & number of edges for all vertices\\ 
g.connectivity\_in() & number of incoming edges for all vertices\\ 
g.connectivity\_out() & number of outgoing edges for all vertices\\ 
g.coord(v) & coordinate of vertex\\ 
g.cost(e) & cost of edge\\ 
g.distance\_metric(v1,v2) & distance between nodes\\ 
g.edata(e) & get edge user data\\ 
g.edgedir(v1,v2) & direction of edge\\ 
g.edges(v) & list of edges for vertex\\ 
g.edges\_in(v) & list of edges into vertex\\ 
g.edges\_out(v) & list of edges from vertex\\ 
g.lookup(name) & vertex from name\\ 
g.name(v) & name of vertex\\ 
g.neighbours(v) & neighbours of vertex\\ 
g.neighbours\_d(v) & neighbours of vertex and edge directions\\ 
g.neighbours\_in(v) & neighbours with edges in\\ 
g.neighbours\_out(v) & neighbours with edges out\\ 
g.samecomponent(v1,v2) & test if vertices in same component\\ 
g.vdata(v) & vertex user data\\ 
g.vertices(e) & vertices for edge\\ 
\end{longtable}\vspace{1ex}

\subsection*{Display}
\begin{longtable}{lp{120mm}}
g.char() & convert graph to string\\ 
g.display() & display summary of graph\\ 
g.highlight\_node(v) & highlight vertex\\ 
g.highlight\_edge(e) & highlight edge\\ 
g.highlight\_component(c) & highlight all nodes in component\\ 
g.highlight\_path(p) & highlight nodes and edge along path\\ 
g.pick(coord) & vertex closest to coord\\ 
g.plot() & plot graph\\ 
\end{longtable}\vspace{1ex}

\subsection*{Matrix representations}
\begin{longtable}{lp{120mm}}
g.adjacency() & adjacency matrix\\ 
g.degree() & degree matrix\\ 
g.incidence() & incidence matrix\\ 
g.laplacian() & Laplacian  matrix\\ 
\end{longtable}\vspace{1ex}

\subsection*{Planning paths through the graph}
\begin{longtable}{lp{120mm}}
g.Astar(s, g) & shortest path from s to g\\ 
g.goal(v) & set goal vertex, and plan paths\\ 
g.path(v) & list of vertices from v to goal\\ 
\end{longtable}\vspace{1ex}

\subsection*{Graph and world points}
\begin{longtable}{lp{120mm}}
g.closest(coord) & vertex closest to coord\\ 
g.coord(v) & coordinate of vertex v\\ 
g.distance(v1, v2) & distance between v1 and v2\\ 
g.distances(coord) & return sorted distances from coord to all vertices\\ 
\end{longtable}\vspace{1ex}

\subsection*{Object properties (read only)}
\begin{longtable}{lp{120mm}}
g.n & number of vertices\\ 
g.ne & number of edges\\ 
g.nc & number of components\\ 
\end{longtable}\vspace{1ex}

\subsection*{Example}
\begin{Code}
   g = PGraph();
   g.add_node([1 2]');  % add node 1
   g.add_node([3 4]');  % add node 1
   g.add_node([1 3]');  % add node 1
   g.add_edge(1, 2);    % add edge 1-2
   g.add_edge(2, 3);    % add edge 2-3
   g.add_edge(1, 3);    % add edge 1-3
   g.plot()

\end{Code}

\subsection*{Notes}
\begin{itemize}
  \item Support for edge direction is quite simple.
  \item The method distance\_metric() could be redefined in a subclass.
\end{itemize}
\vspace{1.5ex}\hrule

%---------------------- PGraph.PGraph
\hypertarget{PGraph.PGraph}{\section*{PGraph.PGraph}}
\subsection*{Graph class constructor}
\addcontentsline{tom}{section}{PGraph.PGraph}


\texttt{G=PGraph(D, OPTIONS)} is a graph object embedded in \texttt{D} dimensions.


\subsection*{Options}
\begin{longtable}{lp{120mm}}
\textquotesingle distance\textquotesingle ,M                  \textquotesingle Euclidean\textquotesingle  (default) or \textquotesingle SE2\textquotesingle . & Use the distance metric M for path planning which is either\\ 
\textquotesingle verbose\textquotesingle  & Specify verbose operation\\ 
\end{longtable}\vspace{1ex}

\subsection*{Notes}
\begin{itemize}
  \item Number of dimensions is not limited to 2 or 3.
  \item The distance metric \textquotesingle SE2\textquotesingle  is the sum of the squares of the difference    in position and angle modulo $2\pi$.
  \item To use a different distance metric create a subclass of PGraph and    override the method distance\_metric().
\end{itemize}
\vspace{1.5ex}\hrule

%---------------------- PGraph.add\_edge
\hypertarget{PGraph.add\_edge}{\section*{PGraph.add\_edge}}
\subsection*{Add an edge}
\addcontentsline{tom}{section}{PGraph.add\_edge}


\texttt{E = G.add\_edge(V1, V2)} adds a directed edge from vertex id \texttt{V1} to vertex id \texttt{V2}, and
returns the edge id \texttt{E}.  The edge cost is the distance between the vertices.



\texttt{E = G.add\_edge(V1, V2, C)} as above but the edge cost is \texttt{C}.


\subsection*{Notes}
\begin{itemize}
  \item If \texttt{V2} is a vector add edges from \texttt{V1} to all elements of \texttt{V2}
  \item Distance is computed according to the metric specified in the    constructor.
\end{itemize}

\subsection*{See also}


\hyperlink{PGraph.add_node}{\color{blue} PGraph.add\_node}, \hyperlink{PGraph.edgedir}{\color{blue} PGraph.edgedir}

\vspace{1.5ex}\hrule

%---------------------- PGraph.add\_node
\hypertarget{PGraph.add\_node}{\section*{PGraph.add\_node}}
\subsection*{Add a node}
\addcontentsline{tom}{section}{PGraph.add\_node}


\texttt{V = G.add\_node(X)} adds a node/vertex with coordinate \texttt{X} ($D \times 1$) and
returns the integer node id \texttt{V}.



\texttt{V = G.add\_node(X, VFROM)} as above but connected by a directed edge from vertex \texttt{VFROM} with cost equal to the distance between the vertices.



\texttt{V = G.add\_node(X, V2, C)} as above but the added edge has cost \texttt{C}.


\subsection*{Notes}
\begin{itemize}
  \item Distance is computed according to the metric specified in the    constructor.
\end{itemize}

\subsection*{See also}


\hyperlink{PGraph.add_edge}{\color{blue} PGraph.add\_edge}, \hyperlink{PGraph.data}{\color{blue} PGraph.data}, \hyperlink{PGraph.getdata}{\color{blue} PGraph.getdata}

\vspace{1.5ex}\hrule

%---------------------- PGraph.adjacency
\hypertarget{PGraph.adjacency}{\section*{PGraph.adjacency}}
\subsection*{Adjacency matrix of graph}
\addcontentsline{tom}{section}{PGraph.adjacency}


\texttt{A = G.adjacency()} is a matrix ($N \times N$) where element \texttt{A}(i,j) is the cost
of moving from vertex i to vertex j.


\subsection*{Notes}
\begin{itemize}
  \item Matrix is symmetric.
  \item Eigenvalues of \texttt{A} are real and are known as the spectrum of the graph.
  \item The element \texttt{A}(I,J) can be considered the number of walks of one    edge from vertex I to vertex J (either zero or one).  The element (I,J)
  \item of \texttt{A}${}^{N}$ are the number of walks of length N from vertex I to vertex J.
\end{itemize}

\subsection*{See also}


\hyperlink{PGraph.degree}{\color{blue} PGraph.degree}, \hyperlink{PGraph.incidence}{\color{blue} PGraph.incidence}, \hyperlink{PGraph.laplacian}{\color{blue} PGraph.laplacian}

\vspace{1.5ex}\hrule

%---------------------- PGraph.Astar
\hypertarget{PGraph.Astar}{\section*{PGraph.Astar}}
\subsection*{path finding}
\addcontentsline{tom}{section}{PGraph.Astar}


\texttt{PATH = G.Astar(V1, V2)} is the lowest cost path from vertex \texttt{V1} to
vertex \texttt{V2}.  \texttt{PATH} is a list of vertices starting with \texttt{V1} and ending
\texttt{V2}.



\texttt{[PATH,C] = G.Astar(V1, V2)} as above but also returns the total cost
of traversing \texttt{PATH}.


\subsection*{Notes}
\begin{itemize}
  \item Uses the efficient A* search algorithm.
  \item The heuristic is the distance function selected in the constructor, it    must be  admissible, meaning that it never overestimates the actual
  \item cost to get to the nearest goal node.
\end{itemize}

\subsection*{References}
\begin{itemize}
  \item Correction to ``A Formal Basis for the Heuristic Determination of Minimum Cost Paths''.    Hart, P. E.; Nilsson, N. J.; Raphael, B.
  \item SIGART Newsletter 37: 28-29, 1972.
\end{itemize}

\subsection*{See also}


\hyperlink{PGraph.goal}{\color{blue} PGraph.goal}, \hyperlink{PGraph.path}{\color{blue} PGraph.path}

\vspace{1.5ex}\hrule

%---------------------- PGraph.char
\hypertarget{PGraph.char}{\section*{PGraph.char}}
\subsection*{Convert graph to string}
\addcontentsline{tom}{section}{PGraph.char}


\texttt{S = G.char()} is a compact human readable representation of the
state of the graph including the number of vertices, edges and components.

\vspace{1.5ex}\hrule

%---------------------- PGraph.clear
\hypertarget{PGraph.clear}{\section*{PGraph.clear}}
\subsection*{Clear the graph}
\addcontentsline{tom}{section}{PGraph.clear}


\texttt{G.clear()} removes all vertices, edges and components.

\vspace{1.5ex}\hrule

%---------------------- PGraph.closest
\hypertarget{PGraph.closest}{\section*{PGraph.closest}}
\subsection*{Find closest vertex}
\addcontentsline{tom}{section}{PGraph.closest}


\texttt{V = G.closest(X)} is the vertex geometrically closest to coordinate \texttt{X}.



\texttt{[V,D] = G.closest(X)} as above but also returns the distance \texttt{D}.


\subsection*{See also}


\hyperlink{PGraph.distances}{\color{blue} PGraph.distances}

\vspace{1.5ex}\hrule

%---------------------- PGraph.component
\hypertarget{PGraph.component}{\section*{PGraph.component}}
\subsection*{Graph component}
\addcontentsline{tom}{section}{PGraph.component}


\texttt{C = G.component(V)} is the id of the graph component that contains vertex
\texttt{V}.

\vspace{1.5ex}\hrule

%---------------------- PGraph.componentnodes
\hypertarget{PGraph.componentnodes}{\section*{PGraph.componentnodes}}
\subsection*{Graph component}
\addcontentsline{tom}{section}{PGraph.componentnodes}


\texttt{C = G.component(V)} are the ids of all vertices in the graph component \texttt{V}.

\vspace{1.5ex}\hrule

%---------------------- PGraph.connectivity
\hypertarget{PGraph.connectivity}{\section*{PGraph.connectivity}}
\subsection*{Node connectivity}
\addcontentsline{tom}{section}{PGraph.connectivity}


\texttt{C = G.connectivity()} is a vector ($N \times 1$) with the number of edges per
vertex.



The average vertex connectivity is

\begin{Code}
   mean(g.connectivity())

\end{Code}


and the minimum vertex connectivity is

\begin{Code}
   min(g.connectivity())

\end{Code}
\vspace{1.5ex}\hrule

%---------------------- PGraph.connectivity\_in
\hypertarget{PGraph.connectivity\_in}{\section*{PGraph.connectivity\_in}}
\subsection*{Graph connectivity}
\addcontentsline{tom}{section}{PGraph.connectivity\_in}


\texttt{C = G.connectivity()} is a vector ($N \times 1$) with the number of incoming edges per
vertex.



The average vertex connectivity is

\begin{Code}
   mean(g.connectivity())

\end{Code}


and the minimum vertex connectivity is

\begin{Code}
   min(g.connectivity())

\end{Code}
\vspace{1.5ex}\hrule

%---------------------- PGraph.connectivity\_out
\hypertarget{PGraph.connectivity\_out}{\section*{PGraph.connectivity\_out}}
\subsection*{Graph connectivity}
\addcontentsline{tom}{section}{PGraph.connectivity\_out}


\texttt{C = G.connectivity()} is a vector ($N \times 1$) with the number of outgoing edges per
vertex.



The average vertex connectivity is

\begin{Code}
   mean(g.connectivity())

\end{Code}


and the minimum vertex connectivity is

\begin{Code}
   min(g.connectivity())

\end{Code}
\vspace{1.5ex}\hrule

%---------------------- PGraph.coord
\hypertarget{PGraph.coord}{\section*{PGraph.coord}}
\subsection*{Coordinate of node}
\addcontentsline{tom}{section}{PGraph.coord}


\texttt{X = G.coord(V)} is the coordinate vector ($D \times 1$) of vertex id \texttt{V}.

\vspace{1.5ex}\hrule

%---------------------- PGraph.cost
\hypertarget{PGraph.cost}{\section*{PGraph.cost}}
\subsection*{Cost of edge}
\addcontentsline{tom}{section}{PGraph.cost}


\texttt{C = G.cost(E)} is the cost of edge id \texttt{E}.

\vspace{1.5ex}\hrule

%---------------------- PGraph.degree
\hypertarget{PGraph.degree}{\section*{PGraph.degree}}
\subsection*{Degree matrix of graph}
\addcontentsline{tom}{section}{PGraph.degree}


\texttt{D = G.degree()} is a diagonal matrix ($N \times N$) where element \texttt{D}(i,i) is the number
of edges connected to vertex id i.


\subsection*{See also}


\hyperlink{PGraph.adjacency}{\color{blue} PGraph.adjacency}, \hyperlink{PGraph.incidence}{\color{blue} PGraph.incidence}, \hyperlink{PGraph.laplacian}{\color{blue} PGraph.laplacian}

\vspace{1.5ex}\hrule

%---------------------- PGraph.display
\hypertarget{PGraph.display}{\section*{PGraph.display}}
\subsection*{Display graph}
\addcontentsline{tom}{section}{PGraph.display}


\texttt{G.display()} displays a compact human readable representation of the
state of the graph including the number of vertices, edges and components.


\subsection*{See also}


\hyperlink{PGraph.char}{\color{blue} PGraph.char}

\vspace{1.5ex}\hrule

%---------------------- PGraph.distance
\hypertarget{PGraph.distance}{\section*{PGraph.distance}}
\subsection*{Distance between vertices}
\addcontentsline{tom}{section}{PGraph.distance}


\texttt{D = G.distance(V1, V2)} is the geometric distance between
the vertices \texttt{V1} and \texttt{V2}.


\subsection*{See also}


\hyperlink{PGraph.distances}{\color{blue} PGraph.distances}

\vspace{1.5ex}\hrule

%---------------------- PGraph.distances
\hypertarget{PGraph.distances}{\section*{PGraph.distances}}
\subsection*{Distances from point to vertices}
\addcontentsline{tom}{section}{PGraph.distances}


\texttt{D = G.distances(X)} is a vector ($1 \times N$) of geometric distance from the point
\texttt{X} ($\texttt{D} \times 1$) to every other vertex sorted into increasing order.



\texttt{[D,W] = G.distances(P)} as above but also returns \texttt{W} ($1 \times N$) with the
corresponding vertex id.


\subsection*{Notes}
\begin{itemize}
  \item Distance is computed according to the metric specified in the    constructor.
\end{itemize}

\subsection*{See also}


\hyperlink{PGraph.closest}{\color{blue} PGraph.closest}

\vspace{1.5ex}\hrule

%---------------------- PGraph.dotfile
\hypertarget{PGraph.dotfile}{\section*{PGraph.dotfile}}
\subsection*{Create a GraphViz dot file}
\addcontentsline{tom}{section}{PGraph.dotfile}


\texttt{G.dotfile(filename, OPTIONS)} creates the specified file which contains the
GraphViz code to represent the embedded graph.



\texttt{G.dotfile(OPTIONS)} as above but outputs the code to the console.


\subsection*{Options}
\begin{longtable}{lp{120mm}}
\textquotesingle directed\textquotesingle  & create a directed graph\\ 
\end{longtable}\vspace{1ex}

\subsection*{Notes}
\begin{itemize}
  \item An undirected graph is default
  \item Use neato rather than dot to get the embedded layout
\end{itemize}
\vspace{1.5ex}\hrule

%---------------------- PGraph.edata
\hypertarget{PGraph.edata}{\section*{PGraph.edata}}
\subsection*{Get user data for node}
\addcontentsline{tom}{section}{PGraph.edata}


\texttt{U = G.data(V)} gets the user data of vertex \texttt{V} which can be of any
type such as a number, struct, object or cell array.


\subsection*{See also}


\hyperlink{PGraph.setdata}{\color{blue} PGraph.setdata}

\vspace{1.5ex}\hrule

%---------------------- PGraph.edgedir
\hypertarget{PGraph.edgedir}{\section*{PGraph.edgedir}}
\subsection*{Find edge direction}
\addcontentsline{tom}{section}{PGraph.edgedir}


\texttt{D = G.edgedir(V1, V2)} is the direction of the edge from vertex id \texttt{V1}
to vertex id \texttt{V2}.



If we add an edge from vertex 3 to vertex 4

\begin{Code}
   g.add_edge(3, 4)
\end{Code}


then

\begin{Code}
   g.edgedir(3, 4)
\end{Code}


is positive, and

\begin{Code}
   g.edgedir(4, 3)
\end{Code}


is negative.


\subsection*{See also}


\hyperlink{PGraph.add_node}{\color{blue} PGraph.add\_node}, \hyperlink{PGraph.add_edge}{\color{blue} PGraph.add\_edge}

\vspace{1.5ex}\hrule

%---------------------- PGraph.edges
\hypertarget{PGraph.edges}{\section*{PGraph.edges}}
\subsection*{Find edges given vertex}
\addcontentsline{tom}{section}{PGraph.edges}


\texttt{E = G.edges(V)} is a vector containing the id of all edges connected to vertex id \texttt{V}.


\subsection*{See also}


\hyperlink{PGraph.edgedir}{\color{blue} PGraph.edgedir}

\vspace{1.5ex}\hrule

%---------------------- PGraph.edges\_in
\hypertarget{PGraph.edges\_in}{\section*{PGraph.edges\_in}}
\subsection*{Find edges given vertex}
\addcontentsline{tom}{section}{PGraph.edges\_in}


\texttt{E = G.edges(V)} is a vector containing the id of all edges connected to vertex id \texttt{V}.


\subsection*{See also}


\hyperlink{PGraph.edgedir}{\color{blue} PGraph.edgedir}

\vspace{1.5ex}\hrule

%---------------------- PGraph.edges\_out
\hypertarget{PGraph.edges\_out}{\section*{PGraph.edges\_out}}
\subsection*{Find edges given vertex}
\addcontentsline{tom}{section}{PGraph.edges\_out}


\texttt{E = G.edges(V)} is a vector containing the id of all edges connected to vertex id \texttt{V}.


\subsection*{See also}


\hyperlink{PGraph.edgedir}{\color{blue} PGraph.edgedir}

\vspace{1.5ex}\hrule

%---------------------- PGraph.get.n
\hypertarget{PGraph.get.n}{\section*{PGraph.get.n}}
\subsection*{Number of vertices}
\addcontentsline{tom}{section}{PGraph.get.n}


\texttt{G.n} is the number of vertices in the graph.


\subsection*{See also}


\hyperlink{PGraph.ne}{\color{blue} PGraph.ne}

\vspace{1.5ex}\hrule

%---------------------- PGraph.get.nc
\hypertarget{PGraph.get.nc}{\section*{PGraph.get.nc}}
\subsection*{Number of components}
\addcontentsline{tom}{section}{PGraph.get.nc}


\texttt{G.nc} is the number of components in the graph.


\subsection*{See also}


\hyperlink{PGraph.component}{\color{blue} PGraph.component}

\vspace{1.5ex}\hrule

%---------------------- PGraph.get.ne
\hypertarget{PGraph.get.ne}{\section*{PGraph.get.ne}}
\subsection*{Number of edges}
\addcontentsline{tom}{section}{PGraph.get.ne}


\texttt{G.ne} is the number of edges in the graph.


\subsection*{See also}


\hyperlink{PGraph.n}{\color{blue} PGraph.n}

\vspace{1.5ex}\hrule

%---------------------- PGraph.graphcolor
\hypertarget{PGraph.graphcolor}{\section*{PGraph.graphcolor}}
\subsection*{the graph}
\addcontentsline{tom}{section}{PGraph.graphcolor}
\vspace{1.5ex}\hrule

%---------------------- PGraph.highlight\_component
\hypertarget{PGraph.highlight\_component}{\section*{PGraph.highlight\_component}}
\subsection*{Highlight a graph component}
\addcontentsline{tom}{section}{PGraph.highlight\_component}


\texttt{G.highlight\_component(C, OPTIONS)} highlights the vertices that belong to
graph component \texttt{C}.


\subsection*{Options}
\begin{longtable}{lp{120mm}}
\textquotesingle NodeSize\textquotesingle ,S & Size of vertex circle (default 12)\\ 
\textquotesingle NodeFaceColor\textquotesingle ,C & Node circle color (default yellow)\\ 
\textquotesingle NodeEdgeColor\textquotesingle ,C & Node circle edge color (default blue)\\ 
\end{longtable}\vspace{1ex}

\subsection*{See also}


\hyperlink{PGraph.highlight_node}{\color{blue} PGraph.highlight\_node}, \hyperlink{PGraph.highlight_edge}{\color{blue} PGraph.highlight\_edge}, \hyperlink{PGraph.highlight_component}{\color{blue} PGraph.highlight\_component}

\vspace{1.5ex}\hrule

%---------------------- PGraph.highlight\_edge
\hypertarget{PGraph.highlight\_edge}{\section*{PGraph.highlight\_edge}}
\subsection*{Highlight a node}
\addcontentsline{tom}{section}{PGraph.highlight\_edge}


\texttt{G.highlight\_edge(V1, V2)} highlights the edge between vertices \texttt{V1} and \texttt{V2}.



\texttt{G.highlight\_edge(E)} highlights the edge with id \texttt{E}.


\subsection*{Options}
\begin{longtable}{lp{120mm}}
\textquotesingle EdgeColor\textquotesingle ,C & Edge edge color (default black)\\ 
\textquotesingle EdgeThickness\textquotesingle ,T & Edge thickness (default 1.5)\\ 
\end{longtable}\vspace{1ex}

\subsection*{See also}


\hyperlink{PGraph.highlight_node}{\color{blue} PGraph.highlight\_node}, \hyperlink{PGraph.highlight_path}{\color{blue} PGraph.highlight\_path}, \hyperlink{PGraph.highlight_component}{\color{blue} PGraph.highlight\_component}

\vspace{1.5ex}\hrule

%---------------------- PGraph.highlight\_node
\hypertarget{PGraph.highlight\_node}{\section*{PGraph.highlight\_node}}
\subsection*{Highlight a node}
\addcontentsline{tom}{section}{PGraph.highlight\_node}


\texttt{G.highlight\_node(V, OPTIONS)} highlights the vertex \texttt{V} with a yellow marker.
If \texttt{V} is a list of vertices then all are highlighted.


\subsection*{Options}
\begin{longtable}{lp{120mm}}
\textquotesingle NodeSize\textquotesingle ,S & Size of vertex circle (default 12)\\ 
\textquotesingle NodeFaceColor\textquotesingle ,C & Node circle color (default yellow)\\ 
\textquotesingle NodeEdgeColor\textquotesingle ,C & Node circle edge color (default blue)\\ 
\end{longtable}\vspace{1ex}

\subsection*{See also}


\hyperlink{PGraph.highlight_edge}{\color{blue} PGraph.highlight\_edge}, \hyperlink{PGraph.highlight_path}{\color{blue} PGraph.highlight\_path}, \hyperlink{PGraph.highlight_component}{\color{blue} PGraph.highlight\_component}

\vspace{1.5ex}\hrule

%---------------------- PGraph.highlight\_path
\hypertarget{PGraph.highlight\_path}{\section*{PGraph.highlight\_path}}
\subsection*{Highlight path}
\addcontentsline{tom}{section}{PGraph.highlight\_path}


\texttt{G.highlight\_path(P, OPTIONS)} highlights the path defined by vector \texttt{P}
which is a list of vertex ids comprising the path.


\subsection*{Options}
\begin{longtable}{lp{120mm}}
\textquotesingle NodeSize\textquotesingle ,S & Size of vertex circle (default 12)\\ 
\textquotesingle NodeFaceColor\textquotesingle ,C & Node circle color (default yellow)\\ 
\textquotesingle NodeEdgeColor\textquotesingle ,C & Node circle edge color (default blue)\\ 
\textquotesingle EdgeColor\textquotesingle ,C & Node circle edge color (default black)\\ 
\textquotesingle EdgeThickness\textquotesingle ,T & Edge thickness (default 1.5)\\ 
\end{longtable}\vspace{1ex}

\subsection*{See also}


\hyperlink{PGraph.highlight_node}{\color{blue} PGraph.highlight\_node}, \hyperlink{PGraph.highlight_edge}{\color{blue} PGraph.highlight\_edge}, \hyperlink{PGraph.highlight_component}{\color{blue} PGraph.highlight\_component}

\vspace{1.5ex}\hrule

%---------------------- PGraph.incidence
\hypertarget{PGraph.incidence}{\section*{PGraph.incidence}}
\subsection*{Incidence matrix of graph}
\addcontentsline{tom}{section}{PGraph.incidence}


\texttt{IN = G.incidence()} is a matrix ($N \times NE$) where element \texttt{IN}(i,j) is
non-zero if vertex id i is connected to edge id j.


\subsection*{See also}


\hyperlink{PGraph.adjacency}{\color{blue} PGraph.adjacency}, \hyperlink{PGraph.degree}{\color{blue} PGraph.degree}, \hyperlink{PGraph.laplacian}{\color{blue} PGraph.laplacian}

\vspace{1.5ex}\hrule

%---------------------- PGraph.laplacian
\hypertarget{PGraph.laplacian}{\section*{PGraph.laplacian}}
\subsection*{Laplacian matrix of graph}
\addcontentsline{tom}{section}{PGraph.laplacian}


\texttt{L = G.laplacian()} is the Laplacian matrix ($N \times N$) of the graph.


\subsection*{Notes}
\begin{itemize}
  \item \texttt{L} is always positive-semidefinite.
  \item \texttt{L} has at least one zero eigenvalue.
  \item The number of zero eigenvalues is the number of connected components    in the graph.
\end{itemize}

\subsection*{See also}


\hyperlink{PGraph.adjacency}{\color{blue} PGraph.adjacency}, \hyperlink{PGraph.incidence}{\color{blue} PGraph.incidence}, \hyperlink{PGraph.degree}{\color{blue} PGraph.degree}

\vspace{1.5ex}\hrule

%---------------------- PGraph.name
\hypertarget{PGraph.name}{\section*{PGraph.name}}
\subsection*{Name of node}
\addcontentsline{tom}{section}{PGraph.name}


\texttt{X = G.name(V)} is the name (string) of vertex id \texttt{V}.

\vspace{1.5ex}\hrule

%---------------------- PGraph.neighbours
\hypertarget{PGraph.neighbours}{\section*{PGraph.neighbours}}
\subsection*{Neighbours of a vertex}
\addcontentsline{tom}{section}{PGraph.neighbours}


\texttt{N = G.neighbours(V)} is a vector of ids for all vertices which are
directly connected neighbours of vertex \texttt{V}.



\texttt{[N,C] = G.neighbours(V)} as above but also returns a vector \texttt{C} whose elements
are the edge costs of the paths corresponding to the vertex ids in \texttt{N}.

\vspace{1.5ex}\hrule

%---------------------- PGraph.neighbours\_d
\hypertarget{PGraph.neighbours\_d}{\section*{PGraph.neighbours\_d}}
\subsection*{Directed neighbours of a vertex}
\addcontentsline{tom}{section}{PGraph.neighbours\_d}


\texttt{N = G.neighbours\_d(V)} is a vector of ids for all vertices which are
directly connected neighbours of vertex \texttt{V}.  Elements are positive
if there is a link from \texttt{V} to the node (outgoing), and negative if the link
is from the node to \texttt{V} (incoming).



\texttt{[N,C] = G.neighbours\_d(V)} as above but also returns a vector \texttt{C} whose elements
are the edge costs of the paths corresponding to the vertex ids in \texttt{N}.

\vspace{1.5ex}\hrule

%---------------------- PGraph.neighbours\_in
\hypertarget{PGraph.neighbours\_in}{\section*{PGraph.neighbours\_in}}
\subsection*{Incoming neighbours of a vertex}
\addcontentsline{tom}{section}{PGraph.neighbours\_in}


\texttt{N = G.neighbours(V)} is a vector of ids for all vertices which are
directly connected neighbours of vertex \texttt{V}.



\texttt{[N,C] = G.neighbours(V)} as above but also returns a vector \texttt{C} whose elements
are the edge costs of the paths corresponding to the vertex ids in \texttt{N}.

\vspace{1.5ex}\hrule

%---------------------- PGraph.neighbours\_out
\hypertarget{PGraph.neighbours\_out}{\section*{PGraph.neighbours\_out}}
\subsection*{Outgoing neighbours of a vertex}
\addcontentsline{tom}{section}{PGraph.neighbours\_out}


\texttt{N = G.neighbours(V)} is a vector of ids for all vertices which are
directly connected neighbours of vertex \texttt{V}.



\texttt{[N,C] = G.neighbours(V)} as above but also returns a vector \texttt{C} whose elements
are the edge costs of the paths corresponding to the vertex ids in \texttt{N}.

\vspace{1.5ex}\hrule

%---------------------- PGraph.pick
\hypertarget{PGraph.pick}{\section*{PGraph.pick}}
\subsection*{Graphically select a vertex}
\addcontentsline{tom}{section}{PGraph.pick}


\texttt{V = G.pick()} is the id of the vertex closest to the point clicked
by the user on a plot of the graph.


\subsection*{See also}


\hyperlink{PGraph.plot}{\color{blue} PGraph.plot}

\vspace{1.5ex}\hrule

%---------------------- PGraph.plot
\hypertarget{PGraph.plot}{\section*{PGraph.plot}}
\subsection*{Plot the graph}
\addcontentsline{tom}{section}{PGraph.plot}


\texttt{G.plot(OPT)} plots the graph in the current figure.  Nodes
are shown as colored circles.


\subsection*{Options}
\begin{longtable}{lp{120mm}}
\textquotesingle labels\textquotesingle  & Display vertex id (default false)\\ 
\textquotesingle edges\textquotesingle  & Display edges (default true)\\ 
\textquotesingle edgelabels\textquotesingle  & Display edge id (default false)\\ 
\textquotesingle NodeSize\textquotesingle ,S & Size of vertex circle (default 8)\\ 
\textquotesingle NodeFaceColor\textquotesingle ,C & Node circle color (default blue)\\ 
\textquotesingle NodeEdgeColor\textquotesingle ,C & Node circle edge color (default blue)\\ 
\textquotesingle NodeLabelSize\textquotesingle ,S & Node label text sizer (default 16)\\ 
\textquotesingle NodeLabelColor\textquotesingle ,C & Node label text color (default blue)\\ 
\textquotesingle EdgeColor\textquotesingle ,C & Edge color (default black)\\ 
\textquotesingle EdgeLabelSize\textquotesingle ,S & Edge label text size (default black)\\ 
\textquotesingle EdgeLabelColor\textquotesingle ,C & Edge label text color (default black)\\ 
\textquotesingle componentcolor\textquotesingle  & Node color is a function of graph component\\ 
\textquotesingle only\textquotesingle ,N & Only show these nodes\\ 
\end{longtable}\vspace{1ex}
\vspace{1.5ex}\hrule

%---------------------- PGraph.samecomponent
\hypertarget{PGraph.samecomponent}{\section*{PGraph.samecomponent}}
\subsection*{Graph component}
\addcontentsline{tom}{section}{PGraph.samecomponent}


\texttt{C = G.component(V)} is the id of the graph component that contains vertex
\texttt{V}.

\vspace{1.5ex}\hrule

%---------------------- PGraph.setcoord
\hypertarget{PGraph.setcoord}{\section*{PGraph.setcoord}}
\subsection*{Coordinate of node}
\addcontentsline{tom}{section}{PGraph.setcoord}


\texttt{X = G.coord(V)} is the coordinate vector ($D \times 1$) of vertex id \texttt{V}.

\vspace{1.5ex}\hrule

%---------------------- PGraph.setcost
\hypertarget{PGraph.setcost}{\section*{PGraph.setcost}}
\subsection*{Set cost of edge}
\addcontentsline{tom}{section}{PGraph.setcost}


\texttt{G.setcost(E, C)} set cost of edge id \texttt{E} to \texttt{C}.

\vspace{1.5ex}\hrule

%---------------------- PGraph.setedata
\hypertarget{PGraph.setedata}{\section*{PGraph.setedata}}
\subsection*{Set user data for node}
\addcontentsline{tom}{section}{PGraph.setedata}


\texttt{G.setdata(V, U)} sets the user data of vertex \texttt{V} to \texttt{U} which can be of any
type such as a number, struct, object or cell array.


\subsection*{See also}


\hyperlink{PGraph.data}{\color{blue} PGraph.data}

\vspace{1.5ex}\hrule

%---------------------- PGraph.setvdata
\hypertarget{PGraph.setvdata}{\section*{PGraph.setvdata}}
\subsection*{Set user data for node}
\addcontentsline{tom}{section}{PGraph.setvdata}


\texttt{G.setdata(V, U)} sets the user data of vertex \texttt{V} to \texttt{U} which can be of any
type such as a number, struct, object or cell array.


\subsection*{See also}


\hyperlink{PGraph.data}{\color{blue} PGraph.data}

\vspace{1.5ex}\hrule

%---------------------- PGraph.vdata
\hypertarget{PGraph.vdata}{\section*{PGraph.vdata}}
\subsection*{Get user data for node}
\addcontentsline{tom}{section}{PGraph.vdata}


\texttt{U = G.data(V)} gets the user data of vertex \texttt{V} which can be of any
type such as a number, struct, object or cell array.


\subsection*{See also}


\hyperlink{PGraph.setdata}{\color{blue} PGraph.setdata}

\vspace{1.5ex}\hrule

%---------------------- PGraph.vertices
\hypertarget{PGraph.vertices}{\section*{PGraph.vertices}}
\subsection*{Find vertices given edge}
\addcontentsline{tom}{section}{PGraph.vertices}


\texttt{V = G.vertices(E)} return the id of the vertices that define edge \texttt{E}.

\vspace{1.5ex}\rule{\textwidth}{1mm}

%---------------------- plot2
\hypertarget{plot2}{\section*{plot2}}
\subsection*{Plot trajectories}
\addcontentsline{toc}{section}{plot2}


Convenience function for plotting 2D or 3D trajectory data stored in a
matrix with one row per time step.



\texttt{PLOT2(P)} plots a line with coordinates taken from successive rows of \texttt{P}($N \times 2$ or $N \times 3$).



If \texttt{P} has three dimensions, ie. $N \times 2 \times M$ or $N \times 3 \times M$ then the M trajectories are
overlaid in the one plot.



\texttt{PLOT2(P, LS)} as above but the line style arguments \texttt{LS} are passed to plot.


\subsection*{See also}


\hyperlink{mplot}{\color{blue} mplot}, \hyperlink{plot}{\color{blue} plot}

\vspace{1.5ex}\rule{\textwidth}{1mm}

%---------------------- plot\_arrow
\hypertarget{plot\_arrow}{\section*{plot\_arrow}}
\subsection*{Draw an arrow in 2D or 3D}
\addcontentsline{toc}{section}{plot\_arrow}


\texttt{PLOT\_ARROW(P1, P2, OPTIONS)} draws an arrow from \texttt{P1} to \texttt{P2} ($2 \times 1$ or $3 \times 1$).  For 3D
case the arrow head is a cone.



\texttt{PLOT\_ARROW(P, OPTIONS)} as above where the columns of \texttt{P} ($2 \times 2$ or $3 \times 2$) define the
start and end points, ie. \texttt{P}=[\texttt{P1} \texttt{P2}].



\texttt{H = PLOT\_ARROW(...)} as above but returns the graphics handle of the arrow.


\subsection*{Options}
\begin{itemize}
  \item All options are passed through to arrow3.
  \item MATLAB LineSpec such as \textquotesingle r\textquotesingle  or \textquotesingle b--\textquotesingle 
\end{itemize}

\subsection*{Example}
\begin{Code}
   plot_arrow([0 0 0]', [1 2 3]', 'r')  % a red arrow
   plot_arrow([0 0 0], [1 2 3], 'r--3', 4) % dashed red arrow big head

\end{Code}

\subsection*{Notes}
\begin{itemize}
  \item Requires \url{https://www.mathworks.com/matlabcentral/fileexchange/14056-arrow3}
  \item ARROW3 attempts to preserve the appearance of existing axes.  In    particular, ARROW3 will not change XYZLim, View, or CameraViewAngle.
\end{itemize}

\subsection*{See also}


\hyperlink{arrow3}{\color{blue} arrow3}

\vspace{1.5ex}\rule{\textwidth}{1mm}

%---------------------- plot\_box
\hypertarget{plot\_box}{\section*{plot\_box}}
\subsection*{Draw a box}
\addcontentsline{toc}{section}{plot\_box}


\texttt{PLOT\_BOX(B, OPTIONS)} draws a box defined by \texttt{B}=[XL XR; YL YR] on the current
plot with optional MATLAB linestyle options LS.



\texttt{PLOT\_BOX(X1,Y1, X2,Y2, OPTIONS)} draws a box with corners at (\texttt{X1},\texttt{Y1}) and (\texttt{X2},\texttt{Y2}),
and optional MATLAB linestyle options LS.



\texttt{PLOT\_BOX('centre', P, 'size', W, OPTIONS)} draws a box with center at \texttt{P}=[X,Y] and
with dimensions \texttt{W}=[WIDTH HEIGHT].



\texttt{PLOT\_BOX('topleft', P, 'size', W, OPTIONS)} draws a box with top-left at \texttt{P}=[X,Y]
and with dimensions \texttt{W}=[WIDTH HEIGHT].



\texttt{PLOT\_BOX('matlab', BOX, LS)} draws box(es) as defined using the MATLAB convention of
specifying a region in terms of top-left coordinate, width and height.  One box is
drawn for each row of \texttt{BOX} which is [xleft ytop width height].



\texttt{H = PLOT\_ARROW(...)} as above but returns the graphics handle of the arrow.


\subsection*{Options}
\begin{longtable}{lp{120mm}}
\textquotesingle edgecolor\textquotesingle  & the color of the circle\textquotesingle s edge, MATLAB ColorSpec\\ 
\textquotesingle fillcolor\textquotesingle  & the color of the circle\textquotesingle s interior, MATLAB ColorSpec\\ 
\textquotesingle alpha\textquotesingle  & transparency of the filled circle: 0=transparent, 1=solid\\ 
\end{longtable}\vspace{1ex}
\begin{itemize}
  \item For an unfilled box:
\begin{itemize}
  \item any standard MATLAB LineSpec such as \textquotesingle r\textquotesingle  or \textquotesingle b---\textquotesingle .
  \item any MATLAB LineProperty options can be given such as \textquotesingle LineWidth\textquotesingle , 2.
\end{itemize}
  \item For a filled box any MATLAB PatchProperty options can be given.
\end{itemize}

\subsection*{Examples}
\begin{Code}
    plot_box([0 1; 0 2], 'r')   % draw a hollow red box
    plot_box([0 1; 0 2], 'fillcolor', 'b', 'alpha', 0.5)   % translucent filled blue box

\end{Code}

\subsection*{Notes}
\begin{itemize}
  \item The box is added to the current plot irrespective of hold status.
\end{itemize}

\subsection*{See also}


\hyperlink{plot_poly}{\color{blue} plot\_poly}, \hyperlink{plot_circle}{\color{blue} plot\_circle}, \hyperlink{plot_ellipse}{\color{blue} plot\_ellipse}

\vspace{1.5ex}\rule{\textwidth}{1mm}

%---------------------- plot\_circle
\hypertarget{plot\_circle}{\section*{plot\_circle}}
\subsection*{Draw a circle}
\addcontentsline{toc}{section}{plot\_circle}


plot\_circleC, R, OPTIONS) draws a circle on the current plot with
centre C=[X,Y] and radius R.  If C=[X,Y,Z] the circle is drawn in the
XY-plane at height Z.



If C ($2 \times N$) then N circles are drawn.  If R ($1 \times 1$) then all
circles have the same radius or else R ($1 \times N$) to specify the radius of
each circle.



\texttt{H = plot\_circle(...)} as above but return handles. For multiple
circles \texttt{H} is a vector of handles, one per circle.


\subsection*{Options}
\begin{longtable}{lp{120mm}}
\textquotesingle edgecolor\textquotesingle  & the color of the circle\textquotesingle s edge, Matlab color spec\\ 
\textquotesingle fillcolor\textquotesingle  & the color of the circle\textquotesingle s interior, Matlab color spec\\ 
\textquotesingle alpha\textquotesingle  & transparency of the filled circle: 0=transparent, 1=solid\\ 
\textquotesingle alter\textquotesingle ,H & alter existing circles with handle \texttt{H}\\ 
\end{longtable}\vspace{1ex}
\begin{itemize}
  \item For an unfilled circle:
\begin{itemize}
  \item any standard MATLAB LineStyle such as \textquotesingle r\textquotesingle  or \textquotesingle b---\textquotesingle .
  \item any MATLAB LineProperty options can be given such as \textquotesingle LineWidth\textquotesingle , 2.
\end{itemize}
  \item For a filled circle any MATLAB PatchProperty options can be given.
\end{itemize}

\subsection*{Example}
\begin{Code}
    H = plot_circle([3 4]', 2, 'r');  % draw red circle
    plot_circle([3 4]', 3, 'alter', H); % change the circle radius
    plot_circle([3 4]', 3, 'alter', H, 'LineColor', 'k'); % change the color

\end{Code}

\subsection*{Notes}
\begin{itemize}
  \item The \textquotesingle alter\textquotesingle  option can be used to create a smooth animation.
  \item The circle(s) is added to the current plot irrespective of hold status.
\end{itemize}

\subsection*{See also}


\hyperlink{plot_ellipse}{\color{blue} plot\_ellipse}, \hyperlink{plot_box}{\color{blue} plot\_box}, \hyperlink{plot_poly}{\color{blue} plot\_poly}

\vspace{1.5ex}\rule{\textwidth}{1mm}

%---------------------- plot\_ellipse
\hypertarget{plot\_ellipse}{\section*{plot\_ellipse}}
\subsection*{Draw an ellipse or ellipsoid}
\addcontentsline{toc}{section}{plot\_ellipse}


\texttt{plot\_ellipse(E, OPTIONS)} draws an ellipse or ellipsoid defined by X\textquotesingle EX =
0 on the current plot, centred at the origin.  \texttt{E} ($2 \times 2$) for an ellipse and
\texttt{E} ($2 \times 3$) for an ellipsoid.



\texttt{plot\_ellipse(E, C, OPTIONS)} as above but centred at \texttt{C}=[X,Y].  If
\texttt{C}=[X,Y,Z] the ellipse is parallel to the XY plane but at height Z.



\texttt{H = plot\_ellipse(...)} as above but return graphic handle.


\subsection*{Options}
\begin{longtable}{lp{120mm}}
\textquotesingle confidence\textquotesingle ,C & confidence interval, range 0 to 1\\ 
\textquotesingle alter\textquotesingle ,H & alter existing ellipses with handle \texttt{H}\\ 
\textquotesingle npoints\textquotesingle ,N & use N points to define the ellipse (default 40)\\ 
\textquotesingle edgecolor\textquotesingle  & color of the ellipse boundary edge, MATLAB color spec\\ 
\textquotesingle fillcolor\textquotesingle  & the color of the ellipses\textquotesingle s interior, MATLAB color spec\\ 
\textquotesingle alpha\textquotesingle  & transparency of the fillcolored ellipse: 0=transparent, 1=solid\\ 
\textquotesingle shadow\textquotesingle  & show shadows on the 3 walls of the plot box\\ 
\end{longtable}\vspace{1ex}
\begin{itemize}
  \item For an unfilled ellipse:
\begin{itemize}
  \item any standard MATLAB LineStyle such as \textquotesingle r\textquotesingle  or \textquotesingle b---\textquotesingle .
  \item any MATLAB LineProperty options can be given such as \textquotesingle LineWidth\textquotesingle , 2.
\end{itemize}
  \item For a filled ellipse any MATLAB PatchProperty options can be given.
\end{itemize}

\subsection*{Example}
\begin{Code}
    H = plot_ellipse(diag([1 2]), [3 4]', 'r'); % draw red ellipse
    plot_ellipse(diag([1 2]), [5 6]', 'alter', H); % move the ellipse
    plot_ellipse(diag([1 2]), [5 6]', 'alter', H, 'LineColor', 'k'); % change color

    plot_ellipse(COVAR, 'confidence', 0.95); % draw 95% confidence ellipse

\end{Code}

\subsection*{Notes}
\begin{itemize}
  \item The \textquotesingle alter\textquotesingle  option can be used to create a smooth animation.
  \item If \texttt{E} ($2 \times 2$) draw an ellipse, else if \texttt{E} ($3 \times 3$) draw an ellipsoid.
  \item The ellipse is added to the current plot irrespective of hold status.
  \item Shadow option only valid for ellipsoids.
  \item If a confidence interval is given then \texttt{E} is interpretted as a covariance    matrix and the ellipse size is computed using an approximate inverse
  \item chi-squared function.
\end{itemize}

\subsection*{See also}


\hyperlink{plot_ellipse_inv}{\color{blue} plot\_ellipse\_inv}, \hyperlink{plot_circle}{\color{blue} plot\_circle}, \hyperlink{plot_box}{\color{blue} plot\_box}, \hyperlink{plot_poly}{\color{blue} plot\_poly}, \hyperlink{ch2inv_rtb}{\color{blue} ch2inv\_rtb}

\vspace{1.5ex}\rule{\textwidth}{1mm}

%---------------------- plot\_homline
\hypertarget{plot\_homline}{\section*{plot\_homline}}
\subsection*{Draw a line in homogeneous form}
\addcontentsline{toc}{section}{plot\_homline}


\texttt{PLOT\_HOMLINE(L)} draws a 2D line in the current plot defined in homogenous
form ax + by + c = 0  where \texttt{L} ($3 \times 1$) is \texttt{L} = [a b c].
The current axis limits are used to determine the endpoints of
the line.  If \texttt{L} ($3 \times N$) then N lines are drawn, one per column.



\texttt{PLOT\_HOMLINE(L, LS)} as above but the MATLAB line specification \texttt{LS} is given.



\texttt{H = PLOT\_HOMLINE(...)} as above but returns a vector of graphics handles for the lines.


\subsection*{Notes}
\begin{itemize}
  \item The line(s) is added to the current plot.
  \item The line(s) can be drawn in 3D axes but will always lie in the    xy-plane.
\end{itemize}

\subsection*{Example}
\begin{Code}
    L = homline([1 2]', [3 1]'); % homog line from (1,2) to (3,1)
    plot_homline(L, 'k--'); % plot dashed black line

\end{Code}

\subsection*{See also}


\hyperlink{plot_box}{\color{blue} plot\_box}, \hyperlink{plot_poly}{\color{blue} plot\_poly}, \hyperlink{homline}{\color{blue} homline}

\vspace{1.5ex}\rule{\textwidth}{1mm}

%---------------------- plot\_point
\hypertarget{plot\_point}{\section*{plot\_point}}
\subsection*{Draw a point}
\addcontentsline{toc}{section}{plot\_point}


\texttt{PLOT\_POINT(P, OPTIONS)} adds point markers and optional annotation text
to the current plot, where \texttt{P} ($2 \times N$) and each column is a point coordinate.



\texttt{H = PLOT\_POINT(...)} as above but return handles to the points.


\subsection*{Options}
\begin{longtable}{lp{120mm}}
\textquotesingle textcolor\textquotesingle , colspec & Specify color of text\\ 
\textquotesingle textsize\textquotesingle , size & Specify size of text\\ 
\textquotesingle bold\textquotesingle  & Text in bold font.\\ 
\textquotesingle printf\textquotesingle , {fmt, data}                            string and corresponding element of data & Label points according to printf format\\ 
\textquotesingle sequence\textquotesingle  & Label points sequentially\\ 
\textquotesingle label\textquotesingle ,L & Label for point\\ 
\end{longtable}\vspace{1ex}


Additional options to PLOT can be used:

\begin{itemize}
  \item standard MATLAB LineStyle such as \textquotesingle r\textquotesingle  or \textquotesingle b---\textquotesingle 
  \item any MATLAB LineProperty options can be given such as \textquotesingle LineWidth\textquotesingle , 2.
\end{itemize}

\subsection*{Notes}
\begin{itemize}
  \item The point(s) and annotations are added to the current plot.
  \item Points can be drawn in 3D axes but will always lie in the    xy-plane.
  \item Handles are to the points but not the annotations.
\end{itemize}

\subsection*{Examples}


Simple point plot with two markers

\begin{Code}
  P = rand(2,4);
  plot_point(P);

\end{Code}


Plot points with markers

\begin{Code}
  plot_point(P, '*');

\end{Code}


Plot points with solid blue circular markers

\begin{Code}
  plot_point(P, 'bo', 'MarkerFaceColor', 'b');

\end{Code}


Plot points with square markers and labelled 1 to 4

\begin{Code}
  plot_point(P, 'sequence', 's');

\end{Code}


Plot points with circles and labelled P1, P2, P4 and P8

\begin{Code}
  data = [1 2 4 8];
  plot_point(P, 'printf', {' P%d', data}, 'o');

\end{Code}
\vspace{1.5ex}\rule{\textwidth}{1mm}

%---------------------- plot\_poly
\hypertarget{plot\_poly}{\section*{plot\_poly}}
\subsection*{Draw a polygon}
\addcontentsline{toc}{section}{plot\_poly}


\texttt{plot\_poly(P, OPTIONS)} adds a closed polygon defined by vertices in the columns
of \texttt{P} ($2 \times N$), in the current plot.



\texttt{H = plot\_poly(...)} as above but returns a graphics handle.



plot\_poly(\texttt{H}, )


\subsection*{\texttt{OPTIONS}}
\begin{longtable}{lp{120mm}}
\textquotesingle fillcolor\textquotesingle ,F & the color of the circle\textquotesingle s interior, MATLAB color spec\\ 
\textquotesingle alpha\textquotesingle ,A & transparency of the filled circle: 0=transparent, 1=solid.\\ 
\textquotesingle edgecolor\textquotesingle ,E & edge color\\ 
\textquotesingle animate\textquotesingle  & the polygon can be animated\\ 
\textquotesingle tag\textquotesingle ,T & the polygon is created with a handle graphics tag\\ 
\textquotesingle axis\textquotesingle ,h & handle of axis or UIAxis to draw into (default is current axis)\\ 
\end{longtable}\vspace{1ex}
\begin{itemize}
  \item For an unfilled polygon:
\begin{itemize}
  \item any standard MATLAB LineStyle such as \textquotesingle r\textquotesingle  or \textquotesingle b---\textquotesingle .
  \item any MATLAB LineProperty options can be given such as \textquotesingle LineWidth\textquotesingle , 2.
\end{itemize}
  \item For a filled polygon any MATLAB PatchProperty options can be given.
\end{itemize}

\subsection*{Notes}
\begin{itemize}
  \item If \texttt{P} ($3 \times N$) the polygon is drawn in 3D
  \item If not filled the polygon is a line segment, otherwise it is a patch    object.
  \item The \textquotesingle animate\textquotesingle  option creates an hgtransform object as a parent of the    polygon, which can be animated by the last call signature above.
  \item The graphics are added to the current plot.
\end{itemize}

\subsection*{Example}
\begin{Code}
    POLY = [0 1 2; 0 1 0];
    H = plot_poly(POLY, 'animate', 'r'); % draw a red polygon

    H = plot_poly(POLY, 'animate', 'r'); % draw a red polygon that can be animated
    plot_poly(H, transl(2,1,0) );  % transform its vertices by (2,1)

\end{Code}

\subsection*{See also}


\hyperlink{plot_box}{\color{blue} plot\_box}, \hyperlink{plot_circle}{\color{blue} plot\_circle}, \hyperlink{patch}{\color{blue} patch}, \hyperlink{Polygon}{\color{blue} Polygon}

\vspace{1.5ex}\rule{\textwidth}{1mm}

%---------------------- plot\_ribbon
\hypertarget{plot\_ribbon}{\section*{plot\_ribbon}}
\subsection*{Draw a wide curved 3D arrow}
\addcontentsline{toc}{section}{plot\_ribbon}


\texttt{plot\_ribbon()} adds a 3D curved arrow ``ribbon'' to the current plot.  The ribbon by
default is about the z-axis at the origin.


\subsection*{Options}
\begin{longtable}{lp{120mm}}
\textquotesingle radius\textquotesingle ,R & radius of the ribbon (default 0.25)\\ 
\textquotesingle N\textquotesingle ,N & number of points along the ribbon (default 100)\\ 
 & \\ 
\textquotesingle d\textquotesingle ,D & ratio of shaft length to total  (default 0.9)\\ 
\textquotesingle w1\textquotesingle ,W & width of shaft (default 0.2)\\ 
\textquotesingle w2\textquotesingle ,W & width of head (default 0.4)\\ 
\textquotesingle phi\textquotesingle ,P & length of ribbon as fraction of circle (default 0.8)\\ 
\textquotesingle phase\textquotesingle ,P & rotate the arrow about its axis (radians, default 0)\\ 
 & \\ 
\textquotesingle color\textquotesingle ,C & color as MATLAB ColorSpec (default \textquotesingle r\textquotesingle )\\ 
\textquotesingle specular\textquotesingle ,S & specularity of surface (default 0.2)\\ 
\textquotesingle diffuse\textquotesingle ,D & diffusivity of surface (default 0.8)\\ 
 & \\ 
\textquotesingle nice\textquotesingle  & adjust the phase for nicely phased arrow\\ 
\end{longtable}\vspace{1ex}


The parameters of the ribbon are:

\begin{Code}
    ^
    |                            | \
    |  ^  +----------------------|  \
    |  |  |                          .
    |  v  +----------------------|  /
    |  w1                        | /
    v     <---------- d --------->
   w2    <----------- phi ---------->

\end{Code}

\subsection*{Examples}


To draw the ribbon at distance A along the X, Y, Z axes is:

\begin{Code}
    plot_ribbon2( SE3(A,0,0)*SE3.Ry(pi/2) )
    plot_ribbon2( SE3(0, A,0)*SE3.Rx(pi/2) )
    plot_ribbon2( SE3(0, 0, A) )
    shading interp
    camlight

\end{Code}

\subsection*{See also}


\hyperlink{plot_arrow}{\color{blue} plot\_arrow}, \hyperlink{plot}{\color{blue} plot}

\vspace{1.5ex}\rule{\textwidth}{1mm}

%---------------------- plot\_sphere
\hypertarget{plot\_sphere}{\section*{plot\_sphere}}
\subsection*{Draw sphere}
\addcontentsline{toc}{section}{plot\_sphere}


\texttt{PLOT\_SPHERE(C, R, LS)} draws spheres in the current plot.  \texttt{C} is the
centre of the sphere ($3 \times 1$), \texttt{R} is the radius and \texttt{LS} is an optional MATLAB
ColorSpec, either a letter or a 3-vector.



\texttt{PLOT\_SPHERE(C, R, COLOR, ALPHA)} as above but \texttt{ALPHA} specifies the opacity
of the sphere where 0 is transparant and 1 is opaque.  The default is 1.



If \texttt{C} ($3 \times N$) then N sphhere are drawn and H is $N \times 1$.  If \texttt{R} ($1 \times 1$) then all
spheres have the same radius or else \texttt{R} ($1 \times N$) to specify the radius of
each sphere.



\texttt{H = PLOT\_SPHERE(...)} as above but returns the handle(s) for the
spheres.


\subsection*{Notes}
\begin{itemize}
  \item The sphere is always added, irrespective of figure hold state.
  \item The number of vertices to draw the sphere is hardwired.
\end{itemize}

\subsection*{Example}
\begin{Code}
   plot_sphere( mkgrid(2, 1), .2, 'b'); % Create four spheres
   lighting gouraud  % full lighting model
   light

\end{Code}

\subsection*{See also}


\hyperlink{: plot_point}{\color{blue} : plot\_point}, \hyperlink{plot_box}{\color{blue} plot\_box}, \hyperlink{plot_circle}{\color{blue} plot\_circle}, \hyperlink{plot_ellipse}{\color{blue} plot\_ellipse}, \hyperlink{plot_poly}{\color{blue} plot\_poly}

\vspace{1.5ex}\rule{\textwidth}{1mm}

%---------------------- plotvol
\hypertarget{plotvol}{\section*{plotvol}}
\subsection*{Set the bounds for a 2D or 3D plot}
\addcontentsline{toc}{section}{plotvol}


2D plots::



\texttt{PLOTVOL([WX WY])} creates a new axis, and sets the bounds for a 2D plot,
with X spanning [-WX, WX] and Y spanning [-WY,WY].



\texttt{PLOTVOL([XMIN XMAX YMIN YMAX])} as above but the X and Y axis limits are explicitly provided.



3D plots::



\texttt{PLOTVOL(W)} creates a new axis, and sets the bounds for a 3D plot with X, Y and Z spanning
the interval -\texttt{W} to \texttt{W}.



\texttt{PLOTVOL([WX WY WZ])} as above with X spanning [-WX, WX], Y spanning [-WY, WY] and Z
spanning [-WZ, WZ].


\subsection*{Notes}
\begin{itemize}
  \item The axes are labelled, grid is enabled, aspect ratio set to 1:1.
  \item Hold is enabled for subsequent plots.
\end{itemize}

\subsection*{See also}


\hyperlink{: axis}{\color{blue} : axis}

\vspace{1.5ex}\rule{\textwidth}{1mm}

%---------------------- Plucker
\hypertarget{Plucker}{\section*{Plucker}}
\subsection*{Plucker coordinate class}
\addcontentsline{toc}{section}{Plucker}


Concrete class to represent a 3D line using Plucker coordinates.


\subsection*{Methods}
\begin{longtable}{lp{120mm}}
Plucker & Contructor from points\\ 
Plucker.planes & Constructor from planes\\ 
Plucker.pointdir & Constructor from point and direction\\ 
\end{longtable}\vspace{1ex}

\subsection*{Information and test methods}
\begin{longtable}{lp{120mm}}
closest & closest point on line\\ 
commonperp & common perpendicular for two lines\\ 
contains & test if point is on line\\ 
distance & minimum distance between two lines\\ 
intersects & intersection point for two lines\\ 
intersect\_plane & intersection points with a plane\\ 
intersect\_volume & intersection points with a volume\\ 
pp & principal point\\ 
ppd & principal point distance from origin\\ 
point & generate point on line\\ 
\end{longtable}\vspace{1ex}

\subsection*{Conversion methods}
\begin{longtable}{lp{120mm}}
char & convert to human readable string\\ 
double & convert to 6-vector\\ 
skew & convert to $4 \times 4$ skew symmetric matrix\\ 
\end{longtable}\vspace{1ex}

\subsection*{Display and print methods}
\begin{longtable}{lp{120mm}}
display & display in human readable form\\ 
plot & plot line\\ 
\end{longtable}\vspace{1ex}

\subsection*{Operators}
\begin{longtable}{lp{120mm}}
\textasteriskcentered  & multiply Plucker matrix by a general matrix\\ 
| & test if lines are parallel\\ 
\textasciicircum  & test if lines intersect\\ 
== & test if two lines are equivalent\\ 
$\sim=$ & test if lines are not equivalent\\ 
\end{longtable}\vspace{1ex}

\subsection*{Notes}
\begin{itemize}
  \item This is reference (handle) class object
  \item Plucker objects can be used in vectors and arrays
\end{itemize}

\subsection*{References}
\begin{itemize}
  \item Ken Shoemake, ``Ray Tracing News'', Volume 11, Number 1     \url{http://www.realtimerendering.com/resources/RTNews/html/rtnv11n1.html}\#art3
  \item Matt Mason lecture notes \url{http://www.cs.cmu.edu/afs/cs/academic/class/16741-s07/www/lectures/lecture9.pdf}
  \item Robotics, Vision \& Control: Second Edition, P. Corke, Springer 2016; p596-7.
\end{itemize}

\subsection*{Implementation notes}
\begin{itemize}
  \item The internal representation is two 3-vectors: v (direction), w (moment).
  \item There is a huge variety of notation used across the literature, as well as the ordering     of the direction and moment components in the 6-vector.
\end{itemize}
\vspace{1.5ex}\hrule

%---------------------- Plucker.Plucker
\hypertarget{Plucker.Plucker}{\section*{Plucker.Plucker}}
\subsection*{Create Plucker line object}
\addcontentsline{tom}{section}{Plucker.Plucker}


\texttt{P = Plucker(P1, P2)} create a \textbf{\color{red} Plucker} object that represents
the line joining the 3D points \texttt{P1} ($3 \times 1$) and \texttt{P2} ($3 \times 1$). The direction
is from \texttt{P2} to \texttt{P1}.



\texttt{P = Plucker(X)} creates a \textbf{\color{red} Plucker} object from \texttt{X} ($6 \times 1$) = [V,W] where
V ($3 \times 1$) is the moment and W ($3 \times 1$) is the line direction.



\texttt{P = Plucker(L)} creates a copy of the \textbf{\color{red} Plucker} object \texttt{L}.

\vspace{1.5ex}\hrule

%---------------------- Plucker.char
\hypertarget{Plucker.char}{\section*{Plucker.char}}
\subsection*{Convert to string}
\addcontentsline{tom}{section}{Plucker.char}


\texttt{s = P.char()} is a string showing \textbf{\color{red} Plucker} parameters in a compact single
line format.


\subsection*{See also}


\hyperlink{Plucker.display}{\color{blue} Plucker.display}

\vspace{1.5ex}\hrule

%---------------------- Plucker.closest
\hypertarget{Plucker.closest}{\section*{Plucker.closest}}
\subsection*{Point on line closest to given point}
\addcontentsline{tom}{section}{Plucker.closest}


\texttt{P = PL.closest(X)} is the coordinate of a point ($3 \times 1$) on the line that is
closest to the point \texttt{X} ($3 \times 1$).



\texttt{[P,d] = PL.closest(X)} as above but also returns the minimum distance
between the point and the line.



\texttt{[P,dist,lambda] = PL.closest(X)} as above but also returns the line parameter
\texttt{lambda} corresponding to the point on the line, ie. \texttt{P} = PL.point(\texttt{lambda})


\subsection*{See also}


\hyperlink{Plucker.point}{\color{blue} Plucker.point}

\vspace{1.5ex}\hrule

%---------------------- Plucker.commonperp
\hypertarget{Plucker.commonperp}{\section*{Plucker.commonperp}}
\subsection*{Common perpendicular to two lines}
\addcontentsline{tom}{section}{Plucker.commonperp}


\texttt{P = PL1.commonperp(PL2)} is a \textbf{\color{red} Plucker} object representing the common
perpendicular line between the lines represented by the Plucker objects
PL1 and \texttt{PL2}.


\subsection*{See also}


\hyperlink{Plucker.intersect}{\color{blue} Plucker.intersect}

\vspace{1.5ex}\hrule

%---------------------- Plucker.contains
\hypertarget{Plucker.contains}{\section*{Plucker.contains}}
\subsection*{Test if point is on the line}
\addcontentsline{tom}{section}{Plucker.contains}


\texttt{PL.contains(X)} is true if the point \texttt{X} ($3 \times 1$) lies on the line defined by
the Plucker object PL.

\vspace{1.5ex}\hrule

%---------------------- Plucker.display
\hypertarget{Plucker.display}{\section*{Plucker.display}}
\subsection*{Display parameters}
\addcontentsline{tom}{section}{Plucker.display}


\texttt{P.display()} displays the \textbf{\color{red} Plucker} parameters in compact single line format.


\subsection*{Notes}
\begin{itemize}
  \item This method is invoked implicitly at the command line when the result     of an expression is a Plucker object and the command has no trailing
  \item semicolon.
\end{itemize}

\subsection*{See also}


\hyperlink{Plucker.char}{\color{blue} Plucker.char}

\vspace{1.5ex}\hrule

%---------------------- Plucker.distance
\hypertarget{Plucker.distance}{\section*{Plucker.distance}}
\subsection*{Distance between lines}
\addcontentsline{tom}{section}{Plucker.distance}


\texttt{d = P1.distance(P2)} is the minimum distance between two lines represented
by Plucker objects P1 and \texttt{P2}.


\subsection*{Notes}
\begin{itemize}
  \item Works for parallel, skew and intersecting lines.
\end{itemize}
\vspace{1.5ex}\hrule

%---------------------- Plucker.double
\hypertarget{Plucker.double}{\section*{Plucker.double}}
\subsection*{Convert Plucker coordinates to real vector}
\addcontentsline{tom}{section}{Plucker.double}


\texttt{PL.double()} is a vector ($6 \times 1$) comprising the \textbf{\color{red} Plucker} moment and direction vectors.

\vspace{1.5ex}\hrule

%---------------------- Plucker.eq
\hypertarget{Plucker.eq}{\section*{Plucker.eq}}
\subsection*{Test if two lines are equivalent}
\addcontentsline{tom}{section}{Plucker.eq}


PL1 == PL2 is true if the \textbf{\color{red} Plucker} objects describe the same line in
space.  Note that because of the over parameterization, lines can be
equivalent even if they have different parameters.

\vspace{1.5ex}\hrule

%---------------------- Plucker.get.uw
\hypertarget{Plucker.get.uw}{\section*{Plucker.get.uw}}
\subsection*{Line direction as a unit vector}
\addcontentsline{tom}{section}{Plucker.get.uw}


\texttt{PL.UW} is a unit-vector parallel to the line

\vspace{1.5ex}\hrule

%---------------------- Plucker.intersect\_plane
\hypertarget{Plucker.intersect\_plane}{\section*{Plucker.intersect\_plane}}
\subsection*{Line intersection with plane}
\addcontentsline{tom}{section}{Plucker.intersect\_plane}


\texttt{X = PL.intersect\_plane(PI)} is the point where the \textbf{\color{red} Plucker} line PL
intersects the plane \texttt{PI}.  \texttt{X}=[] if no intersection.



The plane \texttt{PI} can be either:

\begin{itemize}
  \item a vector ($1 \times 4$) = [a b c d] to describe the plane ax+by+cz+d=0.
  \item a structure with a normal \texttt{PI}.n ($3 \times 1$) and an offset \texttt{PI}.p     ($1 \times 1$) such that \texttt{PI}.n \texttt{X} + \texttt{PI}.p = 0.
\end{itemize}


\texttt{[X,lambda] = PL.intersect\_plane(P)} as above but also returns the
line parameter at the intersection point, ie. \texttt{X} = PL.point(\texttt{lambda}).


\subsection*{See also}


\hyperlink{Plucker.point}{\color{blue} Plucker.point}

\vspace{1.5ex}\hrule

%---------------------- Plucker.intersect\_volume
\hypertarget{Plucker.intersect\_volume}{\section*{Plucker.intersect\_volume}}
\subsection*{Line intersection with volume}
\addcontentsline{tom}{section}{Plucker.intersect\_volume}


\texttt{P = PL.intersect\_volume(BOUNDS)} is a matrix ($3 \times N$) with columns
that indicate where the Plcuker line PL intersects the faces of a volume
specified by \texttt{BOUNDS} = [xmin xmax ymin ymax zmin zmax].  The number of
columns N is either 0 (the line is outside the plot volume) or 2 (where
the line pierces the bounding volume).



\texttt{[P,lambda] = PL.intersect\_volume(bounds, line)} as above but also returns the
\texttt{line} parameters ($1 \times N$) at the intersection points, ie. X = PL.point(\texttt{lambda}).


\subsection*{See also}


\hyperlink{Plucker.plot}{\color{blue} Plucker.plot}, \hyperlink{Plucker.point}{\color{blue} Plucker.point}

\vspace{1.5ex}\hrule

%---------------------- Plucker.intersects
\hypertarget{Plucker.intersects}{\section*{Plucker.intersects}}
\subsection*{Find intersection of two lines}
\addcontentsline{tom}{section}{Plucker.intersects}


\texttt{P = P1.intersects(P2)} is the point of intersection ($3 \times 1$) of the lines
represented by Plucker objects P1 and \texttt{P2}.  \texttt{P} = [] if the lines
do not intersect, or the lines are equivalent.


\subsection*{Notes}
\begin{itemize}
  \item Can be used in operator form as P1${}^{P2}$.
  \item Returns [] if the lines are equivalent (P1==\texttt{P2}) since they would intersect at     an infinite number of points.
\end{itemize}

\subsection*{See also}


\hyperlink{Plucker.commonperp}{\color{blue} Plucker.commonperp}, \hyperlink{Plucker.eq}{\color{blue} Plucker.eq}, \hyperlink{Plucker.mpower}{\color{blue} Plucker.mpower}

\vspace{1.5ex}\hrule

%---------------------- Plucker.isparallel
\hypertarget{Plucker.isparallel}{\section*{Plucker.isparallel}}
\subsection*{Test if lines are parallel}
\addcontentsline{tom}{section}{Plucker.isparallel}


\texttt{P1.isparallel(P2)} is true if the lines represented by \textbf{\color{red} Plucker} objects P1
and \texttt{P2} are parallel.


\subsection*{See also}


\hyperlink{Plucker.or}{\color{blue} Plucker.or}, \hyperlink{Plucker.intersects}{\color{blue} Plucker.intersects}

\vspace{1.5ex}\hrule

%---------------------- Plucker.mpower
\hypertarget{Plucker.mpower}{\section*{Plucker.mpower}}
\subsection*{Test if lines intersect}
\addcontentsline{tom}{section}{Plucker.mpower}


\texttt{P1\textasciicircum P2} is true if lines represented by \textbf{\color{red} Plucker} objects \texttt{P1}
and \texttt{P2} intersect at a point.


\subsection*{Notes}
\begin{itemize}
  \item Is false if the lines are equivalent since they would intersect at     an infinite number of points.
\end{itemize}

\subsection*{See also}


\hyperlink{Plucker.intersects}{\color{blue} Plucker.intersects}, \hyperlink{Plucker.parallel}{\color{blue} Plucker.parallel}

\vspace{1.5ex}\hrule

%---------------------- Plucker.mtimes
\hypertarget{Plucker.mtimes}{\section*{Plucker.mtimes}}
\subsection*{Plucker multiplication}
\addcontentsline{tom}{section}{Plucker.mtimes}


\texttt{PL1 * PL2} is the scalar reciprocal product.



\texttt{PL * M} is the product of the \textbf{\color{red} Plucker} skew matrix and \texttt{M} ($4 \times N$).



\texttt{M * PL} is the product of \texttt{M} ($N \times 4$) and the \textbf{\color{red} Plucker} skew matrix ($4 \times 4$).


\subsection*{Notes}
\begin{itemize}
  \item The * operator is overloaded for convenience.
  \item Multiplication or composition of Plucker lines is not defined.
  \item Premultiplying by an SE3 will transform the line with respect to the world     coordinate frame.
\end{itemize}

\subsection*{See also}


\hyperlink{Plucker.skew}{\color{blue} Plucker.skew}, \hyperlink{SE3.mtimes}{\color{blue} SE3.mtimes}

\vspace{1.5ex}\hrule

%---------------------- Plucker.ne
\hypertarget{Plucker.ne}{\section*{Plucker.ne}}
\subsection*{Test if two lines are not equivalent}
\addcontentsline{tom}{section}{Plucker.ne}


PL1 $\ne$ PL2 is true if the \textbf{\color{red} Plucker} objects describe different lines in
space.  Note that because of the over parameterization, lines can be
equivalent even if they have different parameters.

\vspace{1.5ex}\hrule

%---------------------- Plucker.or
\hypertarget{Plucker.or}{\section*{Plucker.or}}
\subsection*{Test if lines are parallel}
\addcontentsline{tom}{section}{Plucker.or}


\texttt{P1|P2} is true if the lines represented by \textbf{\color{red} Plucker} objects \texttt{P1}
and \texttt{P2} are parallel.


\subsection*{Notes}
\begin{itemize}
  \item Can be used in operator form as \texttt{P1}|\texttt{P2}.
\end{itemize}

\subsection*{See also}


\hyperlink{Plucker.isparallel}{\color{blue} Plucker.isparallel}, \hyperlink{Plucker.mpower}{\color{blue} Plucker.mpower}

\vspace{1.5ex}\hrule

%---------------------- Plucker.planes
\hypertarget{Plucker.planes}{\section*{Plucker.planes}}
\subsection*{Create Plucker line from two planes}
\addcontentsline{tom}{section}{Plucker.planes}


\texttt{P = Plucker.planes(PI1, PI2)} is a \textbf{\color{red} Plucker} object that represents
the line formed by the intersection of two planes \texttt{PI1}, \texttt{PI2} (each $4 \times 1$).


\subsection*{Notes}
\begin{itemize}
  \item Planes are given by the 4-vector [a b c d] to represent ax+by+cz+d=0.
\end{itemize}
\vspace{1.5ex}\hrule

%---------------------- Plucker.plot
\hypertarget{Plucker.plot}{\section*{Plucker.plot}}
\subsection*{Plot a line}
\addcontentsline{tom}{section}{Plucker.plot}


\texttt{PL.plot(OPTIONS)} adds the \textbf{\color{red} Plucker} line PL to the current plot volume.



\texttt{PL.plot(B, OPTIONS)} as above but plots within the plot bounds \texttt{B} = [XMIN
XMAX YMIN YMAX ZMIN ZMAX].


\subsection*{Options}
\begin{itemize}
  \item Are passed directly to plot3, eg. \textquotesingle k--\textquotesingle , \textquotesingle LineWidth\textquotesingle , etc.
\end{itemize}

\subsection*{Notes}
\begin{itemize}
  \item If the line does not intersect the current plot volume nothing will     be displayed.
\end{itemize}

\subsection*{See also}


\hyperlink{plot3}{\color{blue} plot3}, \hyperlink{Plucker.intersect_volume}{\color{blue} Plucker.intersect\_volume}

\vspace{1.5ex}\hrule

%---------------------- Plucker.point
\hypertarget{Plucker.point}{\section*{Plucker.point}}
\subsection*{Generate point on line}
\addcontentsline{tom}{section}{Plucker.point}


\texttt{P = PL.point(LAMBDA)} is a point on the line, where \texttt{LAMBDA} is the parametric
distance along the line from the principal point of the line \texttt{P} = PP + PL.UW*\texttt{LAMBDA}.


\subsection*{See also}


\hyperlink{Plucker.pp}{\color{blue} Plucker.pp}, \hyperlink{Plucker.closest}{\color{blue} Plucker.closest}

\vspace{1.5ex}\hrule

%---------------------- Plucker.pointdir
\hypertarget{Plucker.pointdir}{\section*{Plucker.pointdir}}
\subsection*{Construct Plucker line from point and direction}
\addcontentsline{tom}{section}{Plucker.pointdir}


\texttt{P = Plucker.pointdir(P, W)} is a \textbf{\color{red} Plucker} object that represents the
line containing the point \texttt{P} ($3 \times 1$) and parallel to the direction vector \texttt{W} ($3 \times 1$).


\subsection*{See also}


\hyperlink{: Plucker}{\color{blue} : Plucker}

\vspace{1.5ex}\hrule

%---------------------- Plucker.pp
\hypertarget{Plucker.pp}{\section*{Plucker.pp}}
\subsection*{Principal point of the line}
\addcontentsline{tom}{section}{Plucker.pp}


\texttt{P = PL.pp()} is the point on the line that is closest to the origin.


\subsection*{Notes}
\begin{itemize}
  \item Same as Plucker.point(0)
\end{itemize}

\subsection*{See also}


\hyperlink{Plucker.ppd}{\color{blue} Plucker.ppd}, \hyperlink{Plucker.point}{\color{blue} Plucker.point}

\vspace{1.5ex}\hrule

%---------------------- Plucker.ppd
\hypertarget{Plucker.ppd}{\section*{Plucker.ppd}}
\subsection*{Distance from principal point to the origin}
\addcontentsline{tom}{section}{Plucker.ppd}


\texttt{P = PL.ppd()} is the distance from the principal point to the origin.
This is the smallest distance of any point on the line
to the origin.


\subsection*{See also}


\hyperlink{Plucker.pp}{\color{blue} Plucker.pp}

\vspace{1.5ex}\hrule

%---------------------- Plucker.skew
\hypertarget{Plucker.skew}{\section*{Plucker.skew}}
\subsection*{Skew matrix form of the line}
\addcontentsline{tom}{section}{Plucker.skew}


\texttt{L = PL.skew()} is the \textbf{\color{red} Plucker} matrix, a $4 \times 4$ skew-symmetric matrix
representation of the line.


\subsection*{Notes}
\begin{itemize}
  \item For two homogeneous points P and Q on the line, PQ\textquotesingle -QP\textquotesingle  is also skew     symmetric.
  \item The projection of Plucker line by a perspective camera is a homogeneous line ($3 \times 1$)     given by vex(C*\texttt{L}*C\textquotesingle ) where C ($3 \times 4$) is the camera matrix.
\end{itemize}
\vspace{1.5ex}\rule{\textwidth}{1mm}

%---------------------- Quaternion
\hypertarget{Quaternion}{\section*{Quaternion}}
\subsection*{Quaternion class}
\addcontentsline{toc}{section}{Quaternion}


A quaternion is 4-element mathematical object comprising a scalar s, and
a vector v which can be considered as a pair (s,v).  In the Toolbox it is
denoted by q = s $<$$<$vx, vy, vz$>$$>$.



A quaternion of unit length can be used to represent 3D orientation and
is implemented by the subclass UnitQuaternion.


\subsection*{Constructors}
\begin{longtable}{lp{120mm}}
Quaternion & general constructor\\ 
Quaternion.pure & pure quaternion\\ 
\end{longtable}\vspace{1ex}

\subsection*{Display and print methods}
\begin{longtable}{lp{120mm}}
display & print in human readable form\\ 
\end{longtable}\vspace{1ex}

\subsection*{Group operations}
\begin{longtable}{lp{120mm}}
\textasteriskcentered  & quaternion (Hamilton) product or elementwise multiplication by scalar\\ 
/ & multiply by inverse or elementwise division by scalar\\ 
\textasciicircum  & exponentiate (integer only)\\ 
+ & elementwise sum of quaternion elements\\ 
- & elementwise difference of quaternion elements\\ 
conj & conjugate\\ 
exp & exponential\\ 
log & logarithm\\ 
inv & inverse\\ 
prod & product of elements\\ 
unit & unitized quaternion\\ 
\end{longtable}\vspace{1ex}

\subsection*{Methods}
\begin{longtable}{lp{120mm}}
inner & inner product\\ 
isequal & test for non-equality\\ 
norm & norm, or length\\ 
\end{longtable}\vspace{1ex}

\subsection*{Conversion methods}
\begin{longtable}{lp{120mm}}
char & convert to string\\ 
double & quaternion elements as 4-vector\\ 
matrix & quaternion as a $4 \times 4$ matrix\\ 
\end{longtable}\vspace{1ex}

\subsection*{Overloaded operators}
\begin{longtable}{lp{120mm}}
== & test for quaternion equality\\ 
$\sim=$ & test for quaternion inequality\\ 
\end{longtable}\vspace{1ex}

\subsection*{Properties (read only)}
\begin{longtable}{lp{120mm}}
s & real part\\ 
v & vector part\\ 
\end{longtable}\vspace{1ex}

\subsection*{Notes}
\begin{itemize}
  \item This is reference (handle) class object
  \item Quaternion objects can be used in vectors and arrays.
\end{itemize}

\subsection*{References}
\begin{itemize}
  \item Animating rotation with quaternion curves, K. Shoemake,    in Proceedings of ACM SIGGRAPH, (San Fran cisco), pp. 245-254, 1985.
  \item On homogeneous transforms, quaternions, and computational efficiency,    J. Funda, R. Taylor, and R. Paul,
  \item IEEE Transactions on Robotics and Automation, vol. 6, pp. 382-388, June 1990.
  \item Quaternions for Computer Graphics, J. Vince, Springer 2011.
  \item Robotics, Vision \& Control: Second Edition, P. Corke, Springer 2016; p44-45.
\end{itemize}

\subsection*{See also}


\hyperlink{UnitQuaternion}{\color{blue} UnitQuaternion}

\vspace{1.5ex}\hrule

%---------------------- Quaternion.Quaternion
\hypertarget{Quaternion.Quaternion}{\section*{Quaternion.Quaternion}}
\subsection*{Construct a quaternion object}
\addcontentsline{tom}{section}{Quaternion.Quaternion}


\texttt{Q = Quaternion(S, V)} is a \textbf{\color{red} Quaternion} formed from the scalar \texttt{S} and vector
part \texttt{V} ($1 \times 3$).



\texttt{Q = Quaternion([S V1 V2 V3])} is a \textbf{\color{red} Quaternion} formed by specifying directly its 4 elements.



\texttt{Q = Quaternion()} is a zero \textbf{\color{red} Quaternion}, all its elements are zero.


\subsection*{Notes}
\begin{itemize}
  \item The constructor is not vectorized, it cannot create a vector of Quaternions.
\end{itemize}
\vspace{1.5ex}\hrule

%---------------------- Quaternion.char
\hypertarget{Quaternion.char}{\section*{Quaternion.char}}
\subsection*{Convert to string}
\addcontentsline{tom}{section}{Quaternion.char}


\texttt{S = Q.char()} is a compact string representation of the \textbf{\color{red} Quaternion}\textquotesingle s value
as a 4-tuple.  If Q is a vector then \texttt{S} has one line per element.


\subsection*{Notes}
\begin{itemize}
  \item The vector part is delimited by double angle brackets, to differentiate    from a UnitQuaternion which is delimited by single angle brackets.
\end{itemize}

\subsection*{See also}


\hyperlink{UnitQuaternion.char}{\color{blue} UnitQuaternion.char}

\vspace{1.5ex}\hrule

%---------------------- Quaternion.conj
\hypertarget{Quaternion.conj}{\section*{Quaternion.conj}}
\subsection*{Conjugate of a quaternion}
\addcontentsline{tom}{section}{Quaternion.conj}


\texttt{Q.conj()} is a \textbf{\color{red} Quaternion} object representing the conjugate of Q.


\subsection*{Notes}
\begin{itemize}
  \item Conjugatation is the negation of the vector component.
\end{itemize}

\subsection*{See also}


\hyperlink{Quaternion.inv}{\color{blue} Quaternion.inv}

\vspace{1.5ex}\hrule

%---------------------- Quaternion.display
\hypertarget{Quaternion.display}{\section*{Quaternion.display}}
\subsection*{Display quaternion}
\addcontentsline{tom}{section}{Quaternion.display}


\texttt{Q.display()} displays a compact string representation of the \textbf{\color{red} Quaternion}\textquotesingle s value
as a 4-tuple.  If Q is a vector then S has one line per element.


\subsection*{Notes}
\begin{itemize}
  \item This method is invoked implicitly at the command line when the result    of an expression is a Quaternion object and the command has no trailing
  \item semicolon.
  \item The vector part is displayed with double brackets $<$$<$ 1, 0, 0 $>$$>$ to    distinguish it from a UnitQuaternion which displays as $<$ 1, 0, 0 $>$
  \item If Q is a vector of Quaternion objects the elements are displayed on    consecutive lines.
\end{itemize}

\subsection*{See also}


\hyperlink{Quaternion.char}{\color{blue} Quaternion.char}

\vspace{1.5ex}\hrule

%---------------------- Quaternion.double
\hypertarget{Quaternion.double}{\section*{Quaternion.double}}
\subsection*{Convert a quaternion to a 4-element vector}
\addcontentsline{tom}{section}{Quaternion.double}


\texttt{V = Q.double()} is a row vector ($1 \times 4$) comprising the \textbf{\color{red} Quaternion} elements,
scalar then vector, ie. \texttt{V} = [s vx vy vz].  If Q is a vector ($1 \times N$) of
Quaternion objects then \texttt{V} is a matrix ($N \times 4$) with rows corresponding to
the quaternion elements.

\vspace{1.5ex}\hrule

%---------------------- Quaternion.eq
\hypertarget{Quaternion.eq}{\section*{Quaternion.eq}}
\subsection*{Test quaternion equality}
\addcontentsline{tom}{section}{Quaternion.eq}


Q1 == Q2 is true if the Quaternions Q1 and Q2 are equal.


\subsection*{Notes}
\begin{itemize}
  \item Overloaded operator \textquotesingle ==\textquotesingle .
  \item Equality means elementwise equality of Quaternion elements.
  \item If either, or both, of Q1 or Q2 are vectors, then the result is a vector.
\begin{itemize}
  \item if Q1 is a vector ($1 \times N$) then R is a vector ($1 \times N$) such that R(i) = Q1(i)==Q2.
  \item if Q2 is a vector ($1 \times N$) then R is a vector ($1 \times N$) such that R(i) = Q1==Q2(i).
  \item if both Q1 and Q2 are vectors ($1 \times N$) then R is a vector ($1 \times N$) such      that R(i) = Q1(i)==Q2(i).
\end{itemize}
\end{itemize}

\subsection*{See also}


\hyperlink{Quaternion.ne}{\color{blue} Quaternion.ne}

\vspace{1.5ex}\hrule

%---------------------- Quaternion.exp
\hypertarget{Quaternion.exp}{\section*{Quaternion.exp}}
\subsection*{Exponential of quaternion}
\addcontentsline{tom}{section}{Quaternion.exp}


\texttt{Q.log()} is the logarithm of the \textbf{\color{red} Quaternion} Q.


\subsection*{See also}


\hyperlink{Quaternion.exp}{\color{blue} Quaternion.exp}

\vspace{1.5ex}\hrule

%---------------------- Quaternion.inner
\hypertarget{Quaternion.inner}{\section*{Quaternion.inner}}
\subsection*{Quaternion inner product}
\addcontentsline{tom}{section}{Quaternion.inner}


\texttt{V = Q1.inner(Q2)} is the inner (dot) product of two vectors ($1 \times 4$),
comprising the elements of Q1 and \texttt{Q2} respectively.


\subsection*{Notes}
\begin{itemize}
  \item Q1.inner(Q1) is the same as Q1.norm().
\end{itemize}

\subsection*{See also}


\hyperlink{Quaternion.norm}{\color{blue} Quaternion.norm}

\vspace{1.5ex}\hrule

%---------------------- Quaternion.inv
\hypertarget{Quaternion.inv}{\section*{Quaternion.inv}}
\subsection*{Invert a quaternion}
\addcontentsline{tom}{section}{Quaternion.inv}


\texttt{Q.inv()} is a \textbf{\color{red} Quaternion} object representing the inverse of Q.


\subsection*{Notes}
\begin{itemize}
  \item If Q is a vector then an equal length vector of Quaternion objects    is computed representing the elementwise inverse of Q.
\end{itemize}

\subsection*{See also}


\hyperlink{Quaternion.conj}{\color{blue} Quaternion.conj}

\vspace{1.5ex}\hrule

%---------------------- Quaternion.isequal
\hypertarget{Quaternion.isequal}{\section*{Quaternion.isequal}}
\subsection*{Test quaternion element equality}
\addcontentsline{tom}{section}{Quaternion.isequal}


\texttt{ISEQUAL(Q1,Q2)} is true if the Quaternions \texttt{Q1} and \texttt{Q2} are equal.


\subsection*{Notes}
\begin{itemize}
  \item Used by test suite verifyEqual() in addition to eq().
  \item Invokes eq() so respects double mapping for UnitQuaternion.
\end{itemize}

\subsection*{See also}


\hyperlink{Quaternion.eq}{\color{blue} Quaternion.eq}

\vspace{1.5ex}\hrule

%---------------------- Quaternion.log
\hypertarget{Quaternion.log}{\section*{Quaternion.log}}
\subsection*{Logarithm of quaternion}
\addcontentsline{tom}{section}{Quaternion.log}


\texttt{Q.log()} is the logarithm of the \textbf{\color{red} Quaternion} Q.


\subsection*{See also}


\hyperlink{Quaternion.exp}{\color{blue} Quaternion.exp}

\vspace{1.5ex}\hrule

%---------------------- Quaternion.matrix
\hypertarget{Quaternion.matrix}{\section*{Quaternion.matrix}}
\subsection*{Matrix representation of Quaternion}
\addcontentsline{tom}{section}{Quaternion.matrix}


\texttt{Q.matrix()} is a matrix ($4 \times 4$) representation of the \textbf{\color{red} Quaternion} Q.



\textbf{\color{red} Quaternion}, or Hamilton, multiplication can be implemented as a
matrix-vector product, where the column-vector is the elements of a
second quaternion:

\begin{Code}
    matrix(Q1) * double(Q2)'

\end{Code}

\subsection*{Notes}
\begin{itemize}
  \item This matrix is not unique, other matrices will serve the purpose for    multiplication, see \url{https://en.wikipedia.org/wiki/Quaternion}\#Matrix\_representations
  \item The determinant of the matrix is the norm of the Quaternion to the fourth power.
\end{itemize}

\subsection*{See also}


\hyperlink{Quaternion.double}{\color{blue} Quaternion.double}, \hyperlink{Quaternion.mtimes}{\color{blue} Quaternion.mtimes}

\vspace{1.5ex}\hrule

%---------------------- Quaternion.minus
\hypertarget{Quaternion.minus}{\section*{Quaternion.minus}}
\subsection*{Subtract quaternions}
\addcontentsline{tom}{section}{Quaternion.minus}


\texttt{Q1-Q2} is a \textbf{\color{red} Quaternion} formed from the element-wise difference of \textbf{\color{red} Quaternion} elements.



\texttt{Q1-V}  is a \textbf{\color{red} Quaternion} formed from the element-wise difference of \texttt{Q1} and the
vector \texttt{V} ($1 \times 4$).


\subsection*{Notes}
\begin{itemize}
  \item Overloaded operator \textquotesingle -\textquotesingle .
  \item Effectively \texttt{V} is promoted to a Quaternion.
\end{itemize}

\subsection*{See also}


\hyperlink{Quaternion.plus}{\color{blue} Quaternion.plus}

\vspace{1.5ex}\hrule

%---------------------- Quaternion.mpower
\hypertarget{Quaternion.mpower}{\section*{Quaternion.mpower}}
\subsection*{Raise quaternion to integer power}
\addcontentsline{tom}{section}{Quaternion.mpower}


\texttt{Q\textasciicircum N} is the \textbf{\color{red} Quaternion} \texttt{Q} raised to the integer power \texttt{N}.


\subsection*{Notes}
\begin{itemize}
  \item Overloaded operator \textquotesingle\textasciicircum textquotesingle .
  \item \texttt{N} must be an integer, computed by repeated multiplication.
\end{itemize}

\subsection*{See also}


\hyperlink{Quaternion.mtimes}{\color{blue} Quaternion.mtimes}

\vspace{1.5ex}\hrule

%---------------------- Quaternion.mrdivide
\hypertarget{Quaternion.mrdivide}{\section*{Quaternion.mrdivide}}
\subsection*{Quaternion quotient.}
\addcontentsline{tom}{section}{Quaternion.mrdivide}
\begin{longtable}{lp{120mm}}
R = Q1/Q2 & is a Quaternion formed by Hamilton product of Q1 and inv(Q2).\\ 
R = Q/S & is the element-wise division of Quaternion elements by the scalar S.\\ 
\end{longtable}\vspace{1ex}

\subsection*{Notes}
\begin{itemize}
  \item Overloaded operator \textquotesingle /\textquotesingle .
  \item If either, or both, of Q1 or Q2 are vectors, then the result is a vector.
\begin{itemize}
  \item if Q1 is a vector ($1 \times N$) then R is a vector ($1 \times N$) such that R(i) = Q1(i)./Q2.
  \item if Q2 is a vector ($1 \times N$) then R is a vector ($1 \times N$) such that R(i) = Q1./Q2(i).
  \item if both Q1 and Q2 are vectors ($1 \times N$) then R is a vector ($1 \times N$) such      that R(i) = Q1(i)./Q2(i).
\end{itemize}
\end{itemize}

\subsection*{See also}


\hyperlink{Quaternion.mtimes}{\color{blue} Quaternion.mtimes}, \hyperlink{Quaternion.mpower}{\color{blue} Quaternion.mpower}, \hyperlink{Quaternion.plus}{\color{blue} Quaternion.plus}, \hyperlink{Quaternion.minus}{\color{blue} Quaternion.minus}

\vspace{1.5ex}\hrule

%---------------------- Quaternion.mtimes
\hypertarget{Quaternion.mtimes}{\section*{Quaternion.mtimes}}
\subsection*{Multiply a quaternion object}
\addcontentsline{tom}{section}{Quaternion.mtimes}
\begin{longtable}{lp{120mm}}
Q1\textasteriskcentered Q2 & is a Quaternion formed by the Hamilton product of two Quaternions.\\ 
Q\textasteriskcentered S & is the element-wise multiplication of Quaternion elements by the scalar S.\\ 
S\textasteriskcentered Q & is the element-wise multiplication of Quaternion elements by the scalar S.\\ 
\end{longtable}\vspace{1ex}

\subsection*{Notes}
\begin{itemize}
  \item Overloaded operator \textquotesingle *\textquotesingle .
  \item If either, or both, of Q1 or Q2 are vectors, then the result is a vector.
\begin{itemize}
  \item if Q1 is a vector ($1 \times N$) then R is a vector ($1 \times N$) such that R(i) = Q1(i)*Q2.
  \item if Q2 is a vector ($1 \times N$) then R is a vector ($1 \times N$) such that R(i) = Q1*Q2(i).
  \item if both Q1 and Q2 are vectors ($1 \times N$) then R is a vector ($1 \times N$) such      that R(i) = Q1(i)*Q2(i).
\end{itemize}
\end{itemize}

\subsection*{See also}


\hyperlink{Quaternion.mrdivide}{\color{blue} Quaternion.mrdivide}, \hyperlink{Quaternion.mpower}{\color{blue} Quaternion.mpower}

\vspace{1.5ex}\hrule

%---------------------- Quaternion.ne
\hypertarget{Quaternion.ne}{\section*{Quaternion.ne}}
\subsection*{Test quaternion inequality}
\addcontentsline{tom}{section}{Quaternion.ne}


Q1 $\ne$ Q2 is true if the Quaternions Q1 and Q2 are not equal.


\subsection*{Notes}
\begin{itemize}
  \item Overloaded operator \textquotesingle $\ne$\textquotesingle .
  \item If either, or both, of Q1 or Q2 are vectors, then the result is a vector.
\begin{itemize}
  \item if Q1 is a vector ($1 \times N$) then R is a vector ($1 \times N$) such that R(i) = Q1(i)$\ne$Q2.
  \item if Q2 is a vector ($1 \times N$) then R is a vector ($1 \times N$) such that R(i) = Q1$\ne$Q2(i).
  \item if both Q1 and Q2 are vectors ($1 \times N$) then R is a vector ($1 \times N$) such      that R(i) = Q1(i)$\ne$Q2(i).
\end{itemize}
\end{itemize}

\subsection*{See also}


\hyperlink{Quaternion.eq}{\color{blue} Quaternion.eq}

\vspace{1.5ex}\hrule

%---------------------- Quaternion.new
\hypertarget{Quaternion.new}{\section*{Quaternion.new}}
\subsection*{Construct a new quaternion}
\addcontentsline{tom}{section}{Quaternion.new}


\texttt{QN = Q.new()} constructs a new \textbf{\color{red} Quaternion} object.



\texttt{QN = Q.new([S, V1, V2, V3])} as above but specified directly by its 4 elements.



\texttt{QN = Q.new(S, V)} as above but specified directly by the scalar \texttt{S} and vector
part \texttt{V} ($1 \times 3$)


\subsection*{Notes}
\begin{itemize}
  \item Polymorphic with UnitQuaternion and RTBPose derived classes.
\end{itemize}
\vspace{1.5ex}\hrule

%---------------------- Quaternion.norm
\hypertarget{Quaternion.norm}{\section*{Quaternion.norm}}
\subsection*{Quaternion magnitude}
\addcontentsline{tom}{section}{Quaternion.norm}


\texttt{Q.norm(Q)} is the scalar norm or magnitude of the \textbf{\color{red} Quaternion} \texttt{Q}.


\subsection*{Notes}
\begin{itemize}
  \item This is the Euclidean norm of the Quaternion written as a 4-vector.
  \item A unit-quaternion has a norm of one and is represented by the    UnitQuaternion class.
\end{itemize}

\subsection*{See also}


\hyperlink{Quaternion.inner}{\color{blue} Quaternion.inner}, \hyperlink{Quaternion.unit}{\color{blue} Quaternion.unit}, \hyperlink{UnitQuaternion}{\color{blue} UnitQuaternion}

\vspace{1.5ex}\hrule

%---------------------- Quaternion.plus
\hypertarget{Quaternion.plus}{\section*{Quaternion.plus}}
\subsection*{Add quaternions}
\addcontentsline{tom}{section}{Quaternion.plus}


\texttt{Q1+Q2} is a \textbf{\color{red} Quaternion} formed from the element-wise sum of \textbf{\color{red} Quaternion} elements.



\texttt{Q1+V}  is a \textbf{\color{red} Quaternion} formed from the element-wise sum of \texttt{Q1} and the
vector \texttt{V} ($1 \times 4$).


\subsection*{Notes}
\begin{itemize}
  \item Overloaded operator \textquotesingle +\textquotesingle .
  \item Effectively \texttt{V} is promoted to a Quaternion.
\end{itemize}

\subsection*{See also}


\hyperlink{Quaternion.minus}{\color{blue} Quaternion.minus}

\vspace{1.5ex}\hrule

%---------------------- Quaternion.prod
\hypertarget{Quaternion.prod}{\section*{Quaternion.prod}}
\subsection*{Product of quaternions}
\addcontentsline{tom}{section}{Quaternion.prod}


\texttt{prod(Q)} is the product of the elements of the vector of \textbf{\color{red} Quaternion} objects \texttt{Q}.


\subsection*{See also}


\hyperlink{Quaternion.mtimes}{\color{blue} Quaternion.mtimes}, \hyperlink{RTBPose.prod}{\color{blue} RTBPose.prod}

\vspace{1.5ex}\hrule

%---------------------- Quaternion.pure
\hypertarget{Quaternion.pure}{\section*{Quaternion.pure}}
\subsection*{Construct a pure quaternion}
\addcontentsline{tom}{section}{Quaternion.pure}


\texttt{Q = Quaternion.pure(V)} is a pure \textbf{\color{red} Quaternion} formed from the vector \texttt{V} ($1 \times 3$) and has
a zero scalar part.

\vspace{1.5ex}\hrule

%---------------------- Quaternion.set.s
\hypertarget{Quaternion.set.s}{\section*{Quaternion.set.s}}
\subsection*{Set scalar component}
\addcontentsline{tom}{section}{Quaternion.set.s}


\texttt{Q.s} = S sets the scalar part of the \textbf{\color{red} Quaternion} object to S.

\vspace{1.5ex}\hrule

%---------------------- Quaternion.set.v
\hypertarget{Quaternion.set.v}{\section*{Quaternion.set.v}}
\subsection*{Set vector component}
\addcontentsline{tom}{section}{Quaternion.set.v}


\texttt{Q.v} = V sets the vector part of the \textbf{\color{red} Quaternion} object to V ($1 \times 3$).

\vspace{1.5ex}\hrule

%---------------------- Quaternion.unit
\hypertarget{Quaternion.unit}{\section*{Quaternion.unit}}
\subsection*{Unitize a quaternion}
\addcontentsline{tom}{section}{Quaternion.unit}


\texttt{QU = Q.unit()} is a \textbf{\color{red} Quaternion} with a norm of 1.  If Q is a vector ($1 \times N$) then
\texttt{QU} is also a vector ($1 \times N$).


\subsection*{Notes}
\begin{itemize}
  \item This is Quaternion of unit norm, not a UnitQuaternion object.
\end{itemize}

\subsection*{See also}


\hyperlink{Quaternion.norm}{\color{blue} Quaternion.norm}, \hyperlink{UnitQuaternion}{\color{blue} UnitQuaternion}

\vspace{1.5ex}\rule{\textwidth}{1mm}

%---------------------- r2t
\hypertarget{r2t}{\section*{r2t}}
\subsection*{Convert rotation matrix to a homogeneous transform}
\addcontentsline{toc}{section}{r2t}


\texttt{T = R2T(R)} is an $\mbox{SE}(2)$ or $\mbox{SE}(3)$ homogeneous transform equivalent to an
$\mbox{SO}(2)$ or $\mbox{SO}(3)$ orthonormal rotation matrix \texttt{R} with a zero translational
component. Works for \texttt{T} in either $\mbox{SE}(2)$ or $\mbox{SE}(3)$:

\begin{itemize}
  \item if \texttt{R} is $2 \times 2$ then \texttt{T} is $3 \times 3$, or
  \item if \texttt{R} is $3 \times 3$ then \texttt{T} is $4 \times 4$.
\end{itemize}

\subsection*{Notes}
\begin{itemize}
  \item Translational component is zero.
  \item For a rotation matrix sequence ($K \times K \times N$) returns a homogeneous transform    sequence ($K+1 \times K$+$1 \times N$).
\end{itemize}

\subsection*{See also}


\hyperlink{t2r}{\color{blue} t2r}

\vspace{1.5ex}\rule{\textwidth}{1mm}

%---------------------- randinit
\hypertarget{randinit}{\section*{randinit}}
\subsection*{Reset random number generator}
\addcontentsline{toc}{section}{randinit}


RANDINIT resets the defaul random number stream.  For example:

\begin{Code}
   >> rand
   ans =
      0.8147
   >> rand
   ans =
       0.9058
   >> rand
   ans =
       0.1270
   >> randinit
   >> rand
   ans =
       0.8147

\end{Code}
\vspace{1.5ex}\rule{\textwidth}{1mm}

%---------------------- rot2
\hypertarget{rot2}{\section*{rot2}}
\subsection*{$\mbox{SO}(2)$ rotation matrix}
\addcontentsline{toc}{section}{rot2}


\texttt{R = ROT2(THETA)} is an $\mbox{SO}(2)$ rotation matrix ($2 \times 2$) representing a rotation of \texttt{THETA}
radians.



\texttt{R = ROT2(THETA, 'deg')} as above but \texttt{THETA} is in degrees.


\subsection*{See also}


\hyperlink{trot2}{\color{blue} trot2}, \hyperlink{isrot2}{\color{blue} isrot2}, \hyperlink{trplot2}{\color{blue} trplot2}, \hyperlink{rotx}{\color{blue} rotx}, \hyperlink{roty}{\color{blue} roty}, \hyperlink{rotz}{\color{blue} rotz}, \hyperlink{SO2}{\color{blue} SO2}

\vspace{1.5ex}\rule{\textwidth}{1mm}

%---------------------- rotx
\hypertarget{rotx}{\section*{rotx}}
\subsection*{$\mbox{SO}(3)$ rotation about X axis}
\addcontentsline{toc}{section}{rotx}


\texttt{R = ROTX(THETA)} is an $\mbox{SO}(3)$ rotation matrix ($3 \times 3$) representing a rotation of \texttt{THETA}
radians about the x-axis.



\texttt{R = ROTX(THETA, 'deg')} as above but \texttt{THETA} is in degrees.


\subsection*{See also}


\hyperlink{trotx}{\color{blue} trotx}, \hyperlink{roty}{\color{blue} roty}, \hyperlink{rotz}{\color{blue} rotz}, \hyperlink{angvec2r}{\color{blue} angvec2r}, \hyperlink{rot2}{\color{blue} rot2}, \hyperlink{SO3.Rx}{\color{blue} SO3.Rx}

\vspace{1.5ex}\rule{\textwidth}{1mm}

%---------------------- roty
\hypertarget{roty}{\section*{roty}}
\subsection*{$\mbox{SO}(3)$ rotation about Y axis}
\addcontentsline{toc}{section}{roty}


\texttt{R = ROTY(THETA)} is an $\mbox{SO}(3)$ rotation matrix ($3 \times 3$) representing a rotation of \texttt{THETA}
radians about the y-axis.



\texttt{R = ROTY(THETA, 'deg')} as above but \texttt{THETA} is in degrees.


\subsection*{See also}


\hyperlink{troty}{\color{blue} troty}, \hyperlink{rotx}{\color{blue} rotx}, \hyperlink{rotz}{\color{blue} rotz}, \hyperlink{angvec2r}{\color{blue} angvec2r}, \hyperlink{rot2}{\color{blue} rot2}, \hyperlink{SO3.Ry}{\color{blue} SO3.Ry}

\vspace{1.5ex}\rule{\textwidth}{1mm}

%---------------------- rotz
\hypertarget{rotz}{\section*{rotz}}
\subsection*{$\mbox{SO}(3)$ rotation about Z axis}
\addcontentsline{toc}{section}{rotz}


\texttt{R = ROTZ(THETA)} is an $\mbox{SO}(3)$ rotation matrix ($3 \times 3$) representing a rotation of \texttt{THETA}
radians about the z-axis.



\texttt{R = ROTZ(THETA, 'deg')} as above but \texttt{THETA} is in degrees.


\subsection*{See also}


\hyperlink{trotz}{\color{blue} trotz}, \hyperlink{rotx}{\color{blue} rotx}, \hyperlink{roty}{\color{blue} roty}, \hyperlink{angvec2r}{\color{blue} angvec2r}, \hyperlink{rot2}{\color{blue} rot2}, \hyperlink{SO3.Rx}{\color{blue} SO3.Rx}

\vspace{1.5ex}\rule{\textwidth}{1mm}

%---------------------- rpy2jac
\hypertarget{rpy2jac}{\section*{rpy2jac}}
\subsection*{Jacobian from RPY angle rates to angular velocity}
\addcontentsline{toc}{section}{rpy2jac}


\texttt{J = RPY2JAC(RPY, OPTIONS)} is a Jacobian matrix ($3 \times 3$) that maps ZYX roll-pitch-yaw angle
rates to angular velocity at the operating point \texttt{RPY}=[R,P,Y].



\texttt{J = RPY2JAC(R, P, Y, OPTIONS)} as above but the roll-pitch-yaw angles are passed
as separate arguments.


\subsection*{Options}
\begin{longtable}{lp{120mm}}
\textquotesingle xyz\textquotesingle  & Use XYZ roll-pitch-yaw angles\\ 
\textquotesingle yxz\textquotesingle  & Use YXZ roll-pitch-yaw angles\\ 
\end{longtable}\vspace{1ex}

\subsection*{Notes}
\begin{itemize}
  \item Used in the creation of an analytical Jacobian.
  \item Angles in radians, rates in radians/sec.
\end{itemize}

\subsection*{Reference}
\begin{itemize}
  \item Robotics, Vision \& Control: Second Edition, \texttt{P}. Corke, Springer 2016; p232-3.
\end{itemize}

\subsection*{See also}


\hyperlink{eul2jac}{\color{blue} eul2jac}, \hyperlink{rpy2r}{\color{blue} rpy2r}, \hyperlink{SerialLink.jacobe}{\color{blue} SerialLink.jacobe}

\vspace{1.5ex}\rule{\textwidth}{1mm}

%---------------------- rpy2r
\hypertarget{rpy2r}{\section*{rpy2r}}
\subsection*{Roll-pitch-yaw angles to $\mbox{SO}(3)$ rotation matrix}
\addcontentsline{toc}{section}{rpy2r}


\texttt{R = RPY2R(ROLL, PITCH, YAW, OPTIONS)} is an $\mbox{SO}(3)$ orthonornal rotation
matrix ($3 \times 3$) equivalent to the specified roll, pitch, yaw angles angles.
These correspond to rotations about the Z, Y, X axes respectively. If
\texttt{ROLL}, \texttt{PITCH}, \texttt{YAW} are column vectors ($N \times 1$) then they are assumed to
represent a trajectory and \texttt{R} is a three-dimensional matrix ($3 \times 3 \times N$), where
the last index corresponds to rows of \texttt{ROLL}, \texttt{PITCH}, \texttt{YAW}.



\texttt{R = RPY2R(RPY, OPTIONS)} as above but the roll, pitch, yaw angles are
taken from the vector ($1 \times 3$) \texttt{RPY}=[\texttt{ROLL},\texttt{PITCH},\texttt{YAW}]. If \texttt{RPY} is a matrix
($N \times 3$) then \texttt{R} is a three-dimensional matrix ($3 \times 3 \times N$), where the last index
corresponds to rows of \texttt{RPY} which are assumed to be [\texttt{ROLL},\texttt{PITCH},\texttt{YAW}].


\subsection*{Options}
\begin{longtable}{lp{120mm}}
\textquotesingle deg\textquotesingle  & Compute angles in degrees (radians default)\\ 
\textquotesingle xyz\textquotesingle  & Rotations about X, Y, Z axes (for a robot gripper)\\ 
\textquotesingle zyx\textquotesingle  & Rotations about Z, Y, X axes (for a mobile robot, default)\\ 
\textquotesingle yxz\textquotesingle  & Rotations about Y, X, Z axes (for a camera)\\ 
\textquotesingle arm\textquotesingle  & Rotations about X, Y, Z axes (for a robot arm)\\ 
\end{longtable}\vspace{1ex}


\textquotesingle vehicle\textquotesingle   Rotations about Z, Y, X axes (for a mobile robot)

\begin{longtable}{lp{120mm}}
\textquotesingle camera\textquotesingle  & Rotations about Y, X, Z axes (for a camera)\\ 
\end{longtable}\vspace{1ex}

\subsection*{Note}
\begin{itemize}
  \item Toolbox rel 8-9 has XYZ angle sequence as default.
  \item ZYX order is appropriate for vehicles with direction of travel in the X    direction.  XYZ order is appropriate if direction of travel is in the Z
  \item direction.
  \item \textquotesingle arm\textquotesingle , \textquotesingle vehicle\textquotesingle , \textquotesingle camera\textquotesingle  are synonyms for \textquotesingle xyz\textquotesingle , \textquotesingle zyx\textquotesingle  and \textquotesingle yxz\textquotesingle     respectively.
\end{itemize}

\subsection*{See also}


\hyperlink{tr2rpy}{\color{blue} tr2rpy}, \hyperlink{eul2tr}{\color{blue} eul2tr}

\vspace{1.5ex}\rule{\textwidth}{1mm}

%---------------------- rpy2tr
\hypertarget{rpy2tr}{\section*{rpy2tr}}
\subsection*{Roll-pitch-yaw angles to $\mbox{SE}(3)$ homogeneous transform}
\addcontentsline{toc}{section}{rpy2tr}


\texttt{T = RPY2TR(ROLL, PITCH, YAW, OPTIONS)} is an $\mbox{SE}(3)$ homogeneous
transformation matrix ($4 \times 4$) with zero translation and rotation equivalent
to the specified roll, pitch, yaw angles angles. These correspond to
rotations about the Z, Y, X axes respectively. If \texttt{ROLL}, \texttt{PITCH}, \texttt{YAW} are
column vectors ($N \times 1$) then they are assumed to represent a trajectory and
R is a three-dimensional matrix ($4 \times 4 \times N$), where the last index corresponds
to rows of \texttt{ROLL}, \texttt{PITCH}, \texttt{YAW}.



\texttt{T = RPY2TR(RPY, OPTIONS)} as above but the roll, pitch, yaw angles are
taken from the vector ($1 \times 3$) \texttt{RPY}=[\texttt{ROLL},\texttt{PITCH},\texttt{YAW}]. If \texttt{RPY} is a matrix
($N \times 3$) then R is a three-dimensional matrix ($4 \times 4 \times N$), where the last index
corresponds to rows of \texttt{RPY} which are assumed to be
\texttt{ROLL},\texttt{PITCH},\texttt{YAW}].


\subsection*{Options}
\begin{longtable}{lp{120mm}}
\textquotesingle deg\textquotesingle  & Compute angles in degrees (radians default)\\ 
\textquotesingle xyz\textquotesingle  & Rotations about X, Y, Z axes (for a robot gripper)\\ 
\textquotesingle zyx\textquotesingle  & Rotations about Z, Y, X axes (for a mobile robot, default)\\ 
\textquotesingle yxz\textquotesingle  & Rotations about Y, X, Z axes (for a camera)\\ 
\textquotesingle arm\textquotesingle  & Rotations about X, Y, Z axes (for a robot arm)\\ 
\end{longtable}\vspace{1ex}


\textquotesingle vehicle\textquotesingle   Rotations about Z, Y, X axes (for a mobile robot)

\begin{longtable}{lp{120mm}}
\textquotesingle camera\textquotesingle  & Rotations about Y, X, Z axes (for a camera)\\ 
\end{longtable}\vspace{1ex}

\subsection*{Note}
\begin{itemize}
  \item Toolbox rel 8-9 has the reverse angle sequence as default.
  \item ZYX order is appropriate for vehicles with direction of travel in the X    direction.  XYZ order is appropriate if direction of travel is in the Z
  \item direction.
  \item \textquotesingle arm\textquotesingle , \textquotesingle vehicle\textquotesingle , \textquotesingle camera\textquotesingle  are synonyms for \textquotesingle xyz\textquotesingle , \textquotesingle zyx\textquotesingle  and \textquotesingle yxz\textquotesingle     respectively.
\end{itemize}

\subsection*{See also}


\hyperlink{tr2rpy}{\color{blue} tr2rpy}, \hyperlink{rpy2r}{\color{blue} rpy2r}, \hyperlink{eul2tr}{\color{blue} eul2tr}

\vspace{1.5ex}\rule{\textwidth}{1mm}

%---------------------- rt2tr
\hypertarget{rt2tr}{\section*{rt2tr}}
\subsection*{Convert rotation and translation to homogeneous transform}
\addcontentsline{toc}{section}{rt2tr}


\texttt{TR = RT2TR(R, t)} is a homogeneous transformation matrix ($N+1 \times N+1$) formed
from an orthonormal rotation matrix \texttt{R} ($N \times N$) and a translation vector \texttt{t}
($N \times 1$).  Works for \texttt{R} in $\mbox{SO}(2)$ or $\mbox{SO}(3)$:

\begin{itemize}
  \item If \texttt{R} is $2 \times 2$ and \texttt{t} is $2 \times 1$, then \texttt{TR} is $3 \times 3$
  \item If \texttt{R} is $3 \times 3$ and \texttt{t} is $3 \times 1$, then \texttt{TR} is $4 \times 4$
\end{itemize}


For a sequence \texttt{R} ($N \times N \times K$) and \texttt{t} ($N \times K$) results in a transform sequence ($N+1 \times N$+$1 \times K$).


\subsection*{Notes}
\begin{itemize}
  \item The validity of \texttt{R} is not checked
\end{itemize}

\subsection*{See also}


\hyperlink{t2r}{\color{blue} t2r}, \hyperlink{r2t}{\color{blue} r2t}, \hyperlink{tr2rt}{\color{blue} tr2rt}

\vspace{1.5ex}\rule{\textwidth}{1mm}

%---------------------- RTBPose
\hypertarget{RTBPose}{\section*{RTBPose}}
\subsection*{Superclass for SO2, SO3, SE2, SE3}
\addcontentsline{toc}{section}{RTBPose}


This abstract class provides common methods for the 2D and 3D orientation and pose
classes: SO2, SE2, SO3 and SE3.


\subsection*{Display and print methods}
\begin{longtable}{lp{120mm}}
animate & graphically animate coordinate frame for pose\\ 
display & print the pose in human readable matrix form\\ 
plot & graphically display coordinate frame for pose\\ 
print & print the pose in single line format\\ 
\end{longtable}\vspace{1ex}

\subsection*{Group operations}
\begin{longtable}{lp{120mm}}
\textasteriskcentered  & mtimes: multiplication within group, also transform vector\\ 
/ & mrdivide: multiplication within group by inverse\\ 
prod & mower: product of elements\\ 
\end{longtable}\vspace{1ex}

\subsection*{Methods}
\begin{longtable}{lp{120mm}}
dim & dimension of the underlying matrix\\ 
isSE & true for SE2 and SE3\\ 
issym & true if value is symbolic\\ 
simplify & apply symbolic simplification to all elements\\ 
vpa & apply vpa to all elements\\ 
\end{longtable}\vspace{1ex}


\% Conversion methods::

\begin{longtable}{lp{120mm}}
char & convert to human readable matrix as a string\\ 
double & convert to real rotation or homogeneous transformation matrix\\ 
\end{longtable}\vspace{1ex}

\subsection*{Operators}
\begin{longtable}{lp{120mm}}
+ & plus: elementwise addition, result is a matrix\\ 
- & minus: elementwise subtraction, result is a matrix\\ 
== & eq: test equality\\ 
$\sim=$ & ne: test inequality\\ 
\end{longtable}\vspace{1ex}

\subsection*{Compatibility methods}


A number of compatibility methods give the same behaviour as the
classic RTB functions:

\begin{longtable}{lp{120mm}}
tr2rt & convert to rotation matrix and translation vector\\ 
t2r & convert to rotation matrix\\ 
tranimate & animate coordinate frame\\ 
trprint & print single line representation\\ 
trprint2 & print single line representation\\ 
trplot & plot coordinate frame\\ 
trplot2 & plot coordinate frame\\ 
\end{longtable}\vspace{1ex}

\subsection*{Notes}
\begin{itemize}
  \item This is a handle class.
  \item RTBPose subclasses can be used in vectors and arrays.
  \item Multiplication and division with normalization operations are performed    in the subclasses.
  \item SO3 is polymorphic with UnitQuaternion making it easy to change    rotational representations.
\end{itemize}

\subsection*{See also}


\hyperlink{SO2}{\color{blue} SO2}, \hyperlink{SO3}{\color{blue} SO3}, \hyperlink{SE2}{\color{blue} SE2}, \hyperlink{SE3}{\color{blue} SE3}

\vspace{1.5ex}\hrule

%---------------------- RTBPose.animate
\hypertarget{RTBPose.animate}{\section*{RTBPose.animate}}
\subsection*{Animate a coordinate frame}
\addcontentsline{tom}{section}{RTBPose.animate}


\texttt{RTBPose.animate(P1, P2, OPTIONS)} animates a 3D coordinate frame moving from
RTBPose \texttt{P1} to RTBPose \texttt{P2}.



\texttt{RTBPose.animate(P, OPTIONS)} animates a coordinate frame moving from the identity pose
to the RTBPose \texttt{P}.



\texttt{RTBPose.animate(PV, OPTIONS)} animates a trajectory, where \texttt{PV} is a vector of
RTBPose subclass objects.

\begin{Code}
      %
\end{Code}

\subsection*{Options}
\begin{longtable}{lp{120mm}}
\textquotesingle fps\textquotesingle , fps & Number of frames per second to display (default 10)\\ 
\textquotesingle nsteps\textquotesingle , n & The number of steps along the path (default 50)\\ 
\textquotesingle axis\textquotesingle ,A & Axis bounds [xmin, xmax, ymin, ymax, zmin, zmax]\\ 
\textquotesingle movie\textquotesingle ,M & Save frames as files in the folder M\\ 
\textquotesingle cleanup\textquotesingle  & Remove the frame at end of animation\\ 
\textquotesingle noxyz\textquotesingle  & Don\textquotesingle t label the axes\\ 
\textquotesingle rgb\textquotesingle  & Color the axes in the order x=red, y=green, z=blue\\ 
\textquotesingle retain\textquotesingle  & Retain frames, don\textquotesingle t animate\\ 
\end{longtable}\vspace{1ex}


Additional options are passed through to tranimate or tranimate2.


\subsection*{See also}


\hyperlink{tranimate}{\color{blue} tranimate}, \hyperlink{tranimate2}{\color{blue} tranimate2}

\vspace{1.5ex}\hrule

%---------------------- RTBPose.char
\hypertarget{RTBPose.char}{\section*{RTBPose.char}}
\subsection*{Convert to string}
\addcontentsline{tom}{section}{RTBPose.char}


\texttt{s = P.char()} is a string showing \textbf{\color{red} RTBPose} matrix elements as
a matrix.


\subsection*{See also}


\hyperlink{RTBPose.display}{\color{blue} RTBPose.display}

\vspace{1.5ex}\hrule

%---------------------- RTBPose.dim
\hypertarget{RTBPose.dim}{\section*{RTBPose.dim}}
\subsection*{Dimension}
\addcontentsline{tom}{section}{RTBPose.dim}


\texttt{N = P.dim()} is the dimension of the matrix representing the \textbf{\color{red} RTBPose}
subclass instance P.  It is 2 for SO2, 3 for SE2 and SO3, and 4 for SE3.

\vspace{1.5ex}\hrule

%---------------------- RTBPose.display
\hypertarget{RTBPose.display}{\section*{RTBPose.display}}
\subsection*{Display pose in matrix form}
\addcontentsline{tom}{section}{RTBPose.display}


\texttt{P.display()} displays the matrix elements for the \textbf{\color{red} RTBPose} instance P to
the console. If P is a vector ($1 \times N$) then matrices are displayed sequentially.


\subsection*{Notes}
\begin{itemize}
  \item This method is invoked implicitly at the command line when the result    of an expression is an RTBPose subclass object and the command has no trailing
  \item semicolon.
  \item If the function cprintf is found is used to colorise the matrix:    rotational elements in red, translational in blue.
  \item See \url{https://www.mathworks.com/matlabcentral/fileexchange/24093-cprintf-display-formatted-colored-text-in-the-command-window}
\end{itemize}

\subsection*{See also}


\hyperlink{SO2}{\color{blue} SO2}, \hyperlink{SO3}{\color{blue} SO3}, \hyperlink{SE2}{\color{blue} SE2}, \hyperlink{SE3}{\color{blue} SE3}

\vspace{1.5ex}\hrule

%---------------------- RTBPose.double
\hypertarget{RTBPose.double}{\section*{RTBPose.double}}
\subsection*{Convert to matrix}
\addcontentsline{tom}{section}{RTBPose.double}


\texttt{T = P.double()} is a native matrix representation of the \textbf{\color{red} RTBPose}
subclass instance P, either a rotation matrix or a homogeneous
transformation matrix.



If P is a vector ($1 \times N$) then \texttt{T} will be a 3-dimensional array ($M \times M \times N$).


\subsection*{Notes}
\begin{itemize}
  \item If the pose is symbolic the result will be a symbolic matrix.
\end{itemize}
\vspace{1.5ex}\hrule

%---------------------- RTBPose.ishomog
\hypertarget{RTBPose.ishomog}{\section*{RTBPose.ishomog}}
\subsection*{Test if SE3 class (compatibility)}
\addcontentsline{tom}{section}{RTBPose.ishomog}


\texttt{ISHOMOG(T)} is true (1) if \texttt{T} is of class SE3.


\subsection*{See also}


\hyperlink{ishomog}{\color{blue} ishomog}

\vspace{1.5ex}\hrule

%---------------------- RTBPose.ishomog2
\hypertarget{RTBPose.ishomog2}{\section*{RTBPose.ishomog2}}
\subsection*{Test if SE2 class (compatibility)}
\addcontentsline{tom}{section}{RTBPose.ishomog2}


\texttt{ISHOMOG2(T)} is true (1) if \texttt{T} is of class SE2.


\subsection*{See also}


\hyperlink{ishomog2}{\color{blue} ishomog2}

\vspace{1.5ex}\hrule

%---------------------- RTBPose.isrot
\hypertarget{RTBPose.isrot}{\section*{RTBPose.isrot}}
\subsection*{Test if SO3 class (compatibility)}
\addcontentsline{tom}{section}{RTBPose.isrot}


\texttt{ISROT(R)} is true (1) if \texttt{R} is of class SO3.


\subsection*{See also}


\hyperlink{isrot}{\color{blue} isrot}

\vspace{1.5ex}\hrule

%---------------------- RTBPose.isrot2
\hypertarget{RTBPose.isrot2}{\section*{RTBPose.isrot2}}
\subsection*{Test if SO2 class (compatibility)}
\addcontentsline{tom}{section}{RTBPose.isrot2}


\texttt{ISROT2(R)} is true (1) if \texttt{R} is of class SO2.


\subsection*{See also}


\hyperlink{isrot2}{\color{blue} isrot2}

\vspace{1.5ex}\hrule

%---------------------- RTBPose.isSE
\hypertarget{RTBPose.isSE}{\section*{RTBPose.isSE}}
\subsection*{Test if rigid-body motion}
\addcontentsline{tom}{section}{RTBPose.isSE}


\texttt{P.isSE()} is true if P is an instance of the \textbf{\color{red} RTBPose} sublass SE2 or SE3.

\vspace{1.5ex}\hrule

%---------------------- RTBPose.issym
\hypertarget{RTBPose.issym}{\section*{RTBPose.issym}}
\subsection*{Test if pose is symbolic}
\addcontentsline{tom}{section}{RTBPose.issym}


\texttt{P.issym()} is true if the \textbf{\color{red} RTBPose} subclass instance P has symbolic rather
than real values.

\vspace{1.5ex}\hrule

%---------------------- RTBPose.isvec
\hypertarget{RTBPose.isvec}{\section*{RTBPose.isvec}}
\subsection*{Test if vector (compatibility)}
\addcontentsline{tom}{section}{RTBPose.isvec}


\texttt{ISVEC(T)} is always false.


\subsection*{See also}


\hyperlink{isvec}{\color{blue} isvec}

\vspace{1.5ex}\hrule

%---------------------- RTBPose.minus
\hypertarget{RTBPose.minus}{\section*{RTBPose.minus}}
\subsection*{Subtract poses}
\addcontentsline{tom}{section}{RTBPose.minus}


\texttt{P1-P2} is the elementwise difference of the matrix elements of the two
poses.  The result is a matrix not the input class type since the result
of subtraction is not in the group.

\vspace{1.5ex}\hrule

%---------------------- RTBPose.mpower
\hypertarget{RTBPose.mpower}{\section*{RTBPose.mpower}}
\subsection*{Exponential of pose}
\addcontentsline{tom}{section}{RTBPose.mpower}


\texttt{P\textasciicircum N} is an \textbf{\color{red} RTBPose} subclass instance equal to \textbf{\color{red} RTBPose} subclass instance \texttt{P} raised
to the integer power \texttt{N}.  It is equivalent of compounding \texttt{P} with itself \texttt{N}-1 times.


\subsection*{Notes}
\begin{itemize}
  \item \texttt{N} can be 0 in which case the result is the identity element.
  \item \texttt{N} can be negative which is equivalent to the inverse of \textasciicircum -\texttt{N}).
\end{itemize}

\subsection*{See also}


\hyperlink{RTBPose.power}{\color{blue} RTBPose.power}, \hyperlink{RTBPose.mtimes}{\color{blue} RTBPose.mtimes}, \hyperlink{RTBPose.times}{\color{blue} RTBPose.times}

\vspace{1.5ex}\hrule

%---------------------- RTBPose.mrdivide
\hypertarget{RTBPose.mrdivide}{\section*{RTBPose.mrdivide}}
\subsection*{Compound SO2 object with inverse}
\addcontentsline{tom}{section}{RTBPose.mrdivide}


\texttt{R = P/Q} is an \textbf{\color{red} RTBPose} subclass instance representing the composition of the
RTBPose subclass instance \texttt{P} by the inverse of the RTBPose subclass instance \texttt{Q}.



If either, or both, of \texttt{P} or \texttt{Q} are vectors, then the result is a vector.

\begin{itemize}
  \item if \texttt{P} is a vector ($1 \times N$) then \texttt{R} is a vector ($1 \times N$) such that \texttt{R}(i) = \texttt{P}(i)/\texttt{Q}.
  \item if \texttt{P} is a vector ($1 \times N$) then \texttt{R} is a vector ($1 \times N$) such that \texttt{R}(i) = \texttt{P}/\texttt{Q}(i).
  \item if both \texttt{P} and \texttt{Q} are vectors ($1 \times N$) then \texttt{R} is a vector ($1 \times N$) such     that \texttt{R}(i) = \texttt{P}(i)/\texttt{Q}(i).
\end{itemize}

\subsection*{Notes}
\begin{itemize}
  \item Computed by matrix multiplication of their equivalent matrices with    the second one inverted.
\end{itemize}

\subsection*{See also}


\hyperlink{RTBPose.mtimes}{\color{blue} RTBPose.mtimes}

\vspace{1.5ex}\hrule

%---------------------- RTBPose.mtimes
\hypertarget{RTBPose.mtimes}{\section*{RTBPose.mtimes}}
\subsection*{Compound pose objects}
\addcontentsline{tom}{section}{RTBPose.mtimes}


\texttt{R = P*Q} is an \textbf{\color{red} RTBPose} subclass instance representing the composition of the
RTBPose subclass instance \texttt{P} by the RTBPose subclass instance \texttt{Q}.



If either, or both, of \texttt{P} or \texttt{Q} are vectors, then the result is a vector.

\begin{itemize}
  \item if \texttt{P} is a vector ($1 \times N$) then \texttt{R} is a vector ($1 \times N$) such that \texttt{R}(i) = \texttt{P}(i)*\texttt{Q}.
  \item if \texttt{P} is a vector ($1 \times N$) then \texttt{R} is a vector ($1 \times N$) such that \texttt{R}(i) = \texttt{P}*\texttt{Q}(i).
  \item if both \texttt{P} and \texttt{Q} are vectors ($1 \times N$) then \texttt{R} is a vector ($1 \times N$) such     that \texttt{R}(i) = \texttt{P}(i)*\texttt{Q}(i).
\end{itemize}


\texttt{W = P*V} is a column vector ($2 \times 1$) which is the transformation of the
column vector \texttt{V} ($2 \times 1$) by the matrix representation of the RTBPose
subclass instance \texttt{P}.



\texttt{P} can be a vector and/or \texttt{V} can be a matrix, a columnwise set of vectors:

\begin{itemize}
  \item if \texttt{P} is a vector ($1 \times N$) then \texttt{W} is a matrix ($2 \times N$) such that \texttt{W}(:,i) = \texttt{P}(i)*\texttt{V}.
  \item if \texttt{V} is a matrix ($2 \times N$) \texttt{V} is a matrix ($2 \times N$) then \texttt{W} is a matrix ($2 \times N$) such     that \texttt{W}(:,i) = \texttt{P}*\texttt{V}(:,i).
  \item if \texttt{P} is a vector ($1 \times N$) and \texttt{V} is a matrix ($2 \times N$) then \texttt{W} is a matrix ($2 \times N$)     such that \texttt{W}(:,i) = \texttt{P}(i)*\texttt{V}(:,i).
\end{itemize}

\subsection*{Notes}
\begin{itemize}
  \item Computed by matrix multiplication of their equivalent matrices.
\end{itemize}

\subsection*{See also}


\hyperlink{RTBPose.mrdivide}{\color{blue} RTBPose.mrdivide}

\vspace{1.5ex}\hrule

%---------------------- RTBPose.plot
\hypertarget{RTBPose.plot}{\section*{RTBPose.plot}}
\subsection*{Draw a coordinate frame (compatibility)}
\addcontentsline{tom}{section}{RTBPose.plot}


\texttt{trplot(P, OPTIONS)} draws a 3D coordinate frame represented by \texttt{P} which is
SO2, SO3, SE2 or SE3.



Compatible with matrix function trplot(T).



Options are passed through to trplot or trplot2 depending on the object
type.


\subsection*{See also}


\hyperlink{trplot}{\color{blue} trplot}, \hyperlink{trplot2}{\color{blue} trplot2}

\vspace{1.5ex}\hrule

%---------------------- RTBPose.plus
\hypertarget{RTBPose.plus}{\section*{RTBPose.plus}}
\subsection*{Add poses}
\addcontentsline{tom}{section}{RTBPose.plus}


\texttt{P1+P2} is the elementwise summation of the matrix elements of the
RTBPose subclass instances \texttt{P1} and \texttt{P2}.  The result is a native matrix not
the input class type since the result of addition is not in the group.

\vspace{1.5ex}\hrule

%---------------------- RTBPose.power
\hypertarget{RTBPose.power}{\section*{RTBPose.power}}
\subsection*{Exponential of pose}
\addcontentsline{tom}{section}{RTBPose.power}


\texttt{P.\textasciicircum N} is the exponential of \texttt{P} where \texttt{N} is an integer, followed by normalization.  It is equivalent of compounding
the rigid-body motion of \texttt{P} with itself \texttt{N}-1 times.


\subsection*{Notes}
\begin{itemize}
  \item \texttt{N} can be 0 in which case the result is the identity matrix.
  \item \texttt{N} can be negative which is equivalent to the inverse of \texttt{P}.${}^{abs}$(\texttt{N}).
\end{itemize}

\subsection*{See also}


\hyperlink{RTBPose.mpower}{\color{blue} RTBPose.mpower}, \hyperlink{RTBPose.mtimes}{\color{blue} RTBPose.mtimes}, \hyperlink{RTBPose.times}{\color{blue} RTBPose.times}

\vspace{1.5ex}\hrule

%---------------------- RTBPose.print
\hypertarget{RTBPose.print}{\section*{RTBPose.print}}
\subsection*{Compact display of pose}
\addcontentsline{tom}{section}{RTBPose.print}


\texttt{P.print(OPTIONS)} displays the \textbf{\color{red} RTBPose} subclass instance P in a compact
single-line format.  If P is a vector then each element is printed on
a separate line.


\subsection*{Example}
\begin{Code}
    T = SE3.rand()
    T.print('rpy', 'xyz')  % display using XYZ RPY angles

\end{Code}

\subsection*{Notes}
\begin{itemize}
  \item Options are passed through to trprint or trprint2 depending on the object    type.
\end{itemize}

\subsection*{See also}


\hyperlink{trprint}{\color{blue} trprint}, \hyperlink{trprint2}{\color{blue} trprint2}

\vspace{1.5ex}\hrule

%---------------------- RTBPose.prod
\hypertarget{RTBPose.prod}{\section*{RTBPose.prod}}
\subsection*{Compound array of poses}
\addcontentsline{tom}{section}{RTBPose.prod}


\texttt{P.prod()} is an \textbf{\color{red} RTBPose} subclass instance representing the product (composition) of the
successive elements of P ($1 \times N$).


\subsection*{Note}
\begin{itemize}
  \item Composition is performed with the .* operator, ie. the product is    renormalized at every step.
\end{itemize}

\subsection*{See also}


\hyperlink{RTBPose.times}{\color{blue} RTBPose.times}

\vspace{1.5ex}\hrule

%---------------------- RTBPose.simplify
\hypertarget{RTBPose.simplify}{\section*{RTBPose.simplify}}
\subsection*{Symbolic simplification}
\addcontentsline{tom}{section}{RTBPose.simplify}


\texttt{P2 = P.simplify()} applies symbolic simplification to each element of
internal matrix representation of the RTBPose subclass instance P.


\subsection*{See also}


\hyperlink{simplify}{\color{blue} simplify}

\vspace{1.5ex}\hrule

%---------------------- RTBPose.subs
\hypertarget{RTBPose.subs}{\section*{RTBPose.subs}}
\subsection*{Symbolic substitution}
\addcontentsline{tom}{section}{RTBPose.subs}


\texttt{T = subs(T, old, new)} replaces \texttt{old} with \texttt{new} in the symbolic
transformation \texttt{T}.



See also: subs

\vspace{1.5ex}\hrule

%---------------------- RTBPose.t2r
\hypertarget{RTBPose.t2r}{\section*{RTBPose.t2r}}
\subsection*{Get rotation matrix  (compatibility)}
\addcontentsline{tom}{section}{RTBPose.t2r}


\texttt{t2r(P)} is a native matrix corresponding to the rotational
component of the SE2 or SE3 instance \texttt{P}.


\subsection*{See also}


\hyperlink{t2r}{\color{blue} t2r}

\vspace{1.5ex}\hrule

%---------------------- RTBPose.tr2rt
\hypertarget{RTBPose.tr2rt}{\section*{RTBPose.tr2rt}}
\subsection*{Split rotational and translational components  (compatibility)}
\addcontentsline{tom}{section}{RTBPose.tr2rt}


\texttt{[R,t] = tr2rt(P)} is the rotation matrix and translation vector
corresponding to the SE2 or SE3 instance \texttt{P}.


\subsection*{See also}


\hyperlink{tr2rt}{\color{blue} tr2rt}

\vspace{1.5ex}\hrule

%---------------------- RTBPose.tranimate
\hypertarget{RTBPose.tranimate}{\section*{RTBPose.tranimate}}
\subsection*{Animate a 3D coordinate frame (compatibility)}
\addcontentsline{tom}{section}{RTBPose.tranimate}


\texttt{TRANIMATE(P1, P2, OPTIONS)} animates a 3D coordinate frame moving between
RTBPose subclass instances \texttt{P1} and pose \texttt{P2}.



\texttt{TRANIMATE(P, OPTIONS)} animates a 2D coordinate frame moving from the identity pose
to the RTBPose subclass instance \texttt{P}.



\texttt{TRANIMATE(PV, OPTIONS)} animates a trajectory, where \texttt{PV} is a vector of
RTBPose subclass instances.


\subsection*{Notes}
\begin{itemize}
  \item see tranimate for details of options.
  \item \texttt{P}, \texttt{P1}, \texttt{P2}, \texttt{PV} can be instances of SO3 or SE3.
\end{itemize}

\subsection*{See also}


\hyperlink{RTBPose.animate}{\color{blue} RTBPose.animate}, \hyperlink{tranimate}{\color{blue} tranimate}

\vspace{1.5ex}\hrule

%---------------------- RTBPose.tranimate2
\hypertarget{RTBPose.tranimate2}{\section*{RTBPose.tranimate2}}
\subsection*{Animate a 2D coordinate frame (compatibility)}
\addcontentsline{tom}{section}{RTBPose.tranimate2}


\texttt{TRANIMATE2(P1, P2, OPTIONS)} animates a 2D coordinate frame moving between
RTBPose subclass instances \texttt{P1} and pose \texttt{P2}.



\texttt{TRANIMATE2(P, OPTIONS)} animates a 2D coordinate frame moving from the identity pose
to the RTBPose subclass instance \texttt{P}.



\texttt{TRANIMATE2(PV, OPTIONS)} animates a trajectory, where \texttt{PV} is a vector of
RTBPose subclass instances.


\subsection*{Notes}
\begin{itemize}
  \item see tranimate2 for details of options.
  \item \texttt{P}, \texttt{P1}, \texttt{P2}, \texttt{PV} can be instances of SO2 or SE2.
\end{itemize}

\subsection*{See also}


\hyperlink{RTBPose.animate}{\color{blue} RTBPose.animate}, \hyperlink{tranimate}{\color{blue} tranimate}

\vspace{1.5ex}\hrule

%---------------------- RTBPose.trplot
\hypertarget{RTBPose.trplot}{\section*{RTBPose.trplot}}
\subsection*{Draw a 3D coordinate frame (compatibility)}
\addcontentsline{tom}{section}{RTBPose.trplot}


\texttt{trplot(P, OPTIONS)} draws a 3D coordinate frame represented by \textbf{\color{red} RTBPose}
subclass instance \texttt{P}.


\subsection*{Notes}
\begin{itemize}
  \item see trplot for details of options.
  \item \texttt{P} can be instances of SO3 or SE3.
\end{itemize}

\subsection*{See also}


\hyperlink{RTBPose.plot}{\color{blue} RTBPose.plot}, \hyperlink{trplot}{\color{blue} trplot}

\vspace{1.5ex}\hrule

%---------------------- RTBPose.trplot2
\hypertarget{RTBPose.trplot2}{\section*{RTBPose.trplot2}}
\subsection*{Draw a 2D coordinate frame (compatibility)}
\addcontentsline{tom}{section}{RTBPose.trplot2}


\texttt{trplot2(P, OPTIONS)} draws a 2D coordinate frame represented by \textbf{\color{red} RTBPose}
subclass instance \texttt{P}.


\subsection*{Notes}
\begin{itemize}
  \item see trplot for details of options.
  \item \texttt{P} can be instances of SO2 or SE2.
\end{itemize}

\subsection*{See also}


\hyperlink{RTBPose.plot}{\color{blue} RTBPose.plot}, \hyperlink{trplot2}{\color{blue} trplot2}

\vspace{1.5ex}\hrule

%---------------------- RTBPose.trprint
\hypertarget{RTBPose.trprint}{\section*{RTBPose.trprint}}
\subsection*{Compact display of 3D rotation or transform (compatibility)}
\addcontentsline{tom}{section}{RTBPose.trprint}


\texttt{trprint(P, OPTIONS)} displays the \textbf{\color{red} RTBPose} subclass instance \texttt{P} in a
compact single-line format.  If \texttt{P} is a vector then each element is
printed on a separate line.


\subsection*{Notes}
\begin{itemize}
  \item see trprint for details of options.
  \item \texttt{P} can be instances of SO3 or SE3.
\end{itemize}

\subsection*{See also}


\hyperlink{RTBPose.print}{\color{blue} RTBPose.print}, \hyperlink{trprint}{\color{blue} trprint}

\vspace{1.5ex}\hrule

%---------------------- RTBPose.trprint2
\hypertarget{RTBPose.trprint2}{\section*{RTBPose.trprint2}}
\subsection*{Compact display of 2D rotation or transform (compatibility)}
\addcontentsline{tom}{section}{RTBPose.trprint2}


\texttt{trprint2(P, OPTIONS)} displays the \textbf{\color{red} RTBPose} subclass instance \texttt{P} in a
compact single-line format.  If \texttt{P} is a vector then each element is
printed on a separate line.


\subsection*{Notes}
\begin{itemize}
  \item see trprint for details of options.
  \item \texttt{P} can be instances of SO2 or SE2.
\end{itemize}

\subsection*{See also}


\hyperlink{RTBPose.print}{\color{blue} RTBPose.print}, \hyperlink{trprint2}{\color{blue} trprint2}

\vspace{1.5ex}\hrule

%---------------------- RTBPose.vpa
\hypertarget{RTBPose.vpa}{\section*{RTBPose.vpa}}
\subsection*{Variable precision arithmetic}
\addcontentsline{tom}{section}{RTBPose.vpa}


\texttt{P2 = P.vpa()} numerically evaluates each element of
internal matrix representation of the RTBPose subclass instance P.



\texttt{P2 = P.vpa(D)} as above but with \texttt{D} decimal digit accuracy.


\subsection*{Notes}
\begin{itemize}
  \item Values of symbolic variables are taken from the workspace.
\end{itemize}

\subsection*{See also}


\hyperlink{vpa}{\color{blue} vpa}, \hyperlink{simplify}{\color{blue} simplify}

\vspace{1.5ex}\rule{\textwidth}{1mm}
\vspace{1.5ex}\rule{\textwidth}{1mm}

%---------------------- SE2
\hypertarget{SE2}{\section*{SE2}}
\subsection*{Representation of 2D rigid-body motion}
\addcontentsline{toc}{section}{SE2}


This subclasss of RTBPose is an object that represents rigid-body motion in 2D.
Internally this is a $3 \times 3$ homogeneous transformation matrix ($3 \times 3$) belonging to
the group $\mbox{SE}(2)$.


\subsection*{Constructor methods}
\begin{longtable}{lp{120mm}}
SE2 & general constructor\\ 
SE2.exp & exponentiate an se(2) matrix\\ 
SE2.rand & random transformation\\ 
new & new SE2 object\\ 
\end{longtable}\vspace{1ex}

\subsection*{Display and print methods}
\begin{longtable}{lp{120mm}}
animate & \textasciicircum graphically animate coordinate frame for pose\\ 
display & \textasciicircum print the pose in human readable matrix form\\ 
plot & \textasciicircum graphically display coordinate frame for pose\\ 
print & \textasciicircum print the pose in single line format\\ 
\end{longtable}\vspace{1ex}

\subsection*{Group operations}
\begin{longtable}{lp{120mm}}
\textasteriskcentered  & \textasciicircum mtimes: multiplication (group operator, transform point)\\ 
/ & \textasciicircum mrdivide: multiply by inverse\\ 
\textasciicircum  & \textasciicircum mpower: exponentiate (integer only):\\ 
inv & inverse\\ 
prod & \textasciicircum product of elements\\ 
\end{longtable}\vspace{1ex}

\subsection*{Methods}
\begin{longtable}{lp{120mm}}
det & determinant of matrix component\\ 
eig & eigenvalues of matrix component\\ 
log & logarithm of rotation matrix\\ 
inv & inverse\\ 
simplify\textasteriskcentered  & apply symbolic simplication to all elements\\ 
interp & interpolate between poses\\ 
theta & rotation angle\\ 
\end{longtable}\vspace{1ex}

\subsection*{Information and test methods}
\begin{longtable}{lp{120mm}}
dim & \textasciicircum returns 2\\ 
isSE & \textasciicircum returns true\\ 
issym & \textasciicircum test if rotation matrix has symbolic elements\\ 
SE2.isa & test if matrix is $\mbox{SE}(2)$\\ 
\end{longtable}\vspace{1ex}

\subsection*{Conversion methods}
\begin{longtable}{lp{120mm}}
char\textasteriskcentered  & convert to human readable matrix as a string\\ 
SE2.convert & convert SE2 object or $\mbox{SE}(2)$ matrix to SE2 object\\ 
double & convert to rotation matrix\\ 
R & convert to rotation matrix\\ 
SE3 & convert to SE3 object with zero translation\\ 
SO2 & convert rotational part to SO2 object\\ 
T & convert to homogeneous transformation matrix\\ 
Twist & convert to Twist object\\ 
t & get.t: convert to translation column vector\\ 
\end{longtable}\vspace{1ex}

\subsection*{Compatibility methods}
\begin{longtable}{lp{120mm}}
isrot2 & \textasciicircum returns false\\ 
ishomog2 & \textasciicircum returns true\\ 
tr2rt & \textasciicircum convert to rotation matrix and translation vector\\ 
t2r & \textasciicircum convert to rotation matrix\\ 
transl2 & \textasciicircum translation as a row vector\\ 
trprint2 & \textasciicircum print single line representation\\ 
trplot2 & \textasciicircum plot coordinate frame\\ 
tranimate2 & \textasciicircum animate coordinate frame\\ 
\end{longtable}\vspace{1ex}


\textasciicircum  inherited from RTBPose class.


\subsection*{See also}


\hyperlink{SO2}{\color{blue} SO2}, \hyperlink{SE3}{\color{blue} SE3}, \hyperlink{RTBPose}{\color{blue} RTBPose}

\vspace{1.5ex}\hrule

%---------------------- SE2.SE2
\hypertarget{SE2.SE2}{\section*{SE2.SE2}}
\subsection*{Construct an $\mbox{SE}(2)$ object}
\addcontentsline{tom}{section}{SE2.SE2}


Constructs an $\mbox{SE}(2)$ pose object that contains a $3 \times 3$ homogeneous transformation
matrix.



\texttt{T = SE2()} is the identity element, a null motion.



\texttt{T = SE2(X, Y)} is an object representing pure translation defined by \texttt{X} and \texttt{Y}.



\texttt{T = SE2(XY)} is an object representing pure translation defined by \texttt{XY}
($2 \times 1$). If \texttt{XY} ($N \times 2$) returns an array of SE2 objects, corresponding to
the rows of \texttt{XY}.



\texttt{T = SE2(X, Y, THETA)} is an object representing translation, \texttt{X} and \texttt{Y}, and
rotation, angle \texttt{THETA}.



\texttt{T = SE2(XY, THETA)} is an object representing translation, \texttt{XY} ($2 \times 1$), and
rotation, angle \texttt{THETA}.



\texttt{T = SE2(XYT)} is an object representing translation, \texttt{XYT}(1) and \texttt{XYT}(2),
and rotation angle \texttt{XYT}(3). If \texttt{XYT} ($N \times 3$) returns an array of SE2 objects, corresponding to
the rows of \texttt{XYT}.



\texttt{T = SE2(T)} is an object representing translation and rotation defined by
the $\mbox{SE}(2)$ homogeneous transformation matrix \texttt{T} ($3 \times 3$).  If \texttt{T} ($3 \times 3 \times N$) returns an
array ($1 \times N$) of SE2 objects, corresponding to the third index of \texttt{T}.



\texttt{T = SE2(R)} is an object representing pure rotation defined by the
$\mbox{SO}(2)$ rotation matrix \texttt{R} ($2 \times 2$)



\texttt{T = SE2(R, XY)} is an object representing rotation defined by the
orthonormal rotation matrix \texttt{R} ($2 \times 2$) and position given by \texttt{XY} ($2 \times 1$)



\texttt{T = SE2(T)} is a copy of the \textbf{\color{red} SE2} object \texttt{T}. If \texttt{T} ($N \times 1$) returns an array of \textbf{\color{red} SE2} objects,
corresponding to the index of \texttt{T}.


\subsection*{Options}
\begin{longtable}{lp{120mm}}
\textquotesingle deg\textquotesingle  & Angle is specified in degrees\\ 
\end{longtable}\vspace{1ex}

\subsection*{Notes}
\begin{itemize}
  \item Arguments can be symbolic
  \item The form SE2(\texttt{XY}) is ambiguous with SE2(\texttt{R}) if \texttt{XY} has 2 rows, the second form is assumed.
  \item The form SE2(\texttt{XYT}) is ambiguous with SE2(\texttt{T}) if \texttt{XYT} has 3 rows, the second form is assumed.
  \item \texttt{R} and \texttt{T} are checked to be valid $\mbox{SO}(2)$ or $\mbox{SE}(2)$ matrices.
\end{itemize}
\vspace{1.5ex}\hrule

%---------------------- SE2.convert
\hypertarget{SE2.convert}{\section*{SE2.convert}}
\subsection*{Convert to SE2}
\addcontentsline{tom}{section}{SE2.convert}


\texttt{Q = SE2.convert(X)} is an \textbf{\color{red} SE2} object equivalent to \texttt{X} where \texttt{X} is either
an SE2 object, or an $\mbox{SE}(2)$ homogeneous transformation matrix ($3 \times 3$).

\vspace{1.5ex}\hrule

%---------------------- SE2.exp
\hypertarget{SE2.exp}{\section*{SE2.exp}}
\subsection*{Construct SE2 from Lie algebra}
\addcontentsline{tom}{section}{SE2.exp}


\texttt{SE2.exp(SIGMA)} is the \textbf{\color{red} SE2} rigid-body motion corresponding to the se(2)
Lie algebra element \texttt{SIGMA} ($3 \times 3$).



\texttt{SE3.exp(TW)} as above but the Lie algebra is represented
as a twist vector \texttt{TW} ($1 \times 1$).


\subsection*{Notes}
\begin{itemize}
  \item \texttt{TW} is the non-zero elements of X.
\end{itemize}

\subsection*{Reference}
\begin{itemize}
  \item Robotics, Vision \& Control: Second Edition, P. Corke, Springer 2016; p25-31.
\end{itemize}

\subsection*{See also}


\hyperlink{trexp2}{\color{blue} trexp2}, \hyperlink{skewa}{\color{blue} skewa}

\vspace{1.5ex}\hrule

%---------------------- SE2.get.t
\hypertarget{SE2.get.t}{\section*{SE2.get.t}}
\subsection*{Get translational component}
\addcontentsline{tom}{section}{SE2.get.t}


\texttt{P.t} is a column vector ($2 \times 1$) representing the translational component of
the rigid-body motion described by the SE2 object \texttt{P}.


\subsection*{Notes}
\begin{itemize}
  \item If \texttt{P} is a vector the result is a MATLAB comma separated list, in this    case use \texttt{P}.transl().
\end{itemize}

\subsection*{See also}


\hyperlink{SE2.transl}{\color{blue} SE2.transl}

\vspace{1.5ex}\hrule

%---------------------- SE2.interp
\hypertarget{SE2.interp}{\section*{SE2.interp}}
\subsection*{Interpolate between SO2 objects}
\addcontentsline{tom}{section}{SE2.interp}


\texttt{P1.interp(P2, s)} is an \textbf{\color{red} SE2} object which is an interpolation
between poses represented by SE2 objects P1 and \texttt{P2}.  \texttt{s} varies from 0
(P1) to 1 (\texttt{P2}). If \texttt{s} is a vector ($1 \times N$) then the result will be a vector
of SE2 objects.


\subsection*{Notes}
\begin{itemize}
  \item It is an error if S is outside the interval 0 to 1.
\end{itemize}

\subsection*{See also}


\hyperlink{SO2.angle}{\color{blue} SO2.angle}

\vspace{1.5ex}\hrule

%---------------------- SE2.inv
\hypertarget{SE2.inv}{\section*{SE2.inv}}
\subsection*{Inverse of SE2 object}
\addcontentsline{tom}{section}{SE2.inv}


\texttt{Q = inv(P)} is the inverse of the \textbf{\color{red} SE2} object \texttt{P}.


\subsection*{Notes}
\begin{itemize}
  \item This is formed explicitly, no matrix inverse required.
  \item This is a group operator: input and output in the $\mbox{SE}(2)$ group.
  \item \texttt{P}*\texttt{Q} will be the identity group element (zero motion, identity matrix).
\end{itemize}
\vspace{1.5ex}\hrule

%---------------------- SE2.isa
\hypertarget{SE2.isa}{\section*{SE2.isa}}
\subsection*{Test if matrix is $\mbox{SE}(2)$}
\addcontentsline{tom}{section}{SE2.isa}


\texttt{SE2.isa(T)} is true (1) if the argument \texttt{T} is of dimension $3 \times 3$ or $3 \times 3 \times N$, else
false (0).



\texttt{SE2.isa(T, true)} as above, but also checks the validity of the rotation
sub-matrix.


\subsection*{Notes}
\begin{itemize}
  \item This is a class method.
  \item The first form is a fast, but incomplete, test for a transform in $\mbox{SE}(3)$.
  \item There is ambiguity in the dimensions of SE2 and SO3 in matrix form.
\end{itemize}

\subsection*{See also}


\hyperlink{SO3.ISA}{\color{blue} SO3.ISA}, \hyperlink{SE2.ISA}{\color{blue} SE2.ISA}, \hyperlink{SO2.ISA}{\color{blue} SO2.ISA}, \hyperlink{ishomog2}{\color{blue} ishomog2}

\vspace{1.5ex}\hrule

%---------------------- SE2.log
\hypertarget{SE2.log}{\section*{SE2.log}}
\subsection*{Lie algebra}
\addcontentsline{tom}{section}{SE2.log}


\texttt{se2 = P.log()} is the Lie algebra corresponding to the \textbf{\color{red} SE2} object P. It is
an augmented skew-symmetric matrix ($3 \times 3$).


\subsection*{See also}


\hyperlink{SE2.Twist}{\color{blue} SE2.Twist}, \hyperlink{logm}{\color{blue} logm}, \hyperlink{skewa}{\color{blue} skewa}, \hyperlink{vexa}{\color{blue} vexa}

\vspace{1.5ex}\hrule

%---------------------- SE2.new
\hypertarget{SE2.new}{\section*{SE2.new}}
\subsection*{Construct a new object of the same type}
\addcontentsline{tom}{section}{SE2.new}


\texttt{P2 = P.new(X)} creates a new object of the same type as P, by invoking the \textbf{\color{red} SE2} constructor on the matrix
\texttt{X} ($3 \times 3$).



\texttt{P2 = P.new()} as above but defines a null motion.


\subsection*{Notes}
\begin{itemize}
  \item Serves as a dynamic constructor.
  \item This method is polymorphic across all RTBPose derived classes, and     allows easy creation of a new object of the same class as an existing
  \item one without needing to explicitly determine its type.
\end{itemize}

\subsection*{See also}


\hyperlink{SE3.new}{\color{blue} SE3.new}, \hyperlink{SO3.new}{\color{blue} SO3.new}, \hyperlink{SO2.new}{\color{blue} SO2.new}

\vspace{1.5ex}\hrule

%---------------------- SE2.rand
\hypertarget{SE2.rand}{\section*{SE2.rand}}
\subsection*{Construct a random $\mbox{SE}(2)$ object}
\addcontentsline{tom}{section}{SE2.rand}


\texttt{SE2.rand()} is an \textbf{\color{red} SE2} object with a uniform random translation and a
uniform random orientation.  Random numbers are in the interval [-1 1]
and rotations in the interval [-$\pi$ $\pi$].


\subsection*{See also}


\hyperlink{rand}{\color{blue} rand}

\vspace{1.5ex}\hrule

%---------------------- SE2.SE3
\hypertarget{SE2.SE3}{\section*{SE2.SE3}}
\subsection*{Lift to 3D}
\addcontentsline{tom}{section}{SE2.SE3}


\texttt{Q = P.SE3()} is an SE3 object formed by lifting the rigid-body motion
described by the SE2 object P from 2D to 3D.  The rotation is about the
z-axis, and the translation is within the xy-plane.


\subsection*{See also}


\hyperlink{SE3}{\color{blue} SE3}

\vspace{1.5ex}\hrule

%---------------------- SE2.set.t
\hypertarget{SE2.set.t}{\section*{SE2.set.t}}
\subsection*{Set translational component}
\addcontentsline{tom}{section}{SE2.set.t}


\texttt{P.t} = TV sets the translational component of the rigid-body motion
described by the SE2 object \texttt{P} to TV ($2 \times 1$).


\subsection*{Notes}
\begin{itemize}
  \item TV can be a row or column vector.
  \item If TV contains a symbolic value then the entire matrix becomes    symbolic.
\end{itemize}
\vspace{1.5ex}\hrule

%---------------------- SE2.SO2
\hypertarget{SE2.SO2}{\section*{SE2.SO2}}
\subsection*{Extract $\mbox{SO}(2)$ rotation}
\addcontentsline{tom}{section}{SE2.SO2}


\texttt{Q = SO2(P)} is an SO2 object that represents the rotational component of
the SE2 rigid-body motion.


\subsection*{See also}


\hyperlink{SE2.R}{\color{blue} SE2.R}

\vspace{1.5ex}\hrule

%---------------------- SE2.T
\hypertarget{SE2.T}{\section*{SE2.T}}
\subsection*{Get homogeneous transformation matrix}
\addcontentsline{tom}{section}{SE2.T}


\texttt{T = P.T()} is the homogeneous transformation matrix ($3 \times 3$) associated with the
SE2 object P, and has zero translational component.  If P is a vector
($1 \times N$) then \texttt{T} ($3 \times 3 \times N$) is a stack of homogeneous transformation matrices, with the third
dimension corresponding to the index of P.


\subsection*{See also}


\hyperlink{SO2.T}{\color{blue} SO2.T}

\vspace{1.5ex}\hrule

%---------------------- SE2.transl
\hypertarget{SE2.transl}{\section*{SE2.transl}}
\subsection*{Get translational component}
\addcontentsline{tom}{section}{SE2.transl}


\texttt{TV = P.transl()} is a row vector ($1 \times 2$) representing the translational component of
the rigid-body motion described by the SE2 object P.  If P is a vector of
objects ($1 \times N$) then \texttt{TV} ($N \times 2$) will have one row per object element.

\vspace{1.5ex}\hrule

%---------------------- SE2.Twist
\hypertarget{SE2.Twist}{\section*{SE2.Twist}}
\subsection*{Convert to Twist object}
\addcontentsline{tom}{section}{SE2.Twist}


\texttt{TW = P.Twist()} is the equivalent Twist object.  The elements of the twist are the unique
elements of the Lie algebra of the SE2 object P.


\subsection*{See also}


\hyperlink{SE2.log}{\color{blue} SE2.log}, \hyperlink{Twist}{\color{blue} Twist}

\vspace{1.5ex}\hrule

%---------------------- SE2.xyt
\hypertarget{SE2.xyt}{\section*{SE2.xyt}}
\subsection*{Extract configuration}
\addcontentsline{tom}{section}{SE2.xyt}


\texttt{XYT = P.xyt()} is a column vector ($3 \times 1$) comprising the minimum three
configuration parameters of this rigid-body motion: translation (x,y)
and rotation theta.

\vspace{1.5ex}\rule{\textwidth}{1mm}

%---------------------- SE3
\hypertarget{SE3}{\section*{SE3}}
\subsection*{Representation of 3D rigid-body motion}
\addcontentsline{toc}{section}{SE3}


This subclasss of RTBPose is an object that represents rigid-body motion in 2D.
Internally this is a $3 \times 3$ homogeneous transformation matrix ($4 \times 4$) belonging to
the group $\mbox{SE}(3)$.


\subsection*{Constructor methods}
\begin{longtable}{lp{120mm}}
SE3 & general constructor\\ 
SE3.angvec & rotation about vector\\ 
SE3.eul & rotation defined by Euler angles\\ 
SE3.exp & exponentiate an se(3) matrix\\ 
SE3.oa & rotation defined by o- and a-vectors\\ 
SE3.Rx & rotation about x-axis\\ 
SE3.Ry & rotation about y-axis\\ 
SE3.Rz & rotation about z-axis\\ 
SE3.rand & random transformation\\ 
SE3.rpy & rotation defined by roll-pitch-yaw angles\\ 
new & new SE3 object\\ 
\end{longtable}\vspace{1ex}

\subsection*{Display and print methods}
\begin{longtable}{lp{120mm}}
animate & \textasciicircum graphically animate coordinate frame for pose\\ 
display & \textasciicircum print the pose in human readable matrix form\\ 
plot & \textasciicircum graphically display coordinate frame for pose\\ 
print & \textasciicircum print the pose in single line format\\ 
\end{longtable}\vspace{1ex}

\subsection*{Group operations}
\begin{longtable}{lp{120mm}}
\textasteriskcentered  & \textasciicircum mtimes: multiplication (group operator, transform point)\\ 
.\textasteriskcentered  & \textasciicircum\textasciicircum times: multiplication (group operator) followed by normalization\\ 
/ & \textasciicircum mrdivide: multiply by inverse\\ 
./ & \textasciicircum\textasciicircum rdivide: multiply by inverse followed by normalization\\ 
\textasciicircum  & \textasciicircum mpower: xponentiate (integer only)\\ 
.\textasciicircum  & \textasciicircum power: exponentiate followed by normalization\\ 
inv & inverse\\ 
prod & \textasciicircum product of elements\\ 
\end{longtable}\vspace{1ex}

\subsection*{Methods}
\begin{longtable}{lp{120mm}}
det & determinant of matrix component\\ 
eig & eigenvalues of matrix component\\ 
log & logarithm of rotation matrixr$>$=0 \&\& r$<$=1ub\\ 
simplify & \textasciicircum apply symbolic simplication to all elements\\ 
Ad & adjoint matrix ($6 \times 6$)\\ 
increment & update pose based on incremental motion\\ 
interp & interpolate poses\\ 
velxform & compute velocity transformation\\ 
interp & interpolate between poses\\ 
ctraj & Cartesian motion\\ 
norm & normalize the rotation submatrix\\ 
\end{longtable}\vspace{1ex}

\subsection*{Information and test methods}
\begin{longtable}{lp{120mm}}
dim\textasteriskcentered  & returns 4\\ 
isSE\textasteriskcentered  & returns true\\ 
issym\textasteriskcentered  & test if rotation matrix has symbolic elements\\ 
isidentity & test for null motion\\ 
SE3.isa & check if matrix is $\mbox{SE}(3)$\\ 
\end{longtable}\vspace{1ex}

\subsection*{Conversion methods}
\begin{longtable}{lp{120mm}}
char & convert to human readable matrix as a string\\ 
SE3.convert & convert SE3 object or $\mbox{SE}(3)$ matrix to SE3 object\\ 
double & convert to $\mbox{SE}(3)$ matrix\\ 
R & convert rotation part to $\mbox{SO}(3)$ matrix\\ 
SO3 & convert rotation part to SO3 object\\ 
T & convert to $\mbox{SE}(3)$ matrix\\ 
t & translation column vector\\ 
toangvec & convert to rotation about vector form\\ 
todelta & convert to differential motion vector\\ 
toeul & convert to Euler angles\\ 
torpy & convert to roll-pitch-yaw angles\\ 
tv & translation column vector for vector of SE3\\ 
UnitQuaternion & convert to UnitQuaternion object\\ 
\end{longtable}\vspace{1ex}

\subsection*{Compatibility methods}
\begin{longtable}{lp{120mm}}
homtrans & apply to vector\\ 
isrot & \textasciicircum returns false\\ 
ishomog & \textasciicircum returns true\\ 
t2r & \textasciicircum convert to rotation matrix\\ 
tr2rt & \textasciicircum convert to rotation matrix and translation vector\\ 
tr2eul & \textasciicircum\textasciicircum convert to Euler angles\\ 
tr2rpy & \textasciicircum\textasciicircum convert to roll-pitch-yaw angles\\ 
tranimate & \textasciicircum animate coordinate frame\\ 
transl & translation as a row vector\\ 
trnorm & \textasciicircum\textasciicircum normalize the rotation matrix\\ 
trplot & \textasciicircum plot coordinate frame\\ 
trprint & \textasciicircum print single line representation\\ 
\end{longtable}\vspace{1ex}

\subsection*{Other operators}
\begin{longtable}{lp{120mm}}
+ & \textasciicircum plus: elementwise addition, result is a matrix\\ 
- & \textasciicircum minus: elementwise subtraction, result is a matrix\\ 
== & \textasciicircum eq: test equality\\ 
$\sim=$ & \textasciicircum ne: test inequality\\ 
\end{longtable}\vspace{1ex}
\begin{itemize}
  \item \textasciicircum  inherited from RTBPose
  \item \textasciicircum\textasciicircum  inherited from SO3
\end{itemize}

\subsection*{Properties}
\begin{longtable}{lp{120mm}}
n & get.n: normal (x) vector\\ 
o & get.o: orientation (y) vector\\ 
a & get.a: approach (z) vector\\ 
t & get.t: translation vector\\ 
\end{longtable}\vspace{1ex}


For single SE3 objects only, for a vector of SE3 objects use the
equivalent methods

\begin{longtable}{lp{120mm}}
t & translation as a $3 \times 1$ vector (read/write)\\ 
R & rotation as a $3 \times 3$ matrix (read)\\ 
\end{longtable}\vspace{1ex}

\subsection*{Notes}
\begin{itemize}
  \item The properies R, t are implemented as MATLAB dependent properties.     When applied to a vector of SE3 object the result is a comma-separated
  \item list which can be converted to a matrix by enclosing it in square
  \item brackets, eg [T.t] or more conveniently using the method T.transl
\end{itemize}

\subsection*{See also}


\hyperlink{SO3}{\color{blue} SO3}, \hyperlink{SE2}{\color{blue} SE2}, \hyperlink{RTBPose}{\color{blue} RTBPose}

\vspace{1.5ex}\hrule

%---------------------- SE3.SE3
\hypertarget{SE3.SE3}{\section*{SE3.SE3}}
\subsection*{Create an $\mbox{SE}(3)$ object}
\addcontentsline{tom}{section}{SE3.SE3}


Constructs an $\mbox{SE}(3)$ pose object that contains a $4 \times 4$ homogeneous transformation matrix.



\texttt{T = SE3()} is the identity element, a null motion.



\texttt{T = SE3(X, Y, Z)} is an object representing pure translation defined by \texttt{X},
\texttt{Y} and \texttt{Z}.



\texttt{T = SE3(XYZ)} is an object representing pure translation defined by \texttt{XYZ}
($3 \times 1$).  If \texttt{XYZ} ($N \times 3$) returns an array of SE3 objects, corresponding to
the rows of \texttt{XYZ}.



\texttt{T = SE3(T)} is an object representing translation and rotation defined by
the homogeneous transformation matrix \texttt{T} ($3 \times 3$).  If \texttt{T} ($3 \times 3 \times N$) returns an array of SE3 objects,
corresponding to the third index of \texttt{T}.



\texttt{T = SE3(R, XYZ)} is an object representing rotation defined by the
orthonormal rotation matrix \texttt{R} ($3 \times 3$) and position given by \texttt{XYZ} ($3 \times 1$).



\texttt{T = SE3(T)} is a copy of the \textbf{\color{red} SE3} object \texttt{T}. If \texttt{T} ($N \times 1$) returns an array of \textbf{\color{red} SE3} objects,
corresponding to the index of \texttt{T}.


\subsection*{Options}
\begin{longtable}{lp{120mm}}
\textquotesingle deg\textquotesingle  & Angle is specified in degrees\\ 
\end{longtable}\vspace{1ex}

\subsection*{Notes}
\begin{itemize}
  \item Arguments can be symbolic.
  \item \texttt{R} and \texttt{T} are checked to be valid $\mbox{SO}(2)$ or $\mbox{SE}(2)$ matrices.
\end{itemize}
\vspace{1.5ex}\hrule

%---------------------- SE3.Ad
\hypertarget{SE3.Ad}{\section*{SE3.Ad}}
\subsection*{Adjoint matrix}
\addcontentsline{tom}{section}{SE3.Ad}


\texttt{A = P.Ad()} is the adjoint matrix ($6 \times 6$) corresponding to the pose P.


\subsection*{See also}


\hyperlink{Twist.ad}{\color{blue} Twist.ad}

\vspace{1.5ex}\hrule

%---------------------- SE3.angvec
\hypertarget{SE3.angvec}{\section*{SE3.angvec}}
\subsection*{Construct SE3 from angle and axis vector}
\addcontentsline{tom}{section}{SE3.angvec}


\texttt{SE3.angvec(THETA, V)} is an \textbf{\color{red} SE3} object equivalent to a rotation of \texttt{THETA}
about the vector \texttt{V} and with zero translation.


\subsection*{Notes}
\begin{itemize}
  \item If \texttt{THETA} == 0 then return identity matrix.
  \item If \texttt{THETA} $\ne$ 0 then \texttt{V} must have a finite length.
\end{itemize}

\subsection*{See also}


\hyperlink{SO3.angvec}{\color{blue} SO3.angvec}, \hyperlink{eul2r}{\color{blue} eul2r}, \hyperlink{rpy2r}{\color{blue} rpy2r}, \hyperlink{tr2angvec}{\color{blue} tr2angvec}

\vspace{1.5ex}\hrule

%---------------------- SE3.convert
\hypertarget{SE3.convert}{\section*{SE3.convert}}
\subsection*{Convert to SE3}
\addcontentsline{tom}{section}{SE3.convert}


\texttt{Q = SE3.convert(X)} is an \textbf{\color{red} SE3} object equivalent to \texttt{X} where \texttt{X} is either
an SE3 object, or an $\mbox{SE}(3)$ homogeneous transformation matrix ($4 \times 4$).

\vspace{1.5ex}\hrule

%---------------------- SE3.ctraj
\hypertarget{SE3.ctraj}{\section*{SE3.ctraj}}
\subsection*{Cartesian trajectory between two poses}
\addcontentsline{tom}{section}{SE3.ctraj}


\texttt{TC = T0.ctraj(T1, N)} is a Cartesian trajectory defined by a vector of \textbf{\color{red} SE3}
objects ($1 \times \texttt{N}$) from pose T0 to \texttt{T1}, both described by SE3 objects.  There
are \texttt{N} points on the trajectory that follow a trapezoidal velocity profile
along the trajectory.



\texttt{TC = CTRAJ(T0, T1, S)} as above but the elements of \texttt{S} ($\texttt{N} \times 1$) specify the
fractional distance  along the path, and these values are in the range [0 1].
The i\textquotesingle th point corresponds to a distance \texttt{S}(i) along the path.


\subsection*{Notes}
\begin{itemize}
  \item In the second case \texttt{S} could be generated by a scalar trajectory generator     such as TPOLY or LSPB (default).
  \item Orientation interpolation is performed using quaternion interpolation.
\end{itemize}

\subsection*{Reference}


Robotics, Vision \& Control, Sec 3.1.5,
Peter Corke, Springer 2011


\subsection*{See also}


\hyperlink{lspb}{\color{blue} lspb}, \hyperlink{mstraj}{\color{blue} mstraj}, \hyperlink{trinterp}{\color{blue} trinterp}, \hyperlink{ctraj}{\color{blue} ctraj}, \hyperlink{UnitQuaternion.interp}{\color{blue} UnitQuaternion.interp}

\vspace{1.5ex}\hrule

%---------------------- SE3.delta
\hypertarget{SE3.delta}{\section*{SE3.delta}}
\subsection*{Construct SE3 object from differential motion vector}
\addcontentsline{tom}{section}{SE3.delta}


\texttt{T = SE3.delta(D)} is an \textbf{\color{red} SE3} pose object representing differential
motion \texttt{D} ($6 \times 1$).



The vector \texttt{D}=(dx, dy, dz, dRx, dRy, dRz) represents infinitessimal translation
and rotation, and is an approximation to the instantaneous spatial velocity
multiplied by time step.


\subsection*{Reference}
\begin{itemize}
  \item Robotics, Vision \& Control: Second Edition, P. Corke, Springer 2016; p67.
\end{itemize}

\subsection*{See also}


\hyperlink{SE3.todelta}{\color{blue} SE3.todelta}, \hyperlink{SE3.increment}{\color{blue} SE3.increment}, \hyperlink{tr2delta}{\color{blue} tr2delta}

\vspace{1.5ex}\hrule

%---------------------- SE3.eul
\hypertarget{SE3.eul}{\section*{SE3.eul}}
\subsection*{Construct SE3 from Euler angles}
\addcontentsline{tom}{section}{SE3.eul}


\texttt{P = SO3.eul(PHI, THETA, PSI, OPTIONS)} is an \textbf{\color{red} SE3} object equivalent to the
specified Euler angles.  These correspond to rotations about the Z, Y, Z
axes respectively. If \texttt{PHI}, \texttt{THETA}, \texttt{PSI} are column vectors ($N \times 1$) then they
are assumed to represent a trajectory then \texttt{P} is a vector ($1 \times N$) of SE3 objects.



\texttt{P = SO3.eul(EUL, OPTIONS)} as above but the Euler angles are taken from
consecutive columns of the passed matrix \texttt{EUL} = [\texttt{PHI} \texttt{THETA} \texttt{PSI}].  If \texttt{EUL}
is a matrix ($N \times 3$) then they are assumed to represent a trajectory then \texttt{P}
is a vector ($1 \times N$) of SE3 objects.


\subsection*{Options}
\begin{longtable}{lp{120mm}}
\textquotesingle deg\textquotesingle  & Angles are specified in degrees (default radians)\\ 
\end{longtable}\vspace{1ex}

\subsection*{Note}
\begin{itemize}
  \item Translation is zero.
  \item The vectors \texttt{PHI}, \texttt{THETA}, \texttt{PSI} must be of the same length.
\end{itemize}

\subsection*{Reference}
\begin{itemize}
  \item Robotics, Vision \& Control: Second Edition, \texttt{P}. Corke, Springer 2016; p36-37.
\end{itemize}

\subsection*{See also}


\hyperlink{SO3.eul}{\color{blue} SO3.eul}, \hyperlink{SE3.rpy}{\color{blue} SE3.rpy}, \hyperlink{eul2tr}{\color{blue} eul2tr}, \hyperlink{rpy2tr}{\color{blue} rpy2tr}, \hyperlink{tr2eul}{\color{blue} tr2eul}

\vspace{1.5ex}\hrule

%---------------------- SE3.exp
\hypertarget{SE3.exp}{\section*{SE3.exp}}
\subsection*{Construct SE3 from Lie algebra}
\addcontentsline{tom}{section}{SE3.exp}


\texttt{SE3.exp(SIGMA)} is the \textbf{\color{red} SE3} rigid-body motion corresponding to the se(3)
Lie algebra element \texttt{SIGMA} ($4 \times 4$).



\texttt{SE3.exp(TW)} as above but the Lie algebra is represented
as a twist vector \texttt{TW} ($6 \times 1$).



\texttt{SE3.exp(SIGMA, THETA)} as above, but the motion is given by \texttt{SIGMA}*\texttt{THETA}
where \texttt{SIGMA} is an se(3) element ($4 \times 4$) whose rotation part has a unit norm.


\subsection*{Notes}
\begin{itemize}
  \item \texttt{TW} is the non-zero elements of X.
\end{itemize}

\subsection*{Reference}
\begin{itemize}
  \item Robotics, Vision \& Control: Second Edition, P. Corke, Springer 2016; p42-43.
\end{itemize}

\subsection*{See also}


\hyperlink{trexp}{\color{blue} trexp}, \hyperlink{skewa}{\color{blue} skewa}, \hyperlink{Twist}{\color{blue} Twist}

\vspace{1.5ex}\hrule

%---------------------- SE3.homtrans
\hypertarget{SE3.homtrans}{\section*{SE3.homtrans}}
\subsection*{Apply transformation to points (compatibility)}
\addcontentsline{tom}{section}{SE3.homtrans}


\texttt{homtrans(P, V)} applies \textbf{\color{red} SE3} pose object \texttt{P} to the points stored columnwise in
\texttt{V} ($3 \times N$) and returns transformed points ($3 \times N$).


\subsection*{Notes}
\begin{itemize}
  \item \texttt{P} is an SE3 object defining the pose of $\{$A$\}$ with respect to $\{$B$\}$.
  \item The points are defined with respect to frame $\{$A$\}$ and are transformed to be     with respect to frame $\{$B$\}$.
  \item Equivalent to \texttt{P}*\texttt{V} using overloaded SE3 operators.
\end{itemize}

\subsection*{See also}


\hyperlink{RTBPose.mtimes}{\color{blue} RTBPose.mtimes}, \hyperlink{homtrans}{\color{blue} homtrans}

\vspace{1.5ex}\hrule

%---------------------- SE3.increment
\hypertarget{SE3.increment}{\section*{SE3.increment}}
\subsection*{Apply incremental motion to an SE3 pose}
\addcontentsline{tom}{section}{SE3.increment}


\texttt{P1 = P.increment(D)} is an \textbf{\color{red} SE3} pose object formed by compounding the
SE3 pose with the incremental motion described by \texttt{D} ($6 \times 1$).



The vector \texttt{D}=(dx, dy, dz, dRx, dRy, dRz) represents infinitessimal translation
and rotation, and is an approximation to the instantaneous spatial velocity
multiplied by time step.


\subsection*{See also}


\hyperlink{SE3.todelta}{\color{blue} SE3.todelta}, \hyperlink{SE3.delta}{\color{blue} SE3.delta}, \hyperlink{delta2tr}{\color{blue} delta2tr}, \hyperlink{tr2delta}{\color{blue} tr2delta}

\vspace{1.5ex}\hrule

%---------------------- SE3.interp
\hypertarget{SE3.interp}{\section*{SE3.interp}}
\subsection*{Interpolate SE3 poses}
\addcontentsline{tom}{section}{SE3.interp}


\texttt{P1.interp(P2, s)} is an \textbf{\color{red} SE3} object representing an interpolation
between poses represented by SE3 objects P1 and \texttt{P2}.  \texttt{s} varies from 0
(P1) to 1 (\texttt{P2}).  If \texttt{s} is a vector ($1 \times N$) then the result will be a vector
of SO3 objects.



\texttt{P1.interp(P2, N)} as above but returns a vector ($1 \times \texttt{N}$) of \textbf{\color{red} SE3} objects
interpolated between P1 and \texttt{P2} in \texttt{N} steps.


\subsection*{Notes}
\begin{itemize}
  \item The rotational interpolation (slerp) can be interpretted
\end{itemize}


as interpolation along a great circle arc on a sphere.

\begin{itemize}
  \item It is an error if any element of S is outside the interval 0 to 1.
\end{itemize}

\subsection*{See also}


\hyperlink{trinterp}{\color{blue} trinterp}, \hyperlink{ctraj}{\color{blue} ctraj}, \hyperlink{UnitQuaternion}{\color{blue} UnitQuaternion}

\vspace{1.5ex}\hrule

%---------------------- SE3.inv
\hypertarget{SE3.inv}{\section*{SE3.inv}}
\subsection*{Inverse of SE3 object}
\addcontentsline{tom}{section}{SE3.inv}


\texttt{Q = inv(P)} is the inverse of the \textbf{\color{red} SE3} object \texttt{P}.


\subsection*{Notes}
\begin{itemize}
  \item This is formed explicitly, no matrix inverse required.
  \item This is a group operator: input and output in the $\mbox{SE}(3)$) group.
  \item \texttt{P}*\texttt{Q} will be the identity group element (zero motion, identity matrix).
\end{itemize}
\vspace{1.5ex}\hrule

%---------------------- SE3.isa
\hypertarget{SE3.isa}{\section*{SE3.isa}}
\subsection*{Test if matrix is $\mbox{SE}(3)$}
\addcontentsline{tom}{section}{SE3.isa}


\texttt{SE3.ISA(T)} is true (1) if the argument \texttt{T} is of dimension $4 \times 4$ or $4 \times 4 \times N$, else
false (0).



\texttt{SE3.ISA(T, 'valid')} as above, but also checks the validity of the rotation
sub-matrix.


\subsection*{Notes}
\begin{itemize}
  \item Is a class method.
  \item The first form is a fast, but incomplete, test for a transform in $\mbox{SE}(3)$.
\end{itemize}

\subsection*{See also}


\hyperlink{SO3.isa}{\color{blue} SO3.isa}, \hyperlink{SE2.isa}{\color{blue} SE2.isa}, \hyperlink{SO2.isa}{\color{blue} SO2.isa}

\vspace{1.5ex}\hrule

%---------------------- SE3.isidentity
\hypertarget{SE3.isidentity}{\section*{SE3.isidentity}}
\subsection*{Test if identity element}
\addcontentsline{tom}{section}{SE3.isidentity}


\texttt{P.isidentity()} is true if the \textbf{\color{red} SE3} object P corresponds to null motion,
that is, its homogeneous transformation matrix is identity.

\vspace{1.5ex}\hrule

%---------------------- SE3.log
\hypertarget{SE3.log}{\section*{SE3.log}}
\subsection*{Lie algebra}
\addcontentsline{tom}{section}{SE3.log}


\texttt{P.log()} is the Lie algebra corresponding to the \textbf{\color{red} SE3} object P. It is
an augmented skew-symmetric matrix ($4 \times 4$).


\subsection*{Reference}
\begin{itemize}
  \item Robotics, Vision \& Control: Second Edition, P. Corke, Springer 2016; p42-43.
\end{itemize}

\subsection*{See also}


\hyperlink{SE3.logs}{\color{blue} SE3.logs}, \hyperlink{SE3.Twist}{\color{blue} SE3.Twist}, \hyperlink{trlog}{\color{blue} trlog}, \hyperlink{logm}{\color{blue} logm}, \hyperlink{skewa}{\color{blue} skewa}, \hyperlink{vexa}{\color{blue} vexa}

\vspace{1.5ex}\hrule

%---------------------- SE3.logs
\hypertarget{SE3.logs}{\section*{SE3.logs}}
\subsection*{Lie algebra in vector form}
\addcontentsline{tom}{section}{SE3.logs}


\texttt{P.logs()} is the Lie algebra expressed as a vector ($1 \times 6$)
corresponding to the SE2 object P.  The vector comprises the
translational elements followed by the unique elements of the
skew-symmetric upper-left $3 \times 3$ submatrix.


\subsection*{Reference}
\begin{itemize}
  \item Robotics, Vision \& Control: Second Edition, P. Corke, Springer 2016; p42-43.
\end{itemize}

\subsection*{See also}


\hyperlink{SE3.log}{\color{blue} SE3.log}, \hyperlink{SE3.Twist}{\color{blue} SE3.Twist}, \hyperlink{trlog}{\color{blue} trlog}, \hyperlink{logm}{\color{blue} logm}

\vspace{1.5ex}\hrule

%---------------------- SE3.new
\hypertarget{SE3.new}{\section*{SE3.new}}
\subsection*{Construct a new object of the same type}
\addcontentsline{tom}{section}{SE3.new}


\texttt{P2 = P.new(X)} creates a new object of the same type as P, by invoking the \textbf{\color{red} SE3} constructor on the matrix
\texttt{X} ($4 \times 4$).



\texttt{P2 = P.new()} as above but defines a null motion.


\subsection*{Notes}
\begin{itemize}
  \item Serves as a dynamic constructor.
  \item This method is polymorphic across all RTBPose derived classes, and     allows easy creation of a new object of the same class as an existing
  \item one without needing to explicitly determine its type.
\end{itemize}

\subsection*{See also}


\hyperlink{SO3.new}{\color{blue} SO3.new}, \hyperlink{SO2.new}{\color{blue} SO2.new}, \hyperlink{SE2.new}{\color{blue} SE2.new}

\vspace{1.5ex}\hrule

%---------------------- SE3.norm
\hypertarget{SE3.norm}{\section*{SE3.norm}}
\subsection*{Normalize rotation submatrix (compatibility)}
\addcontentsline{tom}{section}{SE3.norm}


\texttt{P.norm()} is an \textbf{\color{red} SE3} pose equivalent to P but the rotation
matrix is normalized (guaranteed to be orthogonal).


\subsection*{Notes}
\begin{itemize}
  \item Overrides the classic RTB function trnorm for an SE3 object.
\end{itemize}

\subsection*{See also}


\hyperlink{trnorm}{\color{blue} trnorm}

\vspace{1.5ex}\hrule

%---------------------- SE3.oa
\hypertarget{SE3.oa}{\section*{SE3.oa}}
\subsection*{Construct SE3 from orientation and approach vectors}
\addcontentsline{tom}{section}{SE3.oa}


\texttt{P = SE3.oa(O, A)} is an \textbf{\color{red} SE3} object for the specified
orientation and approach vectors ($3 \times 1$) formed from 3 vectors such that R
= [N \texttt{O} \texttt{A}] and N = \texttt{O} x \texttt{A}, with zero translation.


\subsection*{Notes}
\begin{itemize}
  \item The rotation submatrix is guaranteed to be orthonormal so long as \texttt{O} and \texttt{A}     are not parallel.
  \item The vectors \texttt{O} and \texttt{A} are parallel to the Y- and Z-axes of the coordinate     frame.
\end{itemize}

\subsection*{References}
\begin{itemize}
  \item Robot manipulators: mathematics, programming and control     Richard Paul, MIT Press, 1981.
\end{itemize}

\subsection*{See also}


\hyperlink{rpy2r}{\color{blue} rpy2r}, \hyperlink{eul2r}{\color{blue} eul2r}, \hyperlink{oa2tr}{\color{blue} oa2tr}, \hyperlink{SO3.oa}{\color{blue} SO3.oa}

\vspace{1.5ex}\hrule

%---------------------- SE3.rand
\hypertarget{SE3.rand}{\section*{SE3.rand}}
\subsection*{Construct random SE3}
\addcontentsline{tom}{section}{SE3.rand}


\texttt{SE3.rand()} is an \textbf{\color{red} SE3} object with a uniform random translation and a
uniform random RPY/ZYX orientation.  Random numbers are in the interval -1 to
1.


\subsection*{See also}


\hyperlink{rand}{\color{blue} rand}

\vspace{1.5ex}\hrule

%---------------------- SE3.rpy
\hypertarget{SE3.rpy}{\section*{SE3.rpy}}
\subsection*{Construct SE3 from roll-pitch-yaw angles}
\addcontentsline{tom}{section}{SE3.rpy}


\texttt{P = SE3.rpy(ROLL, PITCH, YAW, OPTIONS)} is an \textbf{\color{red} SE3} object equivalent to the
specified roll, pitch, yaw angles angles with zero translation. These correspond to rotations
about the Z, Y, X axes respectively. If \texttt{ROLL}, \texttt{PITCH}, \texttt{YAW} are column
vectors ($N \times 1$) then they are assumed to represent a trajectory then \texttt{P} is a
vector ($1 \times N$) of SE3 objects.



\texttt{P = SE3.rpy(RPY, OPTIONS)} as above but the roll, pitch, yaw angles angles
angles are taken from consecutive columns of the passed matrix \texttt{RPY} =
[\texttt{ROLL}, \texttt{PITCH}, \texttt{YAW}].  If \texttt{RPY} is a matrix ($N \times 3$) then they are assumed to
represent a trajectory and \texttt{P} is a vector ($1 \times N$) of SE3 objects.


\subsection*{Options}
\begin{longtable}{lp{120mm}}
\textquotesingle deg\textquotesingle  & Compute angles in degrees (radians default)\\ 
\textquotesingle xyz\textquotesingle  & Rotations about X, Y, Z axes (for a robot gripper)\\ 
\textquotesingle yxz\textquotesingle  & Rotations about Y, X, Z axes (for a camera)\\ 
\end{longtable}\vspace{1ex}

\subsection*{Reference}
\begin{itemize}
  \item Robotics, Vision \& Control: Second Edition, \texttt{P}. Corke, Springer 2016; p37-38.
\end{itemize}

\subsection*{See also}


\hyperlink{SO3.rpy}{\color{blue} SO3.rpy}, \hyperlink{SE3.eul}{\color{blue} SE3.eul}, \hyperlink{tr2rpy}{\color{blue} tr2rpy}, \hyperlink{eul2tr}{\color{blue} eul2tr}

\vspace{1.5ex}\hrule

%---------------------- SE3.Rx
\hypertarget{SE3.Rx}{\section*{SE3.Rx}}
\subsection*{Construct SE3 from rotation about X axis}
\addcontentsline{tom}{section}{SE3.Rx}


\texttt{P = SE3.Rx(THETA)} is an \textbf{\color{red} SE3} object representing a rotation of \texttt{THETA}
radians about the x-axis.  If the \texttt{THETA} is a vector ($1 \times N$) then \texttt{P} will be
a vector ($1 \times N$) of corresponding SE3 objects.



\texttt{P = SE3.Rx(THETA, 'deg')} as above but \texttt{THETA} is in degrees.


\subsection*{See also}


\hyperlink{SE3.Ry}{\color{blue} SE3.Ry}, \hyperlink{SE3.Rz}{\color{blue} SE3.Rz}, \hyperlink{rotx}{\color{blue} rotx}

\vspace{1.5ex}\hrule

%---------------------- SE3.Ry
\hypertarget{SE3.Ry}{\section*{SE3.Ry}}
\subsection*{Construct SE3 from rotation about Y axis}
\addcontentsline{tom}{section}{SE3.Ry}


\texttt{P = SE3.Ry(THETA)} is an \textbf{\color{red} SE3} object representing a rotation of \texttt{THETA}
radians about the y-axis.  If the \texttt{THETA} is a vector ($1 \times N$) then \texttt{P} will be
a vector ($1 \times N$) of corresponding SE3 objects.



\texttt{P = SE3.Ry(THETA, 'deg')} as above but \texttt{THETA} is in degrees.


\subsection*{See also}


\hyperlink{SE3.Ry}{\color{blue} SE3.Ry}, \hyperlink{SE3.Rz}{\color{blue} SE3.Rz}, \hyperlink{rotx}{\color{blue} rotx}

\vspace{1.5ex}\hrule

%---------------------- SE3.Rz
\hypertarget{SE3.Rz}{\section*{SE3.Rz}}
\subsection*{Construct SE3 from rotation about Z axis}
\addcontentsline{tom}{section}{SE3.Rz}


\texttt{P = SE3.Rz(THETA)} is an \textbf{\color{red} SE3} object representing a rotation of \texttt{THETA}
radians about the z-axis.  If the \texttt{THETA} is a vector ($1 \times N$) then \texttt{P} will be
a vector ($1 \times N$) of corresponding SE3 objects.



\texttt{P = SE3.Rz(THETA, 'deg')} as above but \texttt{THETA} is in degrees.


\subsection*{See also}


\hyperlink{SE3.Ry}{\color{blue} SE3.Ry}, \hyperlink{SE3.Rz}{\color{blue} SE3.Rz}, \hyperlink{rotx}{\color{blue} rotx}

\vspace{1.5ex}\hrule

%---------------------- SE3.set.t
\hypertarget{SE3.set.t}{\section*{SE3.set.t}}
\subsection*{Get translation vector}
\addcontentsline{tom}{section}{SE3.set.t}


\texttt{T = P.t} is the translational part of \textbf{\color{red} SE3} object as a 3-element column
vector.


\subsection*{Notes}
\begin{itemize}
  \item If applied to  a vector will return a comma-separated list, use     .tv() instead.
\end{itemize}

\subsection*{See also}


\hyperlink{SE3.tv}{\color{blue} SE3.tv}, \hyperlink{transl}{\color{blue} transl}

\vspace{1.5ex}\hrule

%---------------------- SE3.SO3
\hypertarget{SE3.SO3}{\section*{SE3.SO3}}
\subsection*{Convert rotational component to SO3 object}
\addcontentsline{tom}{section}{SE3.SO3}


\texttt{P.SO3} is an \texttt{SO3} object representing the rotational component of the \textbf{\color{red} SE3}
pose \texttt{P}.  If \texttt{P} is a vector ($N \times 1$) then the result is a vector ($N \times 1$).

\vspace{1.5ex}\hrule

%---------------------- SE3.T
\hypertarget{SE3.T}{\section*{SE3.T}}
\subsection*{Get homogeneous transformation matrix}
\addcontentsline{tom}{section}{SE3.T}


\texttt{T = P.T()} is the homogeneous transformation matrix ($3 \times 3$) associated with the
SO2 object P, and has zero translational component.  If P is a vector
($1 \times N$) then \texttt{T} ($3 \times 3 \times N$) is a stack of rotation matrices, with the third
dimension corresponding to the index of P.


\subsection*{See also}


\hyperlink{SO2.T}{\color{blue} SO2.T}

\vspace{1.5ex}\hrule

%---------------------- SE3.toangvec
\hypertarget{SE3.toangvec}{\section*{SE3.toangvec}}
\subsection*{Convert to angle-vector form}
\addcontentsline{tom}{section}{SE3.toangvec}


\texttt{[THETA,V] = P.toangvec(OPTIONS)} is rotation expressed in terms of an
angle \texttt{THETA} ($1 \times 1$) about the axis \texttt{V} ($1 \times 3$) equivalent to the rotational
part of the SE3 object P.



If P is a vector ($1 \times N$) then \texttt{THETA} ($K \times 1$) is a vector of angles for
corresponding elements of the vector and \texttt{V} ($K \times 3$) are the corresponding
axes, one per row.


\subsection*{Options}
\begin{longtable}{lp{120mm}}
\textquotesingle deg\textquotesingle  & Return angle in degrees\\ 
\end{longtable}\vspace{1ex}

\subsection*{Notes}
\begin{itemize}
  \item If no output arguments are specified the result is displayed.
\end{itemize}

\subsection*{See also}


\hyperlink{angvec2r}{\color{blue} angvec2r}, \hyperlink{angvec2tr}{\color{blue} angvec2tr}, \hyperlink{trlog}{\color{blue} trlog}

\vspace{1.5ex}\hrule

%---------------------- SE3.todelta
\hypertarget{SE3.todelta}{\section*{SE3.todelta}}
\subsection*{Convert SE3 object to differential motion vector}
\addcontentsline{tom}{section}{SE3.todelta}


\texttt{D = P0.todelta(P1)} is the differential motion ($6 \times 1$) corresponding to
infinitessimal motion (in the P0 frame) from SE3 pose P0 to \texttt{P1}.



The vector \texttt{D}=(dx, dy, dz, dRx, dRy, dRz) represents infinitessimal translation
and rotation, and is an approximation to the instantaneous spatial velocity
multiplied by time step.



\texttt{D = P.todelta()} as above but the motion is from the world frame to the \textbf{\color{red} SE3}
pose P.


\subsection*{Notes}
\begin{itemize}
  \item \texttt{D} is only an approximation to the motion, and assumes     that P0$\approx$\texttt{P1} or P$\approx$eye(4,4).
  \item can be considered as an approximation to the effect of spatial velocity over a     a time interval, average spatial velocity multiplied by time.
\end{itemize}

\subsection*{See also}


\hyperlink{SE3.increment}{\color{blue} SE3.increment}, \hyperlink{tr2delta}{\color{blue} tr2delta}, \hyperlink{delta2tr}{\color{blue} delta2tr}

\vspace{1.5ex}\hrule

%---------------------- SE3.toeul
\hypertarget{SE3.toeul}{\section*{SE3.toeul}}
\subsection*{Convert  to Euler angles}
\addcontentsline{tom}{section}{SE3.toeul}


\texttt{EUL = P.toeul(OPTIONS)} are the ZYZ Euler angles ($1 \times 3$) corresponding to
the rotational part of the SE3 object P. The 3 angles \texttt{EUL}=[PHI,THETA,PSI]
correspond to sequential rotations about the Z, Y and Z axes
respectively.



If P is a vector ($1 \times N$) then each row of \texttt{EUL} corresponds to an element of
the vector.


\subsection*{Options}
\begin{longtable}{lp{120mm}}
\textquotesingle deg\textquotesingle  & Compute angles in degrees (radians default)\\ 
\textquotesingle flip\textquotesingle  & Choose first Euler angle to be in quadrant 2 or 3.\\ 
\end{longtable}\vspace{1ex}

\subsection*{Notes}
\begin{itemize}
  \item There is a singularity for the case where THETA=0 in which case PHI is arbitrarily     set to zero and PSI is the sum (PHI+PSI).
\end{itemize}

\subsection*{See also}


\hyperlink{SO3.toeul}{\color{blue} SO3.toeul}, \hyperlink{SE3.torpy}{\color{blue} SE3.torpy}, \hyperlink{eul2tr}{\color{blue} eul2tr}, \hyperlink{tr2rpy}{\color{blue} tr2rpy}

\vspace{1.5ex}\hrule

%---------------------- SE3.torpy
\hypertarget{SE3.torpy}{\section*{SE3.torpy}}
\subsection*{Convert to roll-pitch-yaw angles}
\addcontentsline{tom}{section}{SE3.torpy}


\texttt{RPY = P.torpy(options)} are the roll-pitch-yaw angles ($1 \times 3$) corresponding
to the rotational part of the SE3 object P. The 3 angles \texttt{RPY}=[R,P,Y]
correspond to sequential rotations about the Z, Y and X axes
respectively.



If P is a vector ($1 \times N$) then each row of \texttt{RPY} corresponds to an element of
the vector.


\subsection*{Options}
\begin{longtable}{lp{120mm}}
\textquotesingle deg\textquotesingle  & Compute angles in degrees (radians default)\\ 
\textquotesingle xyz\textquotesingle  & Return solution for sequential rotations about X, Y, Z axes\\ 
\textquotesingle yxz\textquotesingle  & Return solution for sequential rotations about Y, X, Z axes\\ 
\end{longtable}\vspace{1ex}

\subsection*{Notes}
\begin{itemize}
  \item There is a singularity for the case where P=$\pi/2$ in which case R is arbitrarily     set to zero and Y is the sum (R+Y).
\end{itemize}

\subsection*{See also}


\hyperlink{SE3.torpy}{\color{blue} SE3.torpy}, \hyperlink{SE3.toeul}{\color{blue} SE3.toeul}, \hyperlink{rpy2tr}{\color{blue} rpy2tr}, \hyperlink{tr2eul}{\color{blue} tr2eul}

\vspace{1.5ex}\hrule

%---------------------- SE3.transl
\hypertarget{SE3.transl}{\section*{SE3.transl}}
\subsection*{Get translation vector}
\addcontentsline{tom}{section}{SE3.transl}


\texttt{T = P.transl()} is the translational part of \textbf{\color{red} SE3} object as a 3-element row
vector.  If P is a vector ($1 \times N$) then



the rows of \texttt{T} ($M \times 3$) are the translational component of the



corresponding pose in the sequence.



\texttt{[X,Y,Z] = P.transl()} as above but the translational part is returned as
three components.  If P is a vector ($1 \times N$) then \texttt{X},\texttt{Y},\texttt{Z} ($1 \times N$) are the
translational components of the corresponding pose in the sequence.


\subsection*{Notes}
\begin{itemize}
  \item The .t method only works for a single pose object, on  a vector it     returns a comma-separated list.
\end{itemize}

\subsection*{See also}


\hyperlink{SE3.t}{\color{blue} SE3.t}, \hyperlink{transl}{\color{blue} transl}

\vspace{1.5ex}\hrule

%---------------------- SE3.trnorm
\hypertarget{SE3.trnorm}{\section*{SE3.trnorm}}
\subsection*{Normalize rotation submatrix (compatibility)}
\addcontentsline{tom}{section}{SE3.trnorm}


\texttt{T = trnorm(P)} is an \textbf{\color{red} SE3} object equivalent to \texttt{P} but
normalized (rotation matrix guaranteed to be orthogonal).


\subsection*{Notes}
\begin{itemize}
  \item Overrides the classic RTB function trnorm for an SE3 object.
\end{itemize}

\subsection*{See also}


\hyperlink{trnorm}{\color{blue} trnorm}

\vspace{1.5ex}\hrule

%---------------------- SE3.tv
\hypertarget{SE3.tv}{\section*{SE3.tv}}
\subsection*{Return translation for a vector of SE3 objects}
\addcontentsline{tom}{section}{SE3.tv}


\texttt{P.tv} is a column vector ($3 \times 1$) representing the translational part of the
SE3 pose object \texttt{P}.  If \texttt{P} is a vector of SE3 objects ($N \times 1$) then the result
is a matrix ($3 \times N$) with columns corresponding to the elements of \texttt{P}.


\subsection*{See also}


\hyperlink{SE3.t}{\color{blue} SE3.t}

\vspace{1.5ex}\hrule

%---------------------- SE3.Twist
\hypertarget{SE3.Twist}{\section*{SE3.Twist}}
\subsection*{Convert to Twist object}
\addcontentsline{tom}{section}{SE3.Twist}


\texttt{TW = P.Twist()} is the equivalent Twist object.  The elements of the twist are the unique
elements of the Lie algebra of the SE3 object P.


\subsection*{See also}


\hyperlink{SE3.logs}{\color{blue} SE3.logs}, \hyperlink{Twist}{\color{blue} Twist}

\vspace{1.5ex}\hrule

%---------------------- SE3.velxform
\hypertarget{SE3.velxform}{\section*{SE3.velxform}}
\subsection*{Velocity transformation}
\addcontentsline{tom}{section}{SE3.velxform}


Transform velocity between frames.  A is the world frame, B is the body
frame and C is another frame attached to the body.  PAB is the pose of
the body frame with respect to the world frame, PCB is the pose of the
body frame with respect to frame C.



\texttt{J = PAB.velxform()} is a $6 \times 6$ Jacobian matrix that maps velocity from frame
B to frame A.



\texttt{J = PCB.velxform('samebody')} is a $6 \times 6$ Jacobian matrix that maps velocity
from frame C to frame B.  This is also the adjoint of PCB.

\vspace{1.5ex}\rule{\textwidth}{1mm}

%---------------------- skew
\hypertarget{skew}{\section*{skew}}
\subsection*{Create skew-symmetric matrix}
\addcontentsline{toc}{section}{skew}


\texttt{S = SKEW(V)} is a skew-symmetric matrix formed from \texttt{V}.



If \texttt{V} ($1 \times 1$) then \texttt{S} =

\begin{Code}
     | 0  -v |
     | v   0 |

\end{Code}


and if \texttt{V} ($1 \times 3$) then \texttt{S} =

\begin{Code}
     |  0  -vz   vy |
     | vz    0  -vx |
     |-vy   vx    0 |

\end{Code}

\subsection*{Notes}
\begin{itemize}
  \item This is the inverse of the function VEX().
  \item These are the generator matrices for the Lie algebras so(2) and so(3).
\end{itemize}

\subsection*{References}
\begin{itemize}
  \item Robotics, Vision \& Control: Second Edition, Chap 2,    P. Corke, Springer 2016.
\end{itemize}

\subsection*{See also}


\hyperlink{skewa}{\color{blue} skewa}, \hyperlink{vex}{\color{blue} vex}

\vspace{1.5ex}\rule{\textwidth}{1mm}

%---------------------- skewa
\hypertarget{skewa}{\section*{skewa}}
\subsection*{Create augmented skew-symmetric matrix}
\addcontentsline{toc}{section}{skewa}


\texttt{S = SKEWA(V)} is an augmented skew-symmetric matrix formed from \texttt{V}.



If \texttt{V} ($1 \times 3$) then \texttt{S} =

\begin{Code}
     |  0  -v3  v1 |
     | v3    0  v2 |
     |  0    0   0 |

\end{Code}


and if \texttt{V} ($1 \times 6$) then \texttt{S} =

\begin{Code}
     |  0  -v6   v5  v1 |
     | v6    0  -v4  v2 |
     |-v5   v4    0  v3 |
     |  0    0    0   0 |

\end{Code}

\subsection*{Notes}
\begin{itemize}
  \item This is the inverse of the function VEXA().
  \item These are the generator matrices for the Lie algebras se(2) and se(3).
  \item Map twist vectors in 2D and 3D space to se(2) and se(3).
\end{itemize}

\subsection*{References}
\begin{itemize}
  \item Robotics, Vision \& Control: Second Edition, Chap 2,    P. Corke, Springer 2016.
\end{itemize}

\subsection*{See also}


\hyperlink{skew}{\color{blue} skew}, \hyperlink{vex}{\color{blue} vex}, \hyperlink{Twist}{\color{blue} Twist}

\vspace{1.5ex}\rule{\textwidth}{1mm}

%---------------------- SO2
\hypertarget{SO2}{\section*{SO2}}
\subsection*{Representation of 2D rotation}
\addcontentsline{toc}{section}{SO2}


This subclasss of RTBPose is an object that represents rotation in 2D.
Internally this is a $2 \times 2$ orthonormal matrix belonging to the group $\mbox{SO}(2)$.


\subsection*{Constructor methods}
\begin{longtable}{lp{120mm}}
SO2 & general constructor\\ 
SO2.exp & exponentiate an so(2) matrix\\ 
SO2.rand & random orientation\\ 
new & new SO2 object from instance\\ 
\end{longtable}\vspace{1ex}

\subsection*{Display and print methods}
\begin{longtable}{lp{120mm}}
animate & \textasciicircum graphically animate coordinate frame for pose\\ 
display & \textasciicircum print the pose in human readable matrix form\\ 
plot & \textasciicircum graphically display coordinate frame for pose\\ 
print & \textasciicircum print the pose in single line format\\ 
\end{longtable}\vspace{1ex}

\subsection*{Group operations}
\begin{longtable}{lp{120mm}}
\textasteriskcentered  & \textasciicircum mtimes: multiplication (group operator, transform point)\\ 
/ & \textasciicircum mrdivide: multiply by inverse\\ 
\textasciicircum  & \textasciicircum mpower: exponentiate (integer only)\\ 
inv & \textasciicircum inverse rotation\\ 
prod & \textasciicircum product of elements\\ 
\end{longtable}\vspace{1ex}

\subsection*{Methods}
\begin{longtable}{lp{120mm}}
det & determinant of matrix value (is 1)\\ 
eig & \textasciicircum eigenvalues of matrix value\\ 
interp & interpolate between rotations\\ 
log & logarithm of rotation matrix\\ 
simplify & \textasciicircum apply symbolic simplication to all elements\\ 
subs & \textasciicircum symbolic substitution\\ 
vpa & \textasciicircum symbolic variable precision arithmetic\\ 
\end{longtable}\vspace{1ex}

\subsection*{Information and test methods}
\begin{longtable}{lp{120mm}}
dim & \textasciicircum returns 2\\ 
isSE & \textasciicircum returns false\\ 
issym & \textasciicircum test if rotation matrix has symbolic elements\\ 
SO2.isa & test if matrix is $\mbox{SO}(2)$\\ 
\end{longtable}\vspace{1ex}

\subsection*{Conversion methods}
\begin{longtable}{lp{120mm}}
char & \textasciicircum convert to human readable matrix as a string\\ 
SO2.convert & convert SO2 object or $\mbox{SO}(2)$ matrix to SO2 object\\ 
double & \textasciicircum convert to rotation matrix\\ 
theta & rotation angle\\ 
R & convert to rotation matrix\\ 
SE2 & convert to SE2 object with zero translation\\ 
T & convert to homogeneous transformation matrix with zero translation\\ 
\end{longtable}\vspace{1ex}

\subsection*{Compatibility methods}
\begin{longtable}{lp{120mm}}
ishomog2 & \textasciicircum returns false\\ 
isrot2 & \textasciicircum returns true\\ 
tranimate2 & \textasciicircum animate coordinate frame\\ 
trplot2 & \textasciicircum plot coordinate frame\\ 
trprint2 & \textasciicircum print single line representation\\ 
\end{longtable}\vspace{1ex}

\subsection*{Operators}
\begin{longtable}{lp{120mm}}
+ & \textasciicircum plus: elementwise addition, result is a matrix\\ 
- & \textasciicircum minus: elementwise subtraction, result is a matrix\\ 
== & \textasciicircum eq: test equality\\ 
$\sim=$ & \textasciicircum ne: test inequality\\ 
\end{longtable}\vspace{1ex}


\textasciicircum  inherited from RTBPose class.


\subsection*{See also}


\hyperlink{SE2}{\color{blue} SE2}, \hyperlink{SO3}{\color{blue} SO3}, \hyperlink{SE3}{\color{blue} SE3}, \hyperlink{RTBPose}{\color{blue} RTBPose}

\vspace{1.5ex}\hrule

%---------------------- SO2.SO2
\hypertarget{SO2.SO2}{\section*{SO2.SO2}}
\subsection*{Construct SO2 object}
\addcontentsline{tom}{section}{SO2.SO2}


\texttt{P = SO2()} is the identity element, a null rotation.



\texttt{P = SO2(THETA)} is an \textbf{\color{red} SO2} object representing rotation of \texttt{THETA} radians.
If \texttt{THETA} is a vector (N) then \texttt{P} is a vector of objects, corresponding to
the elements of \texttt{THETA}.



\texttt{P = SO2(THETA, 'deg')} as above but with \texttt{THETA} degrees.



\texttt{P = SO2(R)} is an \textbf{\color{red} SO2} object formed from the rotation
matrix \texttt{R} ($2 \times 2$).



\texttt{P = SO2(T)} is an \textbf{\color{red} SO2} object formed from the rotational part
of the homogeneous transformation matrix \texttt{T} ($3 \times 3$).



\texttt{P = SO2(Q)} is an \textbf{\color{red} SO2} object that is a copy of the \textbf{\color{red} SO2} object \texttt{Q}.


\subsection*{Notes}
\begin{itemize}
  \item For matrix arguments \texttt{R} or \texttt{T} the rotation submatrix is checked for validity.
\end{itemize}

\subsection*{See also}


\hyperlink{rot2}{\color{blue} rot2}, \hyperlink{SE2}{\color{blue} SE2}, \hyperlink{SO3}{\color{blue} SO3}

\vspace{1.5ex}\hrule

%---------------------- SO2.angle
\hypertarget{SO2.angle}{\section*{SO2.angle}}
\subsection*{Rotation angle}
\addcontentsline{tom}{section}{SO2.angle}


\texttt{P.angle()} is the rotation angle, in radians $[-\pi, \pi)$, associated with the
SO2 object P.


\subsection*{See also}


\hyperlink{atan2}{\color{blue} atan2}

\vspace{1.5ex}\hrule

%---------------------- SO2.char
\hypertarget{SO2.char}{\section*{SO2.char}}
\subsection*{Convert to string}
\addcontentsline{tom}{section}{SO2.char}


\texttt{P.char()} is a string containing rotation matrix elements.


\subsection*{See also}


\hyperlink{RTB.display}{\color{blue} RTB.display}

\vspace{1.5ex}\hrule

%---------------------- SO2.convert
\hypertarget{SO2.convert}{\section*{SO2.convert}}
\subsection*{Convert value to SO2}
\addcontentsline{tom}{section}{SO2.convert}


\texttt{Q = SO2.convert(X)} is an \textbf{\color{red} SO2} object equivalent to \texttt{X} where \texttt{X} is either
an SO2 object, an $\mbox{SO}(2)$ rotation matrix ($2 \times 2$), an SE2 object, or an
$\mbox{SE}(2)$ homogeneous transformation matrix ($3 \times 3$).

\vspace{1.5ex}\hrule

%---------------------- SO2.det
\hypertarget{SO2.det}{\section*{SO2.det}}
\subsection*{Determinant}
\addcontentsline{tom}{section}{SO2.det}


\texttt{det(P)} is the determinant of the \textbf{\color{red} SO2} object \texttt{P} and should always be +1.

\vspace{1.5ex}\hrule

%---------------------- SO2.eig
\hypertarget{SO2.eig}{\section*{SO2.eig}}
\subsection*{Eigenvalues and eigenvectors}
\addcontentsline{tom}{section}{SO2.eig}


\texttt{E = eig(P)} is a column vector containing the eigenvalues of the
underlying rotation matrix.



\texttt{[V,D] = eig(P)} produces a diagonal matrix \texttt{D} of eigenvalues and
a full matrix \texttt{V} whose columns are the corresponding eigenvectors
such that A*\texttt{V} = \texttt{V}*\texttt{D}.


\subsection*{See also}


\hyperlink{eig}{\color{blue} eig}

\vspace{1.5ex}\hrule

%---------------------- SO2.exp
\hypertarget{SO2.exp}{\section*{SO2.exp}}
\subsection*{Construct SO2 from Lie algebra}
\addcontentsline{tom}{section}{SO2.exp}


\texttt{R = SO3.exp(X)} is the \textbf{\color{red} SO2} rotation corresponding to the so(2)
Lie algebra element SIGMA ($2 \times 2$).



\texttt{R = SO3.exp(TW)} as above but the Lie algebra is represented
as a twist vector \texttt{TW} ($1 \times 1$).


\subsection*{Notes}
\begin{itemize}
  \item \texttt{TW} is the non-zero elements of \texttt{X}.
\end{itemize}

\subsection*{Reference}
\begin{itemize}
  \item Robotics, Vision \& Control: Second Edition, P. Corke, Springer 2016; p25-31.
\end{itemize}

\subsection*{See also}


\hyperlink{trexp2}{\color{blue} trexp2}, \hyperlink{skewa}{\color{blue} skewa}

\vspace{1.5ex}\hrule

%---------------------- SO2.interp
\hypertarget{SO2.interp}{\section*{SO2.interp}}
\subsection*{Interpolate between rotations}
\addcontentsline{tom}{section}{SO2.interp}


\texttt{P1.interp(P2, s)} is an \textbf{\color{red} SO2} object representing interpolation
between rotations represented by SO2 objects P1 and \texttt{P2}.  \texttt{s} varies from 0
(P1) to 1 (\texttt{P2}). If \texttt{s} is a vector ($1 \times N$) then the result will be a vector
of SO2 objects.



\texttt{P1.interp(P2,N)} as above but returns a vector ($1 \times \texttt{N}$) of \textbf{\color{red} SO2} objects
interpolated between P1 and \texttt{P2} in \texttt{N} steps.


\subsection*{Notes}
\begin{itemize}
  \item It is an error if any element of S is outside the interval 0 to 1.
\end{itemize}

\subsection*{See also}


\hyperlink{SO2.angle}{\color{blue} SO2.angle}

\vspace{1.5ex}\hrule

%---------------------- SO2.inv
\hypertarget{SO2.inv}{\section*{SO2.inv}}
\subsection*{Inverse}
\addcontentsline{tom}{section}{SO2.inv}


\texttt{Q = inv(P)} is an \textbf{\color{red} SO2} object representing the inverse of the \textbf{\color{red} SO2} object \texttt{P}.


\subsection*{Notes}
\begin{itemize}
  \item This is a group operator: input and output in the $\mbox{SO}(2)$ group.
  \item This is simply the transpose of the underlying matrix.
  \item \texttt{P}*\texttt{Q} will be the identity group element (zero rotation, identity matrix).
\end{itemize}
\vspace{1.5ex}\hrule

%---------------------- SO2.isa
\hypertarget{SO2.isa}{\section*{SO2.isa}}
\subsection*{Test if matrix belongs to $\mbox{SO}(2)$}
\addcontentsline{tom}{section}{SO2.isa}


\texttt{SO2.ISA(T)} is true (1) if the argument \texttt{T} is of dimension $2 \times 2$ or $2 \times 2 \times N$, else
false (0).



\texttt{SO2.ISA(T, true)} as above, but also checks the validity of the rotation
matrix, ie. that its determinant is +1.


\subsection*{Notes}
\begin{itemize}
  \item The first form is a fast, but incomplete, test for a transform in $\mbox{SO}(2)$.
\end{itemize}

\subsection*{See also}


\hyperlink{SO3.ISA}{\color{blue} SO3.ISA}, \hyperlink{SE2.ISA}{\color{blue} SE2.ISA}, \hyperlink{SE2.ISA}{\color{blue} SE2.ISA}, \hyperlink{ishomog2}{\color{blue} ishomog2}

\vspace{1.5ex}\hrule

%---------------------- SO2.log
\hypertarget{SO2.log}{\section*{SO2.log}}
\subsection*{Logarithm}
\addcontentsline{tom}{section}{SO2.log}


\texttt{so2 = P.log()} is the Lie algebra corresponding to the \textbf{\color{red} SO2} object P. It is
a skew-symmetric matrix ($2 \times 2$).


\subsection*{See also}


\hyperlink{SO2.exp}{\color{blue} SO2.exp}, \hyperlink{Twist}{\color{blue} Twist}, \hyperlink{logm}{\color{blue} logm}, \hyperlink{vex}{\color{blue} vex}, \hyperlink{skew}{\color{blue} skew}

\vspace{1.5ex}\hrule

%---------------------- SO2.new
\hypertarget{SO2.new}{\section*{SO2.new}}
\subsection*{Construct a new object of the same type}
\addcontentsline{tom}{section}{SO2.new}


Create a new object of the same type as the RTBPose derived instance object.



\texttt{P.new(X)} creates a new object of the same type as P, by invoking the \textbf{\color{red} SO2} constructor on the matrix
\texttt{X} ($2 \times 2$).



\texttt{P.new()} as above but assumes an identity matrix.


\subsection*{Notes}
\begin{itemize}
  \item Serves as a dynamic constructor.
  \item This method is polymorphic across all RTBPose derived classes, and
\end{itemize}


allows easy creation of a new object of the same class as an existing
one without needing to explicitly determine its type.


\subsection*{See also}


\hyperlink{SE3.new}{\color{blue} SE3.new}, \hyperlink{SO3.new}{\color{blue} SO3.new}, \hyperlink{SE2.new}{\color{blue} SE2.new}

\vspace{1.5ex}\hrule

%---------------------- SO2.R
\hypertarget{SO2.R}{\section*{SO2.R}}
\subsection*{Get rotation matrix}
\addcontentsline{tom}{section}{SO2.R}


\texttt{R = P.R()} is the rotation matrix ($2 \times 2$) associated with the \textbf{\color{red} SO2} object P.
If P is a vector ($1 \times N$) then \texttt{R} ($2 \times 2 \times N$) is a stack of rotation matrices, with
the third dimension corresponding to the index of P.


\subsection*{See also}


\hyperlink{SO2.T}{\color{blue} SO2.T}

\vspace{1.5ex}\hrule

%---------------------- SO2.rand
\hypertarget{SO2.rand}{\section*{SO2.rand}}
\subsection*{Construct a random $\mbox{SO}(2)$ object}
\addcontentsline{tom}{section}{SO2.rand}


\texttt{SO2.rand()} is an \textbf{\color{red} SO2} object where the angle is drawn from a uniform
random orientation. Random numbers are in the interval 0 to $2\pi$.


\subsection*{See also}


\hyperlink{rand}{\color{blue} rand}

\vspace{1.5ex}\hrule

%---------------------- SO2.SE2
\hypertarget{SO2.SE2}{\section*{SO2.SE2}}
\subsection*{Convert to SE2 object}
\addcontentsline{tom}{section}{SO2.SE2}


\texttt{P.SE2()} is an SE2 object formed from the rotational component of the
SO2 object P and with a zero translational component.


\subsection*{See also}


\hyperlink{SE2}{\color{blue} SE2}

\vspace{1.5ex}\hrule

%---------------------- SO2.T
\hypertarget{SO2.T}{\section*{SO2.T}}
\subsection*{Get homogeneous transformation matrix}
\addcontentsline{tom}{section}{SO2.T}


\texttt{T = P.T()} is the homogeneous transformation matrix ($3 \times 3$) associated with the
SO2 object P, and has zero translational component.  If P is a vector
($1 \times N$) then \texttt{T} ($3 \times 3 \times N$) is a stack of rotation matrices, with the third
dimension corresponding to the index of P.


\subsection*{See also}


\hyperlink{SO2.T}{\color{blue} SO2.T}

\vspace{1.5ex}\hrule

%---------------------- SO2.theta
\hypertarget{SO2.theta}{\section*{SO2.theta}}
\subsection*{Rotation angle}
\addcontentsline{tom}{section}{SO2.theta}


\texttt{P.theta()} is the rotation angle, in radians, associated with the
SO2 object P.


\subsection*{Notes}
\begin{itemize}
  \item Deprecated, use angle() instead.
\end{itemize}

\subsection*{See also}


\hyperlink{SO2.angle}{\color{blue} SO2.angle}

\vspace{1.5ex}\rule{\textwidth}{1mm}

%---------------------- SO3
\hypertarget{SO3}{\section*{SO3}}
\subsection*{Representation of 3D rotation}
\addcontentsline{toc}{section}{SO3}


This subclasss of RTBPose is an object that represents rotation in 3D.
Internally this is a $3 \times 3$ orthonormal matrix belonging to the group $\mbox{SO}(3)$.


\subsection*{Constructor methods}
\begin{longtable}{lp{120mm}}
SO3 & general constructor\\ 
SO3.exp & exponentiate an so(3) matrix\\ 
SO3.angvec & rotation about vector\\ 
SO3.eul & rotation defined by Euler angles\\ 
SO3.oa & rotation defined by o- and a-vectors\\ 
SO3.Rx & rotation about x-axis\\ 
SO3.Ry & rotation about y-axis\\ 
SO3.Rz & rotation about z-axis\\ 
SO3.rand & random orientation\\ 
SO3.rpy & rotation defined by roll-pitch-yaw angles\\ 
new & new SO3 object from instance\\ 
\end{longtable}\vspace{1ex}

\subsection*{Display and print methods}
\begin{longtable}{lp{120mm}}
plot & \textasciicircum graphically display coordinate frame for pose\\ 
animate & \textasciicircum graphically animate coordinate frame for pose\\ 
print & \textasciicircum print the pose in single line format\\ 
display & \textasciicircum print the pose in human readable matrix form\\ 
\end{longtable}\vspace{1ex}

\subsection*{Group operations}
\begin{longtable}{lp{120mm}}
\textasteriskcentered  & \textasciicircum mtimes: multiplication (group operator, transform point)\\ 
\end{longtable}\vspace{1ex}
\begin{longtable}{lp{120mm}}
.\textasteriskcentered  & times: multiplication (group operator) followed by normalization\\ 
/ & \textasciicircum mrdivide: multiply by inverse\\ 
./ & rdivide: multiply by inverse followed by normalization\\ 
\textasciicircum  & \textasciicircum mpower: exponentiate (integer only)\\ 
.\textasciicircum  & power: exponentiate followed by normalization\\ 
inv & \textasciicircum inverse rotation\\ 
prod & \textasciicircum product of elements\\ 
\end{longtable}\vspace{1ex}

\subsection*{Methods}
\begin{longtable}{lp{120mm}}
det & determinant of matrix value (is 1)\\ 
eig & eigenvalues of matrix value\\ 
interp & interpolate between rotations\\ 
log & logarithm of matrix value\\ 
norm & normalize matrix\\ 
simplify & \textasciicircum apply symbolic simplication to all elements\\ 
subs & \textasciicircum symbolic substitution\\ 
vpa & \textasciicircum symbolic variable precision arithmetic\\ 
\end{longtable}\vspace{1ex}

\subsection*{Information and test methods}
\begin{longtable}{lp{120mm}}
dim & \textasciicircum returns 3\\ 
isSE & \textasciicircum returns false\\ 
issym & \textasciicircum test if rotation matrix has symbolic elements\\ 
SO3.isa & test if matrix is $\mbox{SO}(3)$\\ 
\end{longtable}\vspace{1ex}

\subsection*{Conversion methods}
\begin{longtable}{lp{120mm}}
char & \textasciicircum convert to human readable matrix as a string\\ 
SO3.convert & convert SO3 object or $\mbox{SO}(3)$ matrix to SO3 object\\ 
double & convert to rotation matrix\\ 
R & convert to rotation matrix\\ 
SE3 & convert to SE3 object with zero translation\\ 
T & convert to homogeneous transformation matrix with zero translation\\ 
toangvec & convert to rotation about vector form\\ 
toeul & convert to Euler angles\\ 
torpy & convert to roll-pitch-yaw angles\\ 
UnitQuaternion & convert to UnitQuaternion object\\ 
\end{longtable}\vspace{1ex}

\subsection*{Compatibility methods}
\begin{longtable}{lp{120mm}}
isrot & \textasciicircum returns true\\ 
ishomog & \textasciicircum returns false\\ 
trprint & \textasciicircum print single line representation\\ 
trplot & \textasciicircum plot coordinate frame\\ 
tranimate & \textasciicircum animate coordinate frame\\ 
tr2eul & convert to Euler angles\\ 
tr2rpy & convert to roll-pitch-yaw angles\\ 
trnorm & normalize rotation matrix\\ 
\end{longtable}\vspace{1ex}

\subsection*{Operators}
\begin{longtable}{lp{120mm}}
+ & \textasciicircum plus: elementwise addition, result is a matrix\\ 
- & \textasciicircum minus: elementwise subtraction, result is a matrix\\ 
== & \textasciicircum eq: test equality\\ 
$\sim=$ & \textasciicircum ne: test inequality\\ 
\end{longtable}\vspace{1ex}


\textasciicircum  inherited from RTBPose class.


\subsection*{Properties}
\begin{longtable}{lp{120mm}}
n & normal (x) vector\\ 
o & orientation (y) vector\\ 
a & approach (z) vector\\ 
\end{longtable}\vspace{1ex}

\subsection*{See also}


\hyperlink{SE2}{\color{blue} SE2}, \hyperlink{SO2}{\color{blue} SO2}, \hyperlink{SE3}{\color{blue} SE3}, \hyperlink{RTBPose}{\color{blue} RTBPose}

\vspace{1.5ex}\hrule

%---------------------- SO3.SO3
\hypertarget{SO3.SO3}{\section*{SO3.SO3}}
\subsection*{Construct SO3 object}
\addcontentsline{tom}{section}{SO3.SO3}


\texttt{P = SO3()} is the identity element, a null rotation.



\texttt{P = SO3(R)} is an \textbf{\color{red} SO3} object formed from the rotation
matrix \texttt{R} ($3 \times 3$).



\texttt{P = SO3(T)} is an \textbf{\color{red} SO3} object formed from the rotational part
of the homogeneous transformation matrix \texttt{T} ($4 \times 4$).



\texttt{P = SO3(Q)} is an \textbf{\color{red} SO3} object that is a copy of the \textbf{\color{red} SO3} object \texttt{Q}.


\subsection*{Notes}
\begin{itemize}
  \item For matrix arguments \texttt{R} or \texttt{T} the rotation submatrix is checked for validity.
\end{itemize}

\subsection*{See also}


\hyperlink{SE3}{\color{blue} SE3}, \hyperlink{SO2}{\color{blue} SO2}

\vspace{1.5ex}\hrule

%---------------------- SO3.angvec
\hypertarget{SO3.angvec}{\section*{SO3.angvec}}
\subsection*{Construct SO3 from angle and axis vector}
\addcontentsline{tom}{section}{SO3.angvec}


\texttt{R = SO3.angvec(THETA, V)} is an \textbf{\color{red} SO3} object representitng a rotation
of \texttt{THETA} about the vector \texttt{V}.


\subsection*{Notes}
\begin{itemize}
  \item If \texttt{THETA} == 0 then return null group element (zero rotation, identity matrix).
  \item If \texttt{THETA} $\ne$ 0 then \texttt{V} must have a finite length, does not have to be unit length.
\end{itemize}

\subsection*{Reference}
\begin{itemize}
  \item Robotics, Vision \& Control: Second Edition, P. Corke, Springer 2016; p41-42.
\end{itemize}

\subsection*{See also}


\hyperlink{SE3.angvec}{\color{blue} SE3.angvec}, \hyperlink{eul2r}{\color{blue} eul2r}, \hyperlink{rpy2r}{\color{blue} rpy2r}, \hyperlink{tr2angvec}{\color{blue} tr2angvec}

\vspace{1.5ex}\hrule

%---------------------- SO3.convert
\hypertarget{SO3.convert}{\section*{SO3.convert}}
\subsection*{Convert value to SO3}
\addcontentsline{tom}{section}{SO3.convert}


\texttt{Q = SO3.convert(X)} is an \textbf{\color{red} SO3} object equivalent to \texttt{X} where \texttt{X} is either
an SO3 object, an $\mbox{SO}(3)$ rotation matrix ($3 \times 3$), an SE3 object, or an
$\mbox{SE}(3)$ homogeneous transformation matrix ($4 \times 4$).

\vspace{1.5ex}\hrule

%---------------------- SO3.det
\hypertarget{SO3.det}{\section*{SO3.det}}
\subsection*{Determinant}
\addcontentsline{tom}{section}{SO3.det}


\texttt{det(P)} is the determinant of the \textbf{\color{red} SO3} object \texttt{P} and should always be +1.

\vspace{1.5ex}\hrule

%---------------------- SO3.eig
\hypertarget{SO3.eig}{\section*{SO3.eig}}
\subsection*{Eigenvalues and eigenvectors}
\addcontentsline{tom}{section}{SO3.eig}


\texttt{E = eig(P)} is a column vector containing the eigenvalues of the
underlying rotation matrix.



\texttt{[V,D] = eig(P)} produces a diagonal matrix \texttt{D} of eigenvalues and
a full matrix \texttt{V} whose columns are the corresponding eigenvectors
such that A*\texttt{V} = \texttt{V}*\texttt{D}.


\subsection*{See also}


\hyperlink{eig}{\color{blue} eig}

\vspace{1.5ex}\hrule

%---------------------- SO3.eul
\hypertarget{SO3.eul}{\section*{SO3.eul}}
\subsection*{Construct SO3 from Euler angles}
\addcontentsline{tom}{section}{SO3.eul}


\texttt{P = SO3.eul(PHI, THETA, PSI, OPTIONS)} is an \textbf{\color{red} SO3} object equivalent to the
specified Euler angles.  These correspond to rotations about the Z, Y, Z
axes respectively. If \texttt{PHI}, \texttt{THETA}, \texttt{PSI} are column vectors ($N \times 1$) then they
are assumed to represent a trajectory then \texttt{P} is a vector ($1 \times N$) of SO3 objects.



\texttt{P = SO3.eul(EUL, OPTIONS)} as above but the Euler angles are taken from
consecutive columns of the passed matrix \texttt{EUL} = [\texttt{PHI} \texttt{THETA} \texttt{PSI}].  If \texttt{EUL}
is a matrix ($N \times 3$) then they are assumed to represent a trajectory then \texttt{P}
is a vector ($1 \times N$) of SO3 objects.


\subsection*{Options}
\begin{longtable}{lp{120mm}}
\textquotesingle deg\textquotesingle  & Angles are specified in degrees (default radians)\\ 
\end{longtable}\vspace{1ex}

\subsection*{Note}
\begin{itemize}
  \item The vectors \texttt{PHI}, \texttt{THETA}, \texttt{PSI} must be of the same length.
\end{itemize}

\subsection*{Reference}
\begin{itemize}
  \item Robotics, Vision \& Control: Second Edition, \texttt{P}. Corke, Springer 2016; p36-37.
\end{itemize}

\subsection*{See also}


\hyperlink{SO3.rpy}{\color{blue} SO3.rpy}, \hyperlink{SE3.eul}{\color{blue} SE3.eul}, \hyperlink{eul2tr}{\color{blue} eul2tr}, \hyperlink{rpy2tr}{\color{blue} rpy2tr}, \hyperlink{tr2eul}{\color{blue} tr2eul}

\vspace{1.5ex}\hrule

%---------------------- SO3.exp
\hypertarget{SO3.exp}{\section*{SO3.exp}}
\subsection*{Construct SO3 from Lie algebra}
\addcontentsline{tom}{section}{SO3.exp}


\texttt{R = SO3.exp(X)} is the \textbf{\color{red} SO3} rotation corresponding to the so(3)
Lie algebra element SIGMA ($3 \times 3$).



\texttt{R = SO3.exp(TW)} as above but the Lie algebra is represented
as a twist vector \texttt{TW} ($3 \times 1$).


\subsection*{Notes}
\begin{itemize}
  \item \texttt{TW} is the non-zero elements of \texttt{X}.
\end{itemize}

\subsection*{Reference}
\begin{itemize}
  \item Robotics, Vision \& Control: Second Edition, P. Corke, Springer 2016; p42-43.
\end{itemize}

\subsection*{See also}


\hyperlink{trexp}{\color{blue} trexp}, \hyperlink{skew}{\color{blue} skew}

\vspace{1.5ex}\hrule

%---------------------- SO3.get.a
\hypertarget{SO3.get.a}{\section*{SO3.get.a}}
\subsection*{Get approach vector}
\addcontentsline{tom}{section}{SO3.get.a}


\texttt{P.a} is the approach vector ($3 \times 1$), the third column of the rotation matrix,
which is the z-axis unit vector.


\subsection*{See also}


\hyperlink{SO3.n}{\color{blue} SO3.n}, \hyperlink{SO3.o}{\color{blue} SO3.o}

\vspace{1.5ex}\hrule

%---------------------- SO3.get.n
\hypertarget{SO3.get.n}{\section*{SO3.get.n}}
\subsection*{Get normal vector}
\addcontentsline{tom}{section}{SO3.get.n}


\texttt{P.n} is the normal vector ($3 \times 1$), the first column of the rotation matrix,
which is the x-axis unit vector.


\subsection*{See also}


\hyperlink{SO3.o}{\color{blue} SO3.o}, \hyperlink{SO3.a}{\color{blue} SO3.a}

\vspace{1.5ex}\hrule

%---------------------- SO3.get.o
\hypertarget{SO3.get.o}{\section*{SO3.get.o}}
\subsection*{Get orientation vector}
\addcontentsline{tom}{section}{SO3.get.o}


\texttt{P.o} is the orientation vector ($3 \times 1$), the second column of the rotation matrix,
which is the y-axis unit vector..


\subsection*{See also}


\hyperlink{SO3.n}{\color{blue} SO3.n}, \hyperlink{SO3.a}{\color{blue} SO3.a}

\vspace{1.5ex}\hrule

%---------------------- SO3.interp
\hypertarget{SO3.interp}{\section*{SO3.interp}}
\subsection*{Interpolate between rotations}
\addcontentsline{tom}{section}{SO3.interp}


\texttt{P1.interp(P2, s)} is an \textbf{\color{red} SO3} object representing a slerp interpolation
between rotations represented by SO3 objects P1 and \texttt{P2}.  \texttt{s} varies from 0
(P1) to 1 (\texttt{P2}).  If \texttt{s} is a vector ($1 \times N$) then the result will be a vector
of SO3 objects.



\texttt{P1.interp(P2,N)} as above but returns a vector ($1 \times \texttt{N}$) of \textbf{\color{red} SO3} objects
interpolated between P1 and \texttt{P2} in \texttt{N} steps.


\subsection*{Notes}
\begin{itemize}
  \item It is an error if any element of S is outside the interval 0 to 1.
\end{itemize}

\subsection*{See also}


\hyperlink{UnitQuaternion}{\color{blue} UnitQuaternion}

\vspace{1.5ex}\hrule

%---------------------- SO3.inv
\hypertarget{SO3.inv}{\section*{SO3.inv}}
\subsection*{Inverse}
\addcontentsline{tom}{section}{SO3.inv}


\texttt{Q = inv(P)} is an \textbf{\color{red} SO3} object representing the inverse of the \textbf{\color{red} SO3} object \texttt{P}.


\subsection*{Notes}
\begin{itemize}
  \item This is a group operator: input and output in the $\mbox{SO}(3)$ group.
  \item This is simply the transpose of the underlying matrix.
  \item \texttt{P}*\texttt{Q} will be the identity group element (zero rotation, identity matrix).
\end{itemize}
\vspace{1.5ex}\hrule

%---------------------- SO3.isa
\hypertarget{SO3.isa}{\section*{SO3.isa}}
\subsection*{Test if a rotation matrix}
\addcontentsline{tom}{section}{SO3.isa}


\texttt{SO3.ISA(R)} is true (1) if the argument is of dimension $3 \times 3$ or $3 \times 3 \times N$, else false (0).



\texttt{SO3.ISA(R, 'valid')} as above, but also checks the validity of the rotation
matrix, ie. that its determinant is +1.


\subsection*{Notes}
\begin{itemize}
  \item The first form is a fast, but incomplete, test for a rotation in $\mbox{SO}(3)$.
\end{itemize}

\subsection*{See also}


\hyperlink{SE3.ISA}{\color{blue} SE3.ISA}, \hyperlink{SE2.ISA}{\color{blue} SE2.ISA}, \hyperlink{SO2.ISA}{\color{blue} SO2.ISA}

\vspace{1.5ex}\hrule

%---------------------- SO3.log
\hypertarget{SO3.log}{\section*{SO3.log}}
\subsection*{Logarithm}
\addcontentsline{tom}{section}{SO3.log}


\texttt{P.log()} is the Lie algebra corresponding to the \textbf{\color{red} SO3} object P. It is
a skew-symmetric matrix ($3 \times 3$).


\subsection*{Reference}
\begin{itemize}
  \item Robotics, Vision \& Control: Second Edition, P. Corke, Springer 2016; p42-43.
\end{itemize}

\subsection*{See also}


\hyperlink{SO3.exp}{\color{blue} SO3.exp}, \hyperlink{Twist}{\color{blue} Twist}, \hyperlink{trlog}{\color{blue} trlog}, \hyperlink{skew}{\color{blue} skew}, \hyperlink{vex}{\color{blue} vex}

\vspace{1.5ex}\hrule

%---------------------- SO3.new
\hypertarget{SO3.new}{\section*{SO3.new}}
\subsection*{Construct a new object of the same type}
\addcontentsline{tom}{section}{SO3.new}


Create a new object of the same type as the RTBPose derived instance object.



\texttt{P.new(X)} creates a new object of the same type as P, by invoking the \textbf{\color{red} SO3} constructor on the matrix
\texttt{X} ($3 \times 3$).



\texttt{P.new()} as above but assumes an identity matrix.


\subsection*{Notes}
\begin{itemize}
  \item Serves as a dynamic constructor.
  \item This method is polymorphic across all RTBPose derived classes, and     allows easy creation of a new object of the same class as an existing
  \item one without needing to explicitly determine its type.
\end{itemize}

\subsection*{See also}


\hyperlink{SE3.new}{\color{blue} SE3.new}, \hyperlink{SO2.new}{\color{blue} SO2.new}, \hyperlink{SE2.new}{\color{blue} SE2.new}

\vspace{1.5ex}\hrule

%---------------------- SO3.norm
\hypertarget{SO3.norm}{\section*{SO3.norm}}
\subsection*{Normalize rotation}
\addcontentsline{tom}{section}{SO3.norm}


\texttt{P.norm()} is an \textbf{\color{red} SO3} object equivalent to P but with a rotation
matrix guaranteed to be orthogonal.


\subsection*{Notes}
\begin{itemize}
  \item Overrides the classic RTB function trnorm for an SO3 object.
\end{itemize}

\subsection*{See also}


\hyperlink{trnorm}{\color{blue} trnorm}

\vspace{1.5ex}\hrule

%---------------------- SO3.oa
\hypertarget{SO3.oa}{\section*{SO3.oa}}
\subsection*{Construct SO3 from orientation and approach vectors}
\addcontentsline{tom}{section}{SO3.oa}


\texttt{P = SO3.oa(O, A)} is an \textbf{\color{red} SO3} object for the specified
orientation and approach vectors ($3 \times 1$) formed from 3 vectors such that
R = [N \texttt{O} \texttt{A}] and N = \texttt{O} x \texttt{A}.


\subsection*{Notes}
\begin{itemize}
  \item The rotation matrix is guaranteed to be orthonormal so long as \texttt{O} and \texttt{A}
\end{itemize}


are not parallel.

\begin{itemize}
  \item The vectors \texttt{O} and \texttt{A} are parallel to the Y- and Z-axes of the coordinate
\end{itemize}


frame.


\subsection*{References}
\begin{itemize}
  \item Robot manipulators: mathematis, programming and control     Richard Paul, MIT Press, 1981.
  \item Robotics, Vision \& Control: Second Edition, \texttt{P}. Corke, Springer 2016; p40-41.
\end{itemize}
\vspace{1.5ex}\hrule

%---------------------- SO3.R
\hypertarget{SO3.R}{\section*{SO3.R}}
\subsection*{Get rotation matrix}
\addcontentsline{tom}{section}{SO3.R}


\texttt{R = P.R()} is the rotation matrix ($3 \times 3$) associated with the \textbf{\color{red} SO3} object P.  If P
is a vector ($1 \times N$) then \texttt{R} ($3 \times 3 \times N$) is a stack of rotation matrices, with
the third dimension corresponding to the index of P.


\subsection*{See also}


\hyperlink{SO3.T}{\color{blue} SO3.T}

\vspace{1.5ex}\hrule

%---------------------- SO3.rand
\hypertarget{SO3.rand}{\section*{SO3.rand}}
\subsection*{Construct random SO3}
\addcontentsline{tom}{section}{SO3.rand}


\texttt{SO3.rand()} is an \textbf{\color{red} SO3} object with a random orientation drawn from
a uniform distribution.


\subsection*{See also}


\hyperlink{rand}{\color{blue} rand}, \hyperlink{UnitQuaternion.rand}{\color{blue} UnitQuaternion.rand}

\vspace{1.5ex}\hrule

%---------------------- SO3.rdivide
\hypertarget{SO3.rdivide}{\section*{SO3.rdivide}}
\subsection*{Compose SO3 object with inverse and normalize}
\addcontentsline{tom}{section}{SO3.rdivide}


\texttt{P ./ Q} is an \textbf{\color{red} SO3} object representing the composition of \textbf{\color{red} SO3} object \texttt{P} by the
inverse of SO3 object \texttt{Q}. This is matrix multiplication
of their orthonormal rotation matrices followed by normalization.



If either, or both, of P1 or P2 are vectors, then the result is a vector.

\begin{itemize}
  \item if P1 is a vector ($1 \times N$) then R is a vector ($1 \times N$) such that R(i) = P1(i).*P2.
  \item if P2 is a vector ($1 \times N$) then R is a vector ($1 \times N$) such that R(i) = P1.*P2(i).
  \item if both P1 and P2 are vectors ($1 \times N$) then R is a vector ($1 \times N$) such     that R(i) = P1(i).*P2(i).
\end{itemize}

\subsection*{Notes}
\begin{itemize}
  \item Overloaded operator \textquotesingle ./\textquotesingle .
  \item This is a group operator: \texttt{P}, \texttt{Q} and result all belong to the $\mbox{SO}(3)$ group.
\end{itemize}

\subsection*{See also}


\hyperlink{SO3.mrdivide}{\color{blue} SO3.mrdivide}, \hyperlink{SO3.times}{\color{blue} SO3.times}, \hyperlink{trnorm}{\color{blue} trnorm}

\vspace{1.5ex}\hrule

%---------------------- SO3.rpy
\hypertarget{SO3.rpy}{\section*{SO3.rpy}}
\subsection*{Construct SO3 from roll-pitch-yaw angles}
\addcontentsline{tom}{section}{SO3.rpy}


\texttt{P = SO3.rpy(ROLL, PITCH, YAW, OPTIONS)} is an \textbf{\color{red} SO3} object equivalent to the
specified roll, pitch, yaw angles angles. These correspond to rotations
about the Z, Y, X axes respectively. If \texttt{ROLL}, \texttt{PITCH}, \texttt{YAW} are column
vectors ($N \times 1$) then they are assumed to represent a trajectory then \texttt{P} is a
vector ($1 \times N$) of SO3 objects.



\texttt{P = SO3.rpy(RPY, OPTIONS)} as above but the roll, pitch, yaw angles angles
angles are taken from consecutive columns of the passed matrix \texttt{RPY} =
[\texttt{ROLL}, \texttt{PITCH}, \texttt{YAW}].  If \texttt{RPY} is a matrix ($N \times 3$) then they are assumed to
represent a trajectory and \texttt{P} is a vector ($1 \times N$) of SO3 objects.


\subsection*{Options}
\begin{longtable}{lp{120mm}}
\textquotesingle deg\textquotesingle  & Compute angles in degrees (radians default)\\ 
\textquotesingle xyz\textquotesingle  & Rotations about X, Y, Z axes (for a robot gripper)\\ 
\textquotesingle yxz\textquotesingle  & Rotations about Y, X, Z axes (for a camera)\\ 
\end{longtable}\vspace{1ex}

\subsection*{Reference}
\begin{itemize}
  \item Robotics, Vision \& Control: Second Edition, \texttt{P}. Corke, Springer 2016; p37-38
\end{itemize}

\subsection*{See also}


\hyperlink{SO3.eul}{\color{blue} SO3.eul}, \hyperlink{SE3.rpy}{\color{blue} SE3.rpy}, \hyperlink{tr2rpy}{\color{blue} tr2rpy}, \hyperlink{eul2tr}{\color{blue} eul2tr}

\vspace{1.5ex}\hrule

%---------------------- SO3.Rx
\hypertarget{SO3.Rx}{\section*{SO3.Rx}}
\subsection*{Construct SO3 from rotation about X axis}
\addcontentsline{tom}{section}{SO3.Rx}


\texttt{P = SO3.Rx(THETA)} is an \textbf{\color{red} SO3} object representing a rotation of \texttt{THETA}
radians about the x-axis.  If the \texttt{THETA} is a vector ($1 \times N$) then \texttt{P} will be
a vector ($1 \times N$) of corresponding SO3 objects.



\texttt{P = SO3.Rx(THETA, 'deg')} as above but \texttt{THETA} is in degrees.


\subsection*{See also}


\hyperlink{SO3.Ry}{\color{blue} SO3.Ry}, \hyperlink{SO3.Rz}{\color{blue} SO3.Rz}, \hyperlink{rotx}{\color{blue} rotx}

\vspace{1.5ex}\hrule

%---------------------- SO3.Ry
\hypertarget{SO3.Ry}{\section*{SO3.Ry}}
\subsection*{Construct SO3 from rotation about Y axis}
\addcontentsline{tom}{section}{SO3.Ry}


\texttt{P = SO3.Ry(THETA)} is an \textbf{\color{red} SO3} object representing a rotation of \texttt{THETA}
radians about the y-axis.  If the \texttt{THETA} is a vector ($1 \times N$) then \texttt{P} will be
a vector ($1 \times N$) of corresponding SO3 objects.



\texttt{P = SO3.Ry(THETA, 'deg')} as above but \texttt{THETA} is in degrees.


\subsection*{See also}


\hyperlink{SO3.Rx}{\color{blue} SO3.Rx}, \hyperlink{SO3.Rz}{\color{blue} SO3.Rz}, \hyperlink{roty}{\color{blue} roty}

\vspace{1.5ex}\hrule

%---------------------- SO3.Rz
\hypertarget{SO3.Rz}{\section*{SO3.Rz}}
\subsection*{Construct SO3 from rotation about Z axis}
\addcontentsline{tom}{section}{SO3.Rz}


\texttt{P = SO3.Rz(THETA)} is an \textbf{\color{red} SO3} object representing a rotation of \texttt{THETA}
radians about the z-axis.  If the \texttt{THETA} is a vector ($1 \times N$) then \texttt{P} will be
a vector ($1 \times N$) of corresponding SO3 objects.



\texttt{P = SO3.Rz(THETA, 'deg')} as above but \texttt{THETA} is in degrees.


\subsection*{See also}


\hyperlink{SO3.Rx}{\color{blue} SO3.Rx}, \hyperlink{SO3.Ry}{\color{blue} SO3.Ry}, \hyperlink{rotz}{\color{blue} rotz}

\vspace{1.5ex}\hrule

%---------------------- SO3.SE3
\hypertarget{SO3.SE3}{\section*{SO3.SE3}}
\subsection*{Convert to SE3 object}
\addcontentsline{tom}{section}{SO3.SE3}


\texttt{Q = P.SE3()} is an SE3 object with a rotational component given by the
SO3 object P, and with a zero translational component.  If P is a vector
of SO3 objects then \texttt{Q} will a same length vector of SE3 objects.


\subsection*{See also}


\hyperlink{SE3}{\color{blue} SE3}

\vspace{1.5ex}\hrule

%---------------------- SO3.T
\hypertarget{SO3.T}{\section*{SO3.T}}
\subsection*{Get homogeneous transformation matrix}
\addcontentsline{tom}{section}{SO3.T}


\texttt{T = P.T()} is the homogeneous transformation matrix ($4 \times 4$) associated with the
SO3 object P, and has zero translational component.  If P is a vector
($1 \times N$) then \texttt{T} ($4 \times 4 \times N$) is a stack of rotation matrices, with the third
dimension corresponding to the index of P.


\subsection*{See also}


\hyperlink{SO3.T}{\color{blue} SO3.T}

\vspace{1.5ex}\hrule

%---------------------- SO3.times
\hypertarget{SO3.times}{\section*{SO3.times}}
\subsection*{Compose SO3 objects and normalize}
\addcontentsline{tom}{section}{SO3.times}


\texttt{R = P1 .* P2} is an \textbf{\color{red} SO3} object representing the composition of the two
rotations described by the SO3 objects \texttt{P1} and \texttt{P2}. This is matrix multiplication
of their orthonormal rotation matrices followed by normalization.



If either, or both, of \texttt{P1} or \texttt{P2} are vectors, then the result is a vector.

\begin{itemize}
  \item if \texttt{P1} is a vector ($1 \times N$) then \texttt{R} is a vector ($1 \times N$) such that \texttt{R}(i) = \texttt{P1}(i).*\texttt{P2}.
  \item if \texttt{P2} is a vector ($1 \times N$) then \texttt{R} is a vector ($1 \times N$) such that \texttt{R}(i) = \texttt{P1}.*\texttt{P2}(i).
  \item if both \texttt{P1} and \texttt{P2} are vectors ($1 \times N$) then \texttt{R} is a vector ($1 \times N$) such     that \texttt{R}(i) = \texttt{P1}(i).*\texttt{P2}(i).
\end{itemize}

\subsection*{Notes}
\begin{itemize}
  \item Overloaded operator \textquotesingle .*\textquotesingle .
  \item This is a group operator: P, Q and result all belong to the $\mbox{SO}(3)$ group.
\end{itemize}

\subsection*{See also}


\hyperlink{RTBPose.mtimes}{\color{blue} RTBPose.mtimes}, \hyperlink{SO3.divide}{\color{blue} SO3.divide}, \hyperlink{trnorm}{\color{blue} trnorm}

\vspace{1.5ex}\hrule

%---------------------- SO3.toangvec
\hypertarget{SO3.toangvec}{\section*{SO3.toangvec}}
\subsection*{Convert to angle-vector form}
\addcontentsline{tom}{section}{SO3.toangvec}


\texttt{[THETA,V] = P.toangvec(OPTIONS)} is rotation expressed in terms of an
angle \texttt{THETA} about the axis \texttt{V} ($1 \times 3$) equivalent to the rotational
part of the SO3 object P.



If P is a vector ($1 \times N$) then \texttt{THETA} ($N \times 1$) is a vector of angles for
corresponding elements of the vector and \texttt{V} ($N \times 3$) are the corresponding
axes, one per row.


\subsection*{Options}
\begin{longtable}{lp{120mm}}
\textquotesingle deg\textquotesingle  & Return angle in degrees (default radians)\\ 
\end{longtable}\vspace{1ex}

\subsection*{Notes}
\begin{itemize}
  \item If no output arguments are specified the result is displayed.
\end{itemize}

\subsection*{Reference}
\begin{itemize}
  \item Robotics, Vision \& Control: Second Edition, P. Corke, Springer 2016; p41-42.
\end{itemize}

\subsection*{See also}


\hyperlink{angvec2r}{\color{blue} angvec2r}, \hyperlink{angvec2tr}{\color{blue} angvec2tr}, \hyperlink{trlog}{\color{blue} trlog}

\vspace{1.5ex}\hrule

%---------------------- SO3.toeul
\hypertarget{SO3.toeul}{\section*{SO3.toeul}}
\subsection*{Convert  to Euler angles}
\addcontentsline{tom}{section}{SO3.toeul}


\texttt{EUL = P.toeul(OPTIONS)} are the ZYZ Euler angles ($1 \times 3$) corresponding to
the rotational part of the SO3 object P. The three angles \texttt{EUL}=[PHI,THETA,PSI]
correspond to sequential rotations about the Z, Y and Z axes
respectively.



If P is a vector ($1 \times N$) then each row of \texttt{EUL} corresponds to an element of
the vector.


\subsection*{Options}
\begin{longtable}{lp{120mm}}
\textquotesingle deg\textquotesingle  & Compute angles in degrees (default radians)\\ 
\textquotesingle flip\textquotesingle  & Choose PHI to be in quadrant 2 or 3.\\ 
\end{longtable}\vspace{1ex}

\subsection*{Notes}
\begin{itemize}
  \item There is a singularity when THETA=0 in which case PHI is arbitrarily     set to zero and PSI is the sum (PHI+PSI).
\end{itemize}

\subsection*{Reference}
\begin{itemize}
  \item Robotics, Vision \& Control: Second Edition, P. Corke, Springer 2016; p36-37.
\end{itemize}

\subsection*{See also}


\hyperlink{SO3.torpy}{\color{blue} SO3.torpy}, \hyperlink{eul2tr}{\color{blue} eul2tr}, \hyperlink{tr2rpy}{\color{blue} tr2rpy}

\vspace{1.5ex}\hrule

%---------------------- SO3.torpy
\hypertarget{SO3.torpy}{\section*{SO3.torpy}}
\subsection*{Convert to roll-pitch-yaw angles}
\addcontentsline{tom}{section}{SO3.torpy}


\texttt{RPY = P.torpy(options)} are the roll-pitch-yaw angles ($1 \times 3$) corresponding
to the rotational part of the SO3 object P. The 3 angles \texttt{RPY}=[ROLL,PITCH,YAW]
correspond to sequential rotations about the Z, Y and X axes
respectively.



If P is a vector ($1 \times N$) then each row of \texttt{RPY} corresponds to an element of
the vector.


\subsection*{Options}
\begin{longtable}{lp{120mm}}
\textquotesingle deg\textquotesingle  & Compute angles in degrees (default radians)\\ 
\textquotesingle xyz\textquotesingle  & Return solution for sequential rotations about X, Y, Z axes\\ 
\textquotesingle yxz\textquotesingle  & Return solution for sequential rotations about Y, X, Z axes\\ 
\end{longtable}\vspace{1ex}

\subsection*{Notes}
\begin{itemize}
  \item There is a singularity for the case where PITCH=$\pi/2$ in which case ROLL is arbitrarily    set to zero and YAW is the sum (ROLL+YAW).
\end{itemize}

\subsection*{Reference}
\begin{itemize}
  \item Robotics, Vision \& Control: Second Edition, P. Corke, Springer 2016; p37-38.
\end{itemize}

\subsection*{See also}


\hyperlink{SO3.toeul}{\color{blue} SO3.toeul}, \hyperlink{rpy2tr}{\color{blue} rpy2tr}, \hyperlink{tr2eul}{\color{blue} tr2eul}

\vspace{1.5ex}\hrule

%---------------------- SO3.tr2eul
\hypertarget{SO3.tr2eul}{\section*{SO3.tr2eul}}
\subsection*{Convert to Euler angles (compatibility)}
\addcontentsline{tom}{section}{SO3.tr2eul}


\texttt{tr2eul(P, OPTIONS)} is a vector ($1 \times 3$) of ZYZ Euler angles
equivalent to the rotation \texttt{P} (SO3 object).


\subsection*{Notes}
\begin{itemize}
  \item Overrides the classic RTB function tr2eul for an SO3 object.
  \item All the options of tr2eul apply.
\end{itemize}

\subsection*{See also}


\hyperlink{tr2eul}{\color{blue} tr2eul}

\vspace{1.5ex}\hrule

%---------------------- SO3.tr2rpy
\hypertarget{SO3.tr2rpy}{\section*{SO3.tr2rpy}}
\subsection*{Convert to RPY angles (compatibility)}
\addcontentsline{tom}{section}{SO3.tr2rpy}


\texttt{tr2rpy(P, OPTIONS)} is a vector ($1 \times 3$) of roll-pitch-yaw angles
equivalent to the rotation \texttt{P} (SO3 object).


\subsection*{Notes}
\begin{itemize}
  \item Overrides the classic RTB function tr2rpy for an SO3 object.
  \item All the options of tr2rpy apply.
  \item Defaults to ZYX order.
\end{itemize}

\subsection*{See also}


\hyperlink{tr2rpy}{\color{blue} tr2rpy}

\vspace{1.5ex}\hrule

%---------------------- SO3.trnorm
\hypertarget{SO3.trnorm}{\section*{SO3.trnorm}}
\subsection*{Normalize rotation (compatibility)}
\addcontentsline{tom}{section}{SO3.trnorm}


\texttt{trnorm(P)} is an \textbf{\color{red} SO3} object equivalent to \texttt{P} but with a rotation
matrix guaranteed to be orthogonal.


\subsection*{Notes}
\begin{itemize}
  \item Overrides the classic RTB function trnorm for an SO3 object.
\end{itemize}

\subsection*{See also}


\hyperlink{trnorm}{\color{blue} trnorm}

\vspace{1.5ex}\hrule

%---------------------- SO3.UnitQuaternion
\hypertarget{SO3.UnitQuaternion}{\section*{SO3.UnitQuaternion}}
\subsection*{Convert to UnitQuaternion object}
\addcontentsline{tom}{section}{SO3.UnitQuaternion}


\texttt{P.UnitQuaternion()} is a UnitQuaternion object equivalent to the rotation
described by the SO3 object P.


\subsection*{See also}


\hyperlink{UnitQuaternion}{\color{blue} UnitQuaternion}

\vspace{1.5ex}\rule{\textwidth}{1mm}

%---------------------- SpatialAcceleration
\hypertarget{SpatialAcceleration}{\section*{SpatialAcceleration}}
\subsection*{Spatial acceleration class}
\addcontentsline{toc}{section}{SpatialAcceleration}


Concrete subclass of SpatialM6 and represents the
translational and rotational acceleration of a rigid-body moving in 3D space.

\begin{Code}
    SpatialVec6 (abstract handle class)
      |
      +--- SpatialM6 (abstract)
      |     |
      |     +---SpatialVelocity
      |     +---SpatialAcceleration
      |
      +---SpatialF6 (abstract)
           |
           +---SpatialForce
           +---SpatialMomentum

\end{Code}

\subsection*{Methods}
\begin{longtable}{lp{120mm}}
SpatialAcceleration & \textasciicircum constructor invoked by subclasses\\ 
char & \textasciicircum convert to string\\ 
cross & \textasciicircum\textasciicircum cross product\\ 
display & \textasciicircum display in human readable form\\ 
double & \textasciicircum convert to a $6 \times N$ double\\ 
new & construct new concrete class of same type\\ 
\end{longtable}\vspace{1ex}

\subsection*{Operators}
\begin{longtable}{lp{120mm}}
+ & \textasciicircum add spatial vectors of the same type\\ 
- & \textasciicircum subtract spatial vectors of the same type\\ 
- & \textasciicircum unary minus of spatial vectors\\ 
\textasteriskcentered  & \textasciicircum\textasciicircum\textasciicircum premultiplication by SpatialInertia yields SpatialForce\\ 
\textasteriskcentered  & \textasciicircum\textasciicircum\textasciicircum\textasciicircum premultiplication by Twist yields transformed SpatialAcceleration\\ 
\end{longtable}\vspace{1ex}


Notes:

\begin{itemize}
  \item \textasciicircum  is inherited from SpatialVec6.
  \item \textasciicircum\textasciicircum  is inherited from SpatialM6.
  \item \textasciicircum\textasciicircum\textasciicircum  are implemented in SpatialInertia.
  \item \textasciicircum\textasciicircum\textasciicircum\textasciicircum  are implemented in Twist.
\end{itemize}

\subsection*{References}
\begin{itemize}
  \item Robot Dynamics Algorithms, R. Featherstone, volume 22,     Springer International Series in Engineering and Computer Science,
  \item Springer, 1987.
  \item A beginner\textquotesingle s guide to 6-d vectors (part 1), R. Featherstone,     IEEE Robotics Automation Magazine, 17(3):83-94, Sep. 2010.
\end{itemize}
\vspace{1.5ex}\hrule

%---------------------- SpatialAcceleration.new
\hypertarget{SpatialAcceleration.new}{\section*{SpatialAcceleration.new}}
\subsection*{Construct a new object of the same type}
\addcontentsline{tom}{section}{SpatialAcceleration.new}


\texttt{A2 = A.new(X)} creates a new object of the same type as A, with the value
\texttt{X} ($6 \times 1$).


\subsection*{Notes}
\begin{itemize}
  \item Serves as a dynamic constructor.
  \item This method is polymorphic across all SpatialVec6 derived classes, and     allows easy creation of a new object of the same class as an existing
  \item one without needing to explicitly determine its type.
\end{itemize}
\vspace{1.5ex}\rule{\textwidth}{1mm}

%---------------------- SpatialF6
\hypertarget{SpatialF6}{\section*{SpatialF6}}
\subsection*{Abstract spatial force class}
\addcontentsline{toc}{section}{SpatialF6}


Abstract superclass that represents spatial force.  This class has two
concrete subclasses:

\begin{Code}
    SpatialVec6 (abstract handle class)
      |
      +--- SpatialM6 (abstract)
      |     |
      |     +---SpatialVelocity
      |     +---SpatialAcceleration
      |
      +---SpatialF6 (abstract)
           |
           +---SpatialForce
           +---SpatialMomentum

\end{Code}

\subsection*{Methods}
\begin{longtable}{lp{120mm}}
SpatialF6 & \textasciicircum constructor invoked by subclasses\\ 
char & \textasciicircum convert to string\\ 
display & \textasciicircum display in human readable form\\ 
double & \textasciicircum convert to a $6 \times N$ double\\ 
\end{longtable}\vspace{1ex}

\subsection*{Operators}
\begin{longtable}{lp{120mm}}
+ & \textasciicircum add spatial vectors of the same type\\ 
- & \textasciicircum subtract spatial vectors of the same type\\ 
- & \textasciicircum unary minus of spatial vectors\\ 
\end{longtable}\vspace{1ex}


Notes:

\begin{itemize}
  \item \textasciicircum  is inherited from SpatialVec6.
  \item Subclass of the MATLAB handle class which means that pass by reference semantics    apply.
  \item Spatial vectors can be placed into arrays and indexed.
\end{itemize}

\subsection*{References}
\begin{itemize}
  \item Robot Dynamics Algorithms, R. Featherstone, volume 22,     Springer International Series in Engineering and Computer Science,
  \item Springer, 1987.
  \item A beginner\textquotesingle s guide to 6-d vectors (part 1), R. Featherstone,     IEEE Robotics Automation Magazine, 17(3):83-94, Sep. 2010.
\end{itemize}

\subsection*{See also}


\hyperlink{SpatialForce}{\color{blue} SpatialForce}, \hyperlink{SpatialMomentum}{\color{blue} SpatialMomentum}, \hyperlink{SpatialInertia}{\color{blue} SpatialInertia}, \hyperlink{SpatialM6}{\color{blue} SpatialM6}

\vspace{1.5ex}\hrule
\vspace{1.5ex}\rule{\textwidth}{1mm}

%---------------------- SpatialForce
\hypertarget{SpatialForce}{\section*{SpatialForce}}
\subsection*{Spatial force class}
\addcontentsline{toc}{section}{SpatialForce}


Concrete subclass of SpatialF6 and represents the
translational and rotational forces and torques acting on a rigid-body in 3D space.

\begin{Code}
    SpatialVec6 (abstract handle class)
      |
      +--- SpatialM6 (abstract)
      |     |
      |     +---SpatialVelocity
      |     +---SpatialAcceleration
      |
      +---SpatialF6 (abstract)
           |
           +---SpatialForce
           +---SpatialMomentum

\end{Code}

\subsection*{Methods}
\begin{longtable}{lp{120mm}}
SpatialForce & \textasciicircum constructor invoked by subclasses\\ 
char & \textasciicircum convert to string\\ 
display & \textasciicircum display in human readable form\\ 
double & \textasciicircum convert to a $6 \times N$ double\\ 
new & construct new concrete class of same type\\ 
\end{longtable}\vspace{1ex}

\subsection*{Operators}
\begin{longtable}{lp{120mm}}
+ & \textasciicircum add spatial vectors of the same type\\ 
- & \textasciicircum subtract spatial vectors of the same type\\ 
- & \textasciicircum unary minus of spatial vectors\\ 
\textasteriskcentered  & \textasciicircum\textasciicircum\textasciicircum premultiplication by SE3 yields transformed SpatialForce\\ 
\textasteriskcentered  & \textasciicircum\textasciicircum\textasciicircum\textasciicircum premultiplication by Twist yields transformed SpatialForce\\ 
\end{longtable}\vspace{1ex}


Notes:

\begin{itemize}
  \item \textasciicircum  is inherited from SpatialVec6.
  \item \textasciicircum\textasciicircum  is inherited from SpatialM6.
  \item \textasciicircum\textasciicircum\textasciicircum  are implemented in RTBPose.
  \item \textasciicircum\textasciicircum\textasciicircum\textasciicircum  are implemented in Twist.
\end{itemize}

\subsection*{References}
\begin{itemize}
  \item Robot Dynamics Algorithms, R. Featherstone, volume 22,     Springer International Series in Engineering and Computer Science,
  \item Springer, 1987.
  \item A beginner\textquotesingle s guide to 6-d vectors (part 1), R. Featherstone,     IEEE Robotics Automation Magazine, 17(3):83-94, Sep. 2010.
\end{itemize}

\subsection*{See also}


\hyperlink{SpatialVec6}{\color{blue} SpatialVec6}, \hyperlink{SpatialF6}{\color{blue} SpatialF6}, \hyperlink{SpatialMomentum}{\color{blue} SpatialMomentum}

\vspace{1.5ex}\hrule

%---------------------- SpatialForce.new
\hypertarget{SpatialForce.new}{\section*{SpatialForce.new}}
\subsection*{Construct a new object of the same type}
\addcontentsline{tom}{section}{SpatialForce.new}


\texttt{A2 = A.new(X)} creates a new object of the same type as A, with the value
\texttt{X} ($6 \times 1$).


\subsection*{Notes}
\begin{itemize}
  \item Serves as a dynamic constructor.
  \item This method is polymorphic across all SpatialVec6 derived classes, and     allows easy creation of a new object of the same class as an existing
  \item one without needing to explicitly determine its type.
\end{itemize}
\vspace{1.5ex}\rule{\textwidth}{1mm}

%---------------------- SpatialInertia
\hypertarget{SpatialInertia}{\section*{SpatialInertia}}
\subsection*{Spatial inertia class}
\addcontentsline{toc}{section}{SpatialInertia}


Concrete class representing spatial inertia.


\subsection*{Methods}
\begin{longtable}{lp{120mm}}
SpatialInertia & constructor\\ 
char & convert to string\\ 
display & display in human readable form\\ 
double & convert to a $6 \times N$ double\\ 
\end{longtable}\vspace{1ex}

\subsection*{Operators}
\begin{longtable}{lp{120mm}}
+ & plus: add spatial inertia of connected bodies\\ 
\textasteriskcentered  & mtimes: compute force or momentum\\ 
\end{longtable}\vspace{1ex}

\subsection*{Notes}
\begin{itemize}
  \item Subclass of the MATLAB handle class which means that pass by reference semantics     apply.
  \item Spatial inertias can be placed into arrays and indexed.
\end{itemize}

\subsection*{References}
\begin{itemize}
  \item Robot Dynamics Algorithms, R. Featherstone, volume 22,     Springer International Series in Engineering and Computer Science,
  \item Springer, 1987.
  \item A beginner\textquotesingle s guide to 6-d vectors (part 1), R. Featherstone,     IEEE Robotics Automation Magazine, 17(3):83-94, Sep. 2010.
\end{itemize}


See also SpatialM6, SpatialF6, SpatialVelocity, SpatialAcceleration, SpatialForce,
SpatialMomentum.

\vspace{1.5ex}\hrule

%---------------------- SpatialInertia.SpatialInertia
\hypertarget{SpatialInertia.SpatialInertia}{\section*{SpatialInertia.SpatialInertia}}
\subsection*{Constructor}
\addcontentsline{tom}{section}{SpatialInertia.SpatialInertia}


\texttt{SI = SpatialInertia(M, C, I)} is a spatial inertia object for a rigid-body
with mass \texttt{M}, centre of mass at \texttt{C} relative to the link frame, and an
inertia matrix ($3 \times 3$) about the centre of mass.



\texttt{SI = SpatialInertia(I)} is a spatial inertia object with a value equal
to \texttt{I} ($6 \times 6$).

\vspace{1.5ex}\hrule

%---------------------- SpatialInertia.char
\hypertarget{SpatialInertia.char}{\section*{SpatialInertia.char}}
\subsection*{Convert to string}
\addcontentsline{tom}{section}{SpatialInertia.char}


\texttt{s = SI.char()} is a string showing spatial inertia parameters in a
compact format.
If SI is an array of spatial inertia objects return a string with the
inertia values in a vertical list.


\subsection*{See also}


\hyperlink{SpatialInertia.display}{\color{blue} SpatialInertia.display}

\vspace{1.5ex}\hrule

%---------------------- SpatialInertia.display
\hypertarget{SpatialInertia.display}{\section*{SpatialInertia.display}}
\subsection*{Display parameters}
\addcontentsline{tom}{section}{SpatialInertia.display}


\texttt{SI.display()} displays the spatial inertia parameters in compact format.
If SI is an array of spatial inertia objects it displays them in a vertical
list.


\subsection*{Notes}
\begin{itemize}
  \item This method is invoked implicitly at the command line when the result     of an expression is a spatial inerita object and the command has
  \item no trailing semicolon.
\end{itemize}

\subsection*{See also}


\hyperlink{SpatialInertia.char}{\color{blue} SpatialInertia.char}

\vspace{1.5ex}\hrule

%---------------------- SpatialInertia.double
\hypertarget{SpatialInertia.double}{\section*{SpatialInertia.double}}
\subsection*{Convert to matrix}
\addcontentsline{tom}{section}{SpatialInertia.double}


\texttt{double(V)} is a native matrix ($6 \times 6$) with the value of the spatial inertia.
If \texttt{V} is an array ($1 \times N$) the result is a matrix ($6 \times 6 \times N$).

\vspace{1.5ex}\hrule

%---------------------- SpatialInertia.mtimes
\hypertarget{SpatialInertia.mtimes}{\section*{SpatialInertia.mtimes}}
\subsection*{Multiplication operator}
\addcontentsline{tom}{section}{SpatialInertia.mtimes}


\texttt{SI * A} is the SpatialForce required for a body with \textbf{\color{red} SpatialInertia} \texttt{SI} to accelerate with
the SpatialAcceleration \texttt{A}.



\texttt{SI * V} is the SpatialMomemtum of a body with \textbf{\color{red} SpatialInertia} \texttt{SI} and SpatialVelocity \texttt{V}.


\subsection*{Notes}
\begin{itemize}
  \item These products must be written in this order, \texttt{A}*\texttt{SI} and \texttt{V}*\texttt{SI} are not defined.
\end{itemize}
\vspace{1.5ex}\hrule

%---------------------- SpatialInertia.plus
\hypertarget{SpatialInertia.plus}{\section*{SpatialInertia.plus}}
\subsection*{Addition operator}
\addcontentsline{tom}{section}{SpatialInertia.plus}


\texttt{SI1 + SI2} is the \textbf{\color{red} SpatialInertia} of a composite body when bodies with \textbf{\color{red} SpatialInertia} \texttt{SI1} and \texttt{SI2}
are connected.

\vspace{1.5ex}\rule{\textwidth}{1mm}

%---------------------- SpatialM6
\hypertarget{SpatialM6}{\section*{SpatialM6}}
\subsection*{Abstract spatial motion class}
\addcontentsline{toc}{section}{SpatialM6}


Abstract superclass that represents spatial motion.  This class has two
concrete subclasses:

\begin{Code}
    SpatialVec6 (abstract handle class)
      |
      +--- SpatialM6 (abstract)
      |     |
      |     +---SpatialVelocity
      |     +---SpatialAcceleration
      |
      +---SpatialF6 (abstract)
           |
           +---SpatialForce
           +---SpatialMomentum

\end{Code}

\subsection*{Methods}
\begin{longtable}{lp{120mm}}
SpatialM6 & \textasciicircum constructor invoked by subclasses\\ 
char & \textasciicircum convert to string\\ 
cross & cross product\\ 
display & \textasciicircum display in human readable form\\ 
double & \textasciicircum convert to a $6 \times N$ double\\ 
\end{longtable}\vspace{1ex}

\subsection*{Operators}
\begin{longtable}{lp{120mm}}
+ & \textasciicircum add spatial vectors of the same type\\ 
- & \textasciicircum subtract spatial vectors of the same type\\ 
- & \textasciicircum unary minus of spatial vectors\\ 
\end{longtable}\vspace{1ex}


Notes:

\begin{itemize}
  \item \textasciicircum  is inherited from SpatialVec6.
  \item Subclass of the MATLAB handle class which means that pass by reference semantics     apply.
  \item Spatial vectors can be placed into arrays and indexed.
\end{itemize}

\subsection*{References}
\begin{itemize}
  \item Robot Dynamics Algorithms, R. Featherstone, volume 22,     Springer International Series in Engineering and Computer Science,
  \item Springer, 1987.
  \item A beginner\textquotesingle s guide to 6-d vectors (part 1), R. Featherstone,     IEEE Robotics Automation Magazine, 17(3):83-94, Sep. 2010.
\end{itemize}

\subsection*{See also}


\hyperlink{SpatialForce}{\color{blue} SpatialForce}, \hyperlink{SpatialMomentum}{\color{blue} SpatialMomentum}, \hyperlink{SpatialInertia}{\color{blue} SpatialInertia}, \hyperlink{SpatialM6}{\color{blue} SpatialM6}

\vspace{1.5ex}\hrule

%---------------------- SpatialM6.cross
\hypertarget{SpatialM6.cross}{\section*{SpatialM6.cross}}
\subsection*{Spatial velocity cross product}
\addcontentsline{tom}{section}{SpatialM6.cross}


\texttt{cross(V1, V2)} is a SpatialAcceleration object where \texttt{V1} and \texttt{V2} are \textbf{\color{red} SpatialM6}
subclass instances.



\texttt{cross(V, F)} is a SpatialForce object where \texttt{V1} is a \textbf{\color{red} SpatialM6}
subclass instances and \texttt{F} is a SpatialForce subclass instance.


\subsection*{Notes}
\begin{itemize}
  \item The first form is Featherstone\textquotesingle s ``x'' operator.
  \item The second form is Featherstone\textquotesingle s ``x*'' operator.
\end{itemize}
\vspace{1.5ex}\rule{\textwidth}{1mm}

%---------------------- SpatialMomentum
\hypertarget{SpatialMomentum}{\section*{SpatialMomentum}}
\subsection*{Spatial momentum class}
\addcontentsline{toc}{section}{SpatialMomentum}


Concrete subclass of SpatialF6 and represents the
translational and rotational momentum of a rigid-body moving in 3D space.

\begin{Code}
    SpatialVec6 (abstract handle class)
      |
      +--- SpatialM6 (abstract)
      |     |
      |     +---SpatialVelocity
      |     +---SpatialAcceleration
      |
      +---SpatialF6 (abstract)
           |
           +---SpatialForce
           +---SpatialMomentum

\end{Code}

\subsection*{Methods}
\begin{longtable}{lp{120mm}}
SpatialMomentum & \textasciicircum constructor invoked by subclasses\\ 
new & construct new concrete class of same type\\ 
double & \textasciicircum convert to a $6 \times N$ double\\ 
char & \textasciicircum convert to string\\ 
cross & \textasciicircum\textasciicircum cross product\\ 
display & \textasciicircum display in human readable form\\ 
\end{longtable}\vspace{1ex}

\subsection*{Operators}
\begin{longtable}{lp{120mm}}
+ & \textasciicircum add spatial vectors of the same type\\ 
- & \textasciicircum subtract spatial vectors of the same type\\ 
- & \textasciicircum unary minus of spatial vectors\\ 
\end{longtable}\vspace{1ex}


Notes:

\begin{itemize}
  \item \textasciicircum  is inherited from SpatialVec6.
  \item \textasciicircum\textasciicircum  is inherited from SpatialM6.
\end{itemize}

\subsection*{References}
\begin{itemize}
  \item Robot Dynamics Algorithms, R. Featherstone, volume 22,     Springer International Series in Engineering and Computer Science,
  \item Springer, 1987.
  \item A beginner\textquotesingle s guide to 6-d vectors (part 1), R. Featherstone,     IEEE Robotics Automation Magazine, 17(3):83-94, Sep. 2010.
\end{itemize}

\subsection*{See also}


\hyperlink{SpatialVec6}{\color{blue} SpatialVec6}, \hyperlink{SpatialF6}{\color{blue} SpatialF6}, \hyperlink{SpatialForce}{\color{blue} SpatialForce}

\vspace{1.5ex}\hrule

%---------------------- SpatialMomentum.new
\hypertarget{SpatialMomentum.new}{\section*{SpatialMomentum.new}}
\subsection*{Construct a new object of the same type}
\addcontentsline{tom}{section}{SpatialMomentum.new}


\texttt{A2 = A.new(X)} creates a new object of the same type as A, with the value
\texttt{X} ($6 \times 1$).


\subsection*{Notes}
\begin{itemize}
  \item Serves as a dynamic constructor.
  \item This method is polymorphic across all SpatialVec6 derived classes, and     allows easy creation of a new object of the same class as an existing
  \item one without needing to explicitly determine its type.
\end{itemize}
\vspace{1.5ex}\rule{\textwidth}{1mm}

%---------------------- SpatialVec6
\hypertarget{SpatialVec6}{\section*{SpatialVec6}}
\subsection*{Abstract spatial 6-vector class}
\addcontentsline{toc}{section}{SpatialVec6}


Abstract superclass for spatial vector functionality.  This class has two
abstract subclasses, which each have concrete subclasses:



SpatialVec6 (abstract handle class)

\begin{Code}
  |
  +--- SpatialM6 (abstract)
  |     |
  |     +---SpatialVelocity
  |     +---SpatialAcceleration
  |
  +---SpatialF6 (abstract)
\end{Code}
\begin{Code}
       |
       +---SpatialForce
       +---SpatialMomentum

\end{Code}

\subsection*{Methods}
\begin{longtable}{lp{120mm}}
SpatialV6 & constructor invoked by subclasses\\ 
double & convert to a $6 \times N$ double\\ 
char & convert to string\\ 
display & display in human readable form\\ 
\end{longtable}\vspace{1ex}

\subsection*{Operators}
\begin{longtable}{lp{120mm}}
+ & add spatial vectors of the same type\\ 
- & subtract spatial vectors of the same type\\ 
- & unary minus of spatial vectors\\ 
\end{longtable}\vspace{1ex}

\subsection*{Notes}
\begin{itemize}
  \item Subclass of the MATLAB handle class which means that pass by reference semantics    apply.
  \item Spatial vectors can be placed into arrays and indexed.
\end{itemize}

\subsection*{References}
\begin{itemize}
  \item Robot Dynamics Algorithms, R. Featherstone, volume 22,     Springer International Series in Engineering and Computer Science,
  \item Springer, 1987.
  \item A beginner\textquotesingle s guide to 6-d vectors (part 1), R. Featherstone,     IEEE Robotics Automation Magazine, 17(3):83-94, Sep. 2010.
\end{itemize}


See also SpatialM6, SpatialF6, SpatialVelocity, SpatialAcceleration, SpatialForce,
SpatialMomentum, SpatialInertia.

\vspace{1.5ex}\hrule

%---------------------- SpatialVec6.SpatialVec6
\hypertarget{SpatialVec6.SpatialVec6}{\section*{SpatialVec6.SpatialVec6}}
\subsection*{Constructor}
\addcontentsline{tom}{section}{SpatialVec6.SpatialVec6}


\texttt{SpatiaVecXXX(V)} is a spatial vector of type SpatiaVecXXX with a value
from \texttt{V} ($6 \times 1$).  If \texttt{V} ($6 \times N$) then an ($N \times 1$) array of spatial vectors is
returned.



This constructor is inherited by all the concrete subclasses.


\subsection*{See also}


\hyperlink{SpatialVelocity}{\color{blue} SpatialVelocity}, \hyperlink{SpatialAcceleration}{\color{blue} SpatialAcceleration}, \hyperlink{SpatialForce}{\color{blue} SpatialForce}, \hyperlink{SpatialMomentum}{\color{blue} SpatialMomentum}

\vspace{1.5ex}\hrule

%---------------------- SpatialVec6.char
\hypertarget{SpatialVec6.char}{\section*{SpatialVec6.char}}
\subsection*{Convert to string}
\addcontentsline{tom}{section}{SpatialVec6.char}


\texttt{s = V.char()} is a string showing spatial vector parameters in a
compact single line format.
If V is an array of spatial vector objects return a string with one
line per element.


\subsection*{See also}


\hyperlink{SpatialVec6.display}{\color{blue} SpatialVec6.display}

\vspace{1.5ex}\hrule

%---------------------- SpatialVec6.display
\hypertarget{SpatialVec6.display}{\section*{SpatialVec6.display}}
\subsection*{Display parameters}
\addcontentsline{tom}{section}{SpatialVec6.display}


\texttt{V.display()} displays the spatial vector parameters in compact single line format.
If V is an array of spatial vector objects it displays one per line.


\subsection*{Notes}
\begin{itemize}
  \item This method is invoked implicitly at the command line when the result     of an expression is a serial vector subclass object and the command has
  \item no trailing semicolon.
\end{itemize}

\subsection*{See also}


\hyperlink{SpatialVec6.char}{\color{blue} SpatialVec6.char}

\vspace{1.5ex}\hrule

%---------------------- SpatialVec6.double
\hypertarget{SpatialVec6.double}{\section*{SpatialVec6.double}}
\subsection*{Convert to matrix}
\addcontentsline{tom}{section}{SpatialVec6.double}


\texttt{double(V)} is a native matrix ($6 \times 1$) with the value of the spatial vector.
If \texttt{V} is an array ($1 \times N$) the result is a matrix ($6 \times N$).

\vspace{1.5ex}\hrule

%---------------------- SpatialVec6.minus
\hypertarget{SpatialVec6.minus}{\section*{SpatialVec6.minus}}
\subsection*{Subtraction operator}
\addcontentsline{tom}{section}{SpatialVec6.minus}


\texttt{V1 - V2} is a spatial vector of the same type as \texttt{V1} and \texttt{V2} whose value is
the difference of \texttt{V1} and \texttt{V2}.  If both are arrays of spatial vectors \texttt{V1} ($1 \times N$) and
\texttt{V2} ($1 \times N$) the result is an array ($1 \times N$).


\subsection*{See also}


\hyperlink{SpatialVec6.uminus}{\color{blue} SpatialVec6.uminus}, \hyperlink{SpatialVec6.plus}{\color{blue} SpatialVec6.plus}

\vspace{1.5ex}\hrule

%---------------------- SpatialVec6.plus
\hypertarget{SpatialVec6.plus}{\section*{SpatialVec6.plus}}
\subsection*{Addition operator}
\addcontentsline{tom}{section}{SpatialVec6.plus}


\texttt{V1 + V2} is a spatial vector of the same type as \texttt{V1} and \texttt{V2} whose value is
the sum of \texttt{V1} and \texttt{V2}.  If both are arrays of spatial vectors \texttt{V1} ($1 \times N$) and
\texttt{V2} ($1 \times N$) the result is an array ($1 \times N$).


\subsection*{See also}


\hyperlink{SpatialVec6.minus}{\color{blue} SpatialVec6.minus}

\vspace{1.5ex}\hrule

%---------------------- SpatialVec6.uminus
\hypertarget{SpatialVec6.uminus}{\section*{SpatialVec6.uminus}}
\subsection*{Unary minus operator}
\addcontentsline{tom}{section}{SpatialVec6.uminus}
\begin{itemize}
  \item V is a spatial vector of the same type as V whose value is
\end{itemize}


the negative of V.  If V is an array V ($1 \times N$) then the result
is an array ($1 \times N$).


\subsection*{See also}


\hyperlink{SpatialVec6.minus}{\color{blue} SpatialVec6.minus}, \hyperlink{SpatialVec6.plus}{\color{blue} SpatialVec6.plus}

\vspace{1.5ex}\rule{\textwidth}{1mm}

%---------------------- SpatialVelocity
\hypertarget{SpatialVelocity}{\section*{SpatialVelocity}}
\subsection*{Spatial velocity class}
\addcontentsline{toc}{section}{SpatialVelocity}


Concrete subclass of SpatialM6 and represents the
translational and rotational velocity of a rigid-body moving in 3D space.

\begin{Code}
    SpatialVec6 (abstract handle class)
      |
      +--- SpatialM6 (abstract)
      |     |
      |     +---SpatialVelocity
      |     +---SpatialAcceleration
      |
      +---SpatialF6 (abstract)
           |
           +---SpatialForce
           +---SpatialMomentum

\end{Code}

\subsection*{Methods}
\begin{longtable}{lp{120mm}}
SpatialVelocity & \textasciicircum constructor invoked by subclasses\\ 
char & \textasciicircum convert to string\\ 
cross & \textasciicircum\textasciicircum cross product\\ 
display & \textasciicircum display in human readable form\\ 
double & \textasciicircum convert to a $6 \times N$ double\\ 
new & construct new concrete class of same type\\ 
\end{longtable}\vspace{1ex}

\subsection*{Operators}
\begin{longtable}{lp{120mm}}
+ & \textasciicircum add spatial vectors of the same type\\ 
- & \textasciicircum subtract spatial vectors of the same type\\ 
- & \textasciicircum unary minus of spatial vectors\\ 
\textasteriskcentered  & \textasciicircum\textasciicircum\textasciicircum premultiplication by SpatialInertia yields SpatialMomentum\\ 
\textasteriskcentered  & \textasciicircum\textasciicircum\textasciicircum\textasciicircum premultiplication by Twist yields transformed SpatialVelocity\\ 
\end{longtable}\vspace{1ex}


Notes:

\begin{itemize}
  \item \textasciicircum  is inherited from SpatialVec6.
  \item \textasciicircum\textasciicircum  is inherited from SpatialM6.
  \item \textasciicircum\textasciicircum\textasciicircum  are implemented in SpatialInertia.
  \item \textasciicircum\textasciicircum\textasciicircum\textasciicircum  are implemented in Twist.
\end{itemize}

\subsection*{References}
\begin{itemize}
  \item Robot Dynamics Algorithms, R. Featherstone, volume 22,     Springer International Series in Engineering and Computer Science,
  \item Springer, 1987.
  \item A beginner\textquotesingle s guide to 6-d vectors (part 1), R. Featherstone,     IEEE Robotics Automation Magazine, 17(3):83-94, Sep. 2010.
\end{itemize}

\subsection*{See also}


\hyperlink{SpatialVec6}{\color{blue} SpatialVec6}, \hyperlink{SpatialM6}{\color{blue} SpatialM6}, \hyperlink{SpatialAcceleration}{\color{blue} SpatialAcceleration}, \hyperlink{SpatialInertia}{\color{blue} SpatialInertia}, \hyperlink{SpatialMomentum}{\color{blue} SpatialMomentum}

\vspace{1.5ex}\hrule

%---------------------- SpatialVelocity.new
\hypertarget{SpatialVelocity.new}{\section*{SpatialVelocity.new}}
\subsection*{Construct a new object of the same type}
\addcontentsline{tom}{section}{SpatialVelocity.new}


\texttt{A2 = A.new(X)} creates a new object of the same type as A, with the value
\texttt{X} ($6 \times 1$).


\subsection*{Notes}
\begin{itemize}
  \item Serves as a dynamic constructor.
  \item This method is polymorphic across all SpatialVec6 derived classes, and     allows easy creation of a new object of the same class as an existing
  \item one without needing to explicitly determine its type.
\end{itemize}
\vspace{1.5ex}\rule{\textwidth}{1mm}

%---------------------- stlRead
\hypertarget{stlRead}{\section*{stlRead}}
\subsection*{Reads STL file}
\addcontentsline{toc}{section}{stlRead}


\texttt{[v, f, n, objname] = stlRead(fileName)} reads the STL format file (ASCII or
binary) and returns:

\begin{longtable}{lp{120mm}}
V (Mx3) & each row is the 3D coordinate of a vertex\\ 
F (Nx3) & each row is a list of vertex indices that defines a triangular face\\ 
N (Nx3) & each row is a unit-vector defining the face normal\\ 
OBJNAME & is the name of the STL object (NOT the name of the STL file).\\ 
\end{longtable}\vspace{1ex}

\subsection*{Authors}
\begin{itemize}
  \item From MATLAB File Exchange by Pau Mico, \url{https://au.mathworks.com/matlabcentral/fileexchange/51200-stltools}
  \item Copyright (c) 2015, Pau Mico
  \item Copyright (c) 2013, Adam H. Aitkenhead
  \item Copyright (c) 2011, Francis Esmonde-White
\end{itemize}
\vspace{1.5ex}\rule{\textwidth}{1mm}

%---------------------- t2r
\hypertarget{t2r}{\section*{t2r}}
\subsection*{Rotational submatrix}
\addcontentsline{toc}{section}{t2r}


\texttt{R = T2R(T)} is the orthonormal rotation matrix component of homogeneous
transformation matrix \texttt{T}.  Works for \texttt{T} in $\mbox{SE}(2)$ or $\mbox{SE}(3)$

\begin{itemize}
  \item If \texttt{T} is $4 \times 4$, then \texttt{R} is $3 \times 3$.
  \item If \texttt{T} is $3 \times 3$, then \texttt{R} is $2 \times 2$.
\end{itemize}

\subsection*{Notes}
\begin{itemize}
  \item For a homogeneous transform sequence ($K \times K \times N$) returns a rotation matrix    sequence ($K-1 \times K$-$1 \times N$).
  \item The validity of rotational part is not checked
\end{itemize}

\subsection*{See also}


\hyperlink{r2t}{\color{blue} r2t}, \hyperlink{tr2rt}{\color{blue} tr2rt}, \hyperlink{rt2tr}{\color{blue} rt2tr}

\vspace{1.5ex}\rule{\textwidth}{1mm}

%---------------------- tb\_optparse
\hypertarget{tb\_optparse}{\section*{tb\_optparse}}
\subsection*{Standard option parser for Toolbox functions}
\addcontentsline{toc}{section}{tb\_optparse}


\texttt{OPTOUT = TB\_OPTPARSE(OPT, ARGLIST)} is a generalized option parser for
Toolbox functions.  \texttt{OPT} is a structure that contains the names and
default values for the options, and \texttt{ARGLIST} is a cell array containing
option parameters, typically it comes from VARARGIN.  It supports options
that have an assigned value, boolean or enumeration types (string or
int).



\texttt{[OPTOUT,ARGS] = TB\_OPTPARSE(OPT, ARGLIST)} as above but returns all the
unassigned options, those that don\textquotesingle t match anything in \texttt{OPT}, as a cell
array of all unassigned arguments in the order given in \texttt{ARGLIST}.



\texttt{[OPTOUT,ARGS,LS] = TB\_OPTPARSE(OPT, ARGLIST)} as above but if any
unmatched option looks like a MATLAB LineSpec (eg. \textquotesingle r:\textquotesingle ) it is placed in \texttt{LS} rather
than in \texttt{ARGS}.



\texttt{[OBJOUT,ARGS,LS] = TB\_OPTPARSE(OPT, ARGLIST, OBJ)} as above but properties
of \texttt{OBJ} with matching names in \texttt{OPT} are set.



The software pattern is:

\begin{Code}
   function myFunction(a, b, c, varargin)
      opt.foo = false;
      opt.bar = true;
      opt.blah = [];
      opt.stuff = {};
      opt.choose = {'this', 'that', 'other'};
      opt.select = {'#no', '#yes'};
      opt.old = '@foo';
      opt = tb_optparse(opt, varargin);

\end{Code}


Optional arguments to the function behave as follows:

\begin{longtable}{lp{120mm}}
\textquotesingle foo\textquotesingle  & sets opt.foo := true\\ 
\textquotesingle nobar\textquotesingle  & sets opt.foo := false\\ 
\textquotesingle blah\textquotesingle , 3 & sets opt.blah := 3\\ 
\textquotesingle blah\textquotesingle ,{x,y} & sets opt.blah := $\{$x,y$\}$\\ 
\textquotesingle that\textquotesingle  & sets opt.choose := \textquotesingle that\textquotesingle \\ 
\textquotesingle yes\textquotesingle  & sets opt.select := 2 (the second element)\\ 
\textquotesingle stuff\textquotesingle , 5 & sets opt.stuff to $\{$5$\}$\\ 
\textquotesingle stuff\textquotesingle , {\textquotesingle k\textquotesingle ,3} & sets opt.stuff to $\{$\textquotesingle k\textquotesingle ,3$\}$\\ 
\textquotesingle old\textquotesingle  & synonym, is the same as the option foo\\ 
\end{longtable}\vspace{1ex}


and can be given in any combination.



If neither of \textquotesingle this\textquotesingle , \textquotesingle that\textquotesingle  or \textquotesingle other\textquotesingle  are specified then opt.choose := \textquotesingle this\textquotesingle .
Alternatively if:

\begin{Code}
  opt.choose = {[], 'this', 'that', 'other'};
\end{Code}


then if neither of \textquotesingle this\textquotesingle , \textquotesingle that\textquotesingle  or \textquotesingle other\textquotesingle  are specified then opt.choose := [].



If neither of \textquotesingle no\textquotesingle  or \textquotesingle yes\textquotesingle  are specified then opt.select := 1.



The return structure is automatically populated with fields: verbose and
debug.  The following options are automatically parsed:

\begin{longtable}{lp{120mm}}
\textquotesingle verbose\textquotesingle  & sets opt.verbose := true\\ 
\textquotesingle verbose=2\textquotesingle  & sets opt.verbose := 2 (very verbose)\\ 
\textquotesingle verbose=3\textquotesingle  & sets opt.verbose := 3 (extremeley verbose)\\ 
\textquotesingle verbose=4\textquotesingle  & sets opt.verbose := 4 (ridiculously verbose)\\ 
\textquotesingle debug\textquotesingle , N & sets opt.debug := N\\ 
\textquotesingle showopt\textquotesingle  & displays opt and arglist\\ 
\textquotesingle setopt\textquotesingle ,S                    opt.foo is set to 4. & sets opt := S, if S.foo=4, and opt.foo is present, then\\ 
\end{longtable}\vspace{1ex}


The allowable options are specified by the names of the fields in the
structure \texttt{OPT}.  By default if an option is given that is not a field of
\texttt{OPT} an error is declared.


\subsection*{Notes}
\begin{itemize}
  \item That the enumerator names must be distinct from the field names.
  \item That only one value can be assigned to a field, if multiple values    are required they must placed in a cell array.
  \item If the option is seen multiple times the last (rightmost) instance applies.
  \item To match an option that starts with a digit, prefix it with \textquotesingle d\_\textquotesingle , so    the field \textquotesingle d\_3d\textquotesingle  matches the option \textquotesingle 3d\textquotesingle .
  \item Any input argument or element of the opt struct can be a string instead    of a char array.
\end{itemize}
\vspace{1.5ex}\rule{\textwidth}{1mm}

%---------------------- tr2angvec
\hypertarget{tr2angvec}{\section*{tr2angvec}}
\subsection*{Convert rotation matrix to angle-vector form}
\addcontentsline{toc}{section}{tr2angvec}


\texttt{[THETA,V] = TR2ANGVEC(R, OPTIONS)} is rotation expressed in terms of an
angle \texttt{THETA} ($1 \times 1$) about the axis \texttt{V} ($1 \times 3$) equivalent to the orthonormal rotation
matrix \texttt{R} ($3 \times 3$).



\texttt{[THETA,V] = TR2ANGVEC(T, OPTIONS)} as above but uses the rotational part of the
homogeneous transform \texttt{T} ($4 \times 4$).



If \texttt{R} ($3 \times 3 \times K$) or \texttt{T} ($4 \times 4 \times K$) represent a sequence then \texttt{THETA} ($K \times 1$)is a vector
of angles for corresponding elements of the sequence and \texttt{V} ($K \times 3$) are the
corresponding axes, one per row.


\subsection*{Options}
\begin{longtable}{lp{120mm}}
\textquotesingle deg\textquotesingle  & Return angle in degrees (default radians)\\ 
\end{longtable}\vspace{1ex}

\subsection*{Notes}
\begin{itemize}
  \item For an identity rotation matrix both \texttt{THETA} and \texttt{V} are set to zero.
  \item The rotation angle is always in the interval [0 $\pi$], negative rotation    is handled by inverting the direction of the rotation axis.
  \item If no output arguments are specified the result is displayed.
\end{itemize}

\subsection*{See also}


\hyperlink{angvec2r}{\color{blue} angvec2r}, \hyperlink{angvec2tr}{\color{blue} angvec2tr}, \hyperlink{trlog}{\color{blue} trlog}

\vspace{1.5ex}\rule{\textwidth}{1mm}

%---------------------- tr2delta
\hypertarget{tr2delta}{\section*{tr2delta}}
\subsection*{Convert $\mbox{SE}(3)$ homogeneous transform to differential motion}
\addcontentsline{toc}{section}{tr2delta}


\texttt{D = TR2DELTA(T0, T1)} is the differential motion ($6 \times 1$) corresponding to
infinitessimal motion (in the \texttt{T0} frame) from pose \texttt{T0} to \texttt{T1} which are homogeneous
transformations ($4 \times 4$) or SE3 objects.



The vector \texttt{D}=(dx, dy, dz, dRx, dRy, dRz) represents infinitessimal translation
and rotation, and is an approximation to the instantaneous spatial velocity
multiplied by time step.



\texttt{D = TR2DELTA(T)} as above but the motion is from the world frame to the SE3
pose \texttt{T}.


\subsection*{Notes}
\begin{itemize}
  \item \texttt{D} is only an approximation to the motion \texttt{T}, and assumes    that \texttt{T0}$\approx$\texttt{T1} or \texttt{T}$\approx$eye(4,4).
  \item Can be considered as an approximation to the effect of spatial velocity over a    a time interval, average spatial velocity multiplied by time.
\end{itemize}

\subsection*{Reference}
\begin{itemize}
  \item Robotics, Vision \& Control: Second Edition, P. Corke, Springer 2016; p67.
\end{itemize}

\subsection*{See also}


\hyperlink{delta2tr}{\color{blue} delta2tr}, \hyperlink{skew}{\color{blue} skew}, \hyperlink{SE3.todelta}{\color{blue} SE3.todelta}

\vspace{1.5ex}\rule{\textwidth}{1mm}

%---------------------- tr2eul
\hypertarget{tr2eul}{\section*{tr2eul}}
\subsection*{Convert $\mbox{SO}(3)$ or $\mbox{SE}(3)$ matrix to Euler angles}
\addcontentsline{toc}{section}{tr2eul}


\texttt{EUL = TR2EUL(T, OPTIONS)} are the ZYZ Euler angles ($1 \times 3$) corresponding to
the rotational part of a homogeneous transform \texttt{T} ($4 \times 4$). The 3 angles
\texttt{EUL}=[PHI,THETA,PSI] correspond to sequential rotations about the Z, Y and
Z axes respectively.



\texttt{EUL = TR2EUL(R, OPTIONS)} as above but the input is an orthonormal
rotation matrix \texttt{R} ($3 \times 3$).



If \texttt{R} ($3 \times 3 \times K$) or \texttt{T} ($4 \times 4 \times K$) represent a sequence then each row of \texttt{EUL}
corresponds to a step of the sequence.


\subsection*{Options}
\begin{longtable}{lp{120mm}}
\textquotesingle deg\textquotesingle  & Compute angles in degrees (radians default)\\ 
\textquotesingle flip\textquotesingle  & Choose first Euler angle to be in quadrant 2 or 3.\\ 
\end{longtable}\vspace{1ex}

\subsection*{Notes}
\begin{itemize}
  \item There is a singularity for the case where THETA=0 in which case PHI is arbitrarily    set to zero and PSI is the sum (PHI+PSI).
  \item Translation component is ignored.
\end{itemize}

\subsection*{See also}


\hyperlink{eul2tr}{\color{blue} eul2tr}, \hyperlink{tr2rpy}{\color{blue} tr2rpy}

\vspace{1.5ex}\rule{\textwidth}{1mm}

%---------------------- tr2jac
\hypertarget{tr2jac}{\section*{tr2jac}}
\subsection*{Jacobian for differential motion}
\addcontentsline{toc}{section}{tr2jac}


\texttt{J = TR2JAC(TAB)} is a Jacobian matrix ($6 \times 6$) that maps spatial velocity or
differential motion from frame $\{$A$\}$ to frame $\{$B$\}$ where the pose of $\{$B$\}$
relative to $\{$A$\}$ is represented by the homogeneous transform \texttt{TAB} ($4 \times 4$).



\texttt{J = TR2JAC(TAB, 'samebody')} is a Jacobian matrix ($6 \times 6$) that maps spatial
velocity or differential motion from frame $\{$A$\}$ to frame $\{$B$\}$ where both
are attached to the same moving body.  The pose of $\{$B$\}$ relative to $\{$A$\}$ is
represented by the homogeneous transform \texttt{TAB} ($4 \times 4$).


\subsection*{See also}


\hyperlink{wtrans}{\color{blue} wtrans}, \hyperlink{tr2delta}{\color{blue} tr2delta}, \hyperlink{delta2tr}{\color{blue} delta2tr}, \hyperlink{SE3.velxform}{\color{blue} SE3.velxform}

\vspace{1.5ex}\rule{\textwidth}{1mm}

%---------------------- tr2rpy
\hypertarget{tr2rpy}{\section*{tr2rpy}}
\subsection*{Convert $\mbox{SO}(3)$ or $\mbox{SE}(3)$ matrix to roll-pitch-yaw angles}
\addcontentsline{toc}{section}{tr2rpy}


\texttt{RPY = TR2RPY(T, options)} are the roll-pitch-yaw angles ($1 \times 3$)
corresponding to the rotation part of a homogeneous transform \texttt{T}. The 3
angles \texttt{RPY}=[ROLL,PITCH,YAW] correspond to sequential rotations about the Z, Y and
X axes respectively. Roll and yaw angles are in $[-\pi, \pi)$ while pitch angle is
in [-$\pi/2$,$\pi/2$).



\texttt{RPY = TR2RPY(R, options)} as above but the input is an orthonormal
rotation matrix \texttt{R} ($3 \times 3$).



If \texttt{R} ($3 \times 3 \times K$) or \texttt{T} ($4 \times 4 \times K$) represent a sequence then each row of \texttt{RPY}
corresponds to a step of the sequence.


\subsection*{Options}
\begin{longtable}{lp{120mm}}
\textquotesingle deg\textquotesingle  & Compute angles in degrees (radians default)\\ 
\end{longtable}\vspace{1ex}
\begin{longtable}{lp{120mm}}
\textquotesingle xyz\textquotesingle  & Return solution for sequential rotations about X, Y, Z axes\\ 
\textquotesingle zyx\textquotesingle  & Return solution for sequential rotations about Z, Y, X axes (default)\\ 
\textquotesingle yxz\textquotesingle  & Return solution for sequential rotations about Y, X, Z axes\\ 
\textquotesingle arm\textquotesingle  & Return solution for sequential rotations about X, Y, Z axes\\ 
\textquotesingle vehicle\textquotesingle  & Return solution for sequential rotations about Z, Y, X axes\\ 
\textquotesingle camera\textquotesingle  & Return solution for sequential rotations about Y, X, Z axes\\ 
\end{longtable}\vspace{1ex}

\subsection*{Notes}
\begin{itemize}
  \item There is a singularity for the case where PITCH=$\pi/2$ in which case ROLL is arbitrarily    set to zero and YAW is the sum (ROLL+YAW).
  \item Translation component is ignored.
  \item Toolbox rel 8-9 has XYZ angle sequence as default.
  \item \textquotesingle arm\textquotesingle , \textquotesingle vehicle\textquotesingle , \textquotesingle camera\textquotesingle  are synonyms for \textquotesingle xyz\textquotesingle , \textquotesingle zyx\textquotesingle  and \textquotesingle yxz\textquotesingle     respectively.
  \item these solutions are generated by symbolic/rpygen.mlx
\end{itemize}

\subsection*{See also}


\hyperlink{rpy2tr}{\color{blue} rpy2tr}, \hyperlink{tr2eul}{\color{blue} tr2eul}

\vspace{1.5ex}\rule{\textwidth}{1mm}

%---------------------- tr2rt
\hypertarget{tr2rt}{\section*{tr2rt}}
\subsection*{Convert homogeneous transform to rotation and translation}
\addcontentsline{toc}{section}{tr2rt}


\texttt{[R,t] = TR2RT(TR)} splits a homogeneous transformation matrix ($N \times N$) into an
orthonormal rotation matrix \texttt{R} ($M \times M$) and a translation vector \texttt{t} ($M \times 1$), where
N=M+1.



Works for \texttt{TR} in $\mbox{SE}(2)$ or $\mbox{SE}(3)$

\begin{itemize}
  \item If \texttt{TR} is $4 \times 4$, then \texttt{R} is $3 \times 3$ and T is $3 \times 1$.
  \item If \texttt{TR} is $3 \times 3$, then \texttt{R} is $2 \times 2$ and T is $2 \times 1$.
\end{itemize}


A homogeneous transform sequence \texttt{TR} ($N \times N \times K$) is split into rotation matrix
sequence \texttt{R} ($M \times M \times K$) and a translation sequence \texttt{t} ($K \times M$).


\subsection*{Notes}
\begin{itemize}
  \item The validity of \texttt{R} is not checked.
\end{itemize}

\subsection*{See also}


\hyperlink{rt2tr}{\color{blue} rt2tr}, \hyperlink{r2t}{\color{blue} r2t}, \hyperlink{t2r}{\color{blue} t2r}

\vspace{1.5ex}\rule{\textwidth}{1mm}

%---------------------- tranimate
\hypertarget{tranimate}{\section*{tranimate}}
\subsection*{Animate a 3D coordinate frame}
\addcontentsline{toc}{section}{tranimate}


\texttt{TRANIMATE(P1, P2, OPTIONS)} animates a 3D coordinate frame moving from pose X1
to pose X2.  Poses X1 and X2 can be represented by:

\begin{itemize}
  \item $\mbox{SE}(3)$ homogeneous transformation matrices ($4 \times 4$)
  \item $\mbox{SO}(3)$ orthonormal rotation matrices ($3 \times 3$)
\end{itemize}


\texttt{TRANIMATE(X, OPTIONS)} animates a coordinate frame moving from the identity pose
to the pose \texttt{X} represented by any of the types listed above.



\texttt{TRANIMATE(XSEQ, OPTIONS)} animates a trajectory, where \texttt{XSEQ} is any of

\begin{itemize}
  \item $\mbox{SE}(3)$ homogeneous transformation matrix sequence ($4 \times 4 \times N$)
  \item $\mbox{SO}(3)$ orthonormal rotation matrix sequence ($3 \times 3 \times N$)
\end{itemize}

\subsection*{Options}
\begin{longtable}{lp{120mm}}
\textquotesingle fps\textquotesingle , fps & Number of frames per second to display (default 10)\\ 
\textquotesingle nsteps\textquotesingle , n & The number of steps along the path (default 50)\\ 
\textquotesingle axis\textquotesingle ,A & Axis bounds [xmin, xmax, ymin, ymax, zmin, zmax]\\ 
\textquotesingle movie\textquotesingle ,M & Save frames as a movie or sequence of frames\\ 
\textquotesingle cleanup\textquotesingle  & Remove the frame at end of animation\\ 
\textquotesingle noxyz\textquotesingle  & Don\textquotesingle t label the axes\\ 
\textquotesingle rgb\textquotesingle  & Color the axes in the order x=red, y=green, z=blue\\ 
\textquotesingle retain\textquotesingle  & Retain frames, don\textquotesingle t animate\\ 
\end{longtable}\vspace{1ex}


Additional options are passed through to TRPLOT.


\subsection*{Notes}
\begin{itemize}
  \item Uses the Animate helper class to record the frames.
\end{itemize}

\subsection*{See also}


\hyperlink{trplot}{\color{blue} trplot}, \hyperlink{Animate}{\color{blue} Animate}, \hyperlink{SE3.animate}{\color{blue} SE3.animate}

\vspace{1.5ex}\rule{\textwidth}{1mm}

%---------------------- tranimate2
\hypertarget{tranimate2}{\section*{tranimate2}}
\subsection*{Animate a 2D coordinate frame}
\addcontentsline{toc}{section}{tranimate2}


\texttt{TRANIMATE2(P1, P2, OPTIONS)} animates a 3D coordinate frame moving from pose X1
to pose X2.  Poses X1 and X2 can be represented by:

\begin{itemize}
  \item $\mbox{SE}(2)$ homogeneous transformation matrices ($3 \times 3$)
  \item $\mbox{SO}(2)$ orthonormal rotation matrices ($2 \times 2$)
\end{itemize}


\texttt{TRANIMATE2(X, OPTIONS)} animates a coordinate frame moving from the identity pose
to the pose \texttt{X} represented by any of the types listed above.



\texttt{TRANIMATE2(XSEQ, OPTIONS)} animates a trajectory, where \texttt{XSEQ} is any of

\begin{itemize}
  \item $\mbox{SE}(2)$ homogeneous transformation matrix sequence ($3 \times 3 \times N$)
  \item $\mbox{SO}(2)$ orthonormal rotation matrix sequence ($2 \times 2 \times N$)
\end{itemize}

\subsection*{Options}
\begin{longtable}{lp{120mm}}
\textquotesingle fps\textquotesingle , fps & Number of frames per second to display (default 10)\\ 
\textquotesingle nsteps\textquotesingle , n & The number of steps along the path (default 50)\\ 
\textquotesingle axis\textquotesingle ,A & Axis bounds [xmin, xmax, ymin, ymax, zmin, zmax]\\ 
\textquotesingle movie\textquotesingle ,M & Save frames as a movie or sequence of frames\\ 
\textquotesingle cleanup\textquotesingle  & Remove the frame at end of animation\\ 
\textquotesingle noxyz\textquotesingle  & Don\textquotesingle t label the axes\\ 
\textquotesingle rgb\textquotesingle  & Color the axes in the order x=red, y=green, z=blue\\ 
\textquotesingle retain\textquotesingle  & Retain frames, don\textquotesingle t animate\\ 
\end{longtable}\vspace{1ex}


Additional options are passed through to TRPLOT2.


\subsection*{Notes}
\begin{itemize}
  \item Uses the Animate helper class to record the frames.
\end{itemize}

\subsection*{See also}


\hyperlink{trplot}{\color{blue} trplot}, \hyperlink{Animate}{\color{blue} Animate}, \hyperlink{SE3.animate}{\color{blue} SE3.animate}

\vspace{1.5ex}\rule{\textwidth}{1mm}

%---------------------- transl
\hypertarget{transl}{\section*{transl}}
\subsection*{$\mbox{SE}(3)$ translational homogeneous transform}
\addcontentsline{toc}{section}{transl}

\subsection*{Create a translational $\mbox{SE}(3)$ matrix}


\texttt{T = TRANSL(X, Y, Z)} is an $\mbox{SE}(3)$ homogeneous transform ($4 \times 4$) representing
a pure translation of \texttt{X}, \texttt{Y} and \texttt{Z}.



\texttt{T = TRANSL(P)} is an $\mbox{SE}(3)$ homogeneous transform ($4 \times 4$) representing a
translation of \texttt{P}=[\texttt{X},\texttt{Y},\texttt{Z}]. \texttt{P} ($M \times 3$) represents a sequence and \texttt{T}
($4 \times 4 \times M$) is a sequence of homogeneous transforms such that \texttt{T}(:,:,i)
corresponds to the i\textquotesingle th row of \texttt{P}.


\subsection*{Extract the translational part of an $\mbox{SE}(3)$ matrix}


\texttt{P = TRANSL(T)} is the translational part of a homogeneous transform \texttt{T} as a
3-element column vector.  \texttt{T} ($4 \times 4 \times M$) is a homogeneous transform
sequence and the rows of \texttt{P} ($M \times 3$) are the translational component of the
corresponding transform in the sequence.



\texttt{[X,Y,Z] = TRANSL(T)} is the translational part of a homogeneous transform
\texttt{T} as three components.  If \texttt{T} ($4 \times 4 \times M$) is a homogeneous transform sequence
then \texttt{X},\texttt{Y},\texttt{Z} ($1 \times M$) are the translational components of the corresponding
transform in the sequence.


\subsection*{Notes}
\begin{itemize}
  \item Somewhat unusually, this function performs a function and its inverse.  An    historical anomaly.
\end{itemize}

\subsection*{See also}


\hyperlink{SE3.t}{\color{blue} SE3.t}, \hyperlink{SE3.transl}{\color{blue} SE3.transl}

\vspace{1.5ex}\rule{\textwidth}{1mm}

%---------------------- transl2
\hypertarget{transl2}{\section*{transl2}}
\subsection*{$\mbox{SE}(2)$ translational homogeneous transform}
\addcontentsline{toc}{section}{transl2}

\subsection*{Create a translational $\mbox{SE}(2)$ matrix}


\texttt{T = TRANSL2(X, Y)} is an $\mbox{SE}(2)$ homogeneous transform ($3 \times 3$) representing a
pure translation.



\texttt{T = TRANSL2(P)} is a homogeneous transform representing a translation or
point \texttt{P}=[\texttt{X},\texttt{Y}]. \texttt{P} ($M \times 2$) represents a sequence and \texttt{T} ($3 \times 3 \times M$) is a
sequence of homogenous transforms such that \texttt{T}(:,:,i) corresponds to the
i\textquotesingle th row of \texttt{P}.


\subsection*{Extract the translational part of an $\mbox{SE}(2)$ matrix}


\texttt{P = TRANSL2(T)} is the translational part of a homogeneous transform as a
2-element column vector.  \texttt{T} ($3 \times 3 \times M$) is a homogeneous transform
sequence and the rows of \texttt{P} ($M \times 2$) are the translational component of the
corresponding transform in the sequence.


\subsection*{Notes}
\begin{itemize}
  \item Somewhat unusually, this function performs a function and its inverse.  An    historical anomaly.
\end{itemize}

\subsection*{See also}


\hyperlink{SE2.t}{\color{blue} SE2.t}, \hyperlink{rot2}{\color{blue} rot2}, \hyperlink{ishomog2}{\color{blue} ishomog2}, \hyperlink{trplot2}{\color{blue} trplot2}, \hyperlink{transl}{\color{blue} transl}

\vspace{1.5ex}\rule{\textwidth}{1mm}

%---------------------- trchain
\hypertarget{trchain}{\section*{trchain}}
\subsection*{Compound $\mbox{SE}(3)$ transforms from string}
\addcontentsline{toc}{section}{trchain}


\texttt{T = TRCHAIN(S, Q)} is a homogeneous transform ($4 \times 4$) that results from
compounding a number of elementary transformations defined by the string
\texttt{S}.  The string \texttt{S} comprises a number of tokens of the form X(ARG) where
X is one of Tx, Ty, Tz, Rx, Ry, or Rz.  ARG is the name of a variable in
MATLAB workspace or \textquotesingle qJ\textquotesingle  where J is an integer in the range 1 to N that
selects the variable from the Jth column of the vector \texttt{Q} ($1 \times N$).



For example:

\begin{Code}
  trchain('Rx(q1)Tx(a1)Ry(q2)Ty(a3)Rz(q3)', [1 2 3])

\end{Code}


is equivalent to computing:

\begin{Code}
  trotx(1) * transl(a1,0,0) * troty(2) * transl(0,a3,0) * trotz(3)

\end{Code}

\subsection*{Notes}
\begin{itemize}
  \item Variables list in the string must exist in the caller workspace.
  \item The string can contain spaces between elements, or on either side of ARG.
  \item Works for symbolic variables in the workspace and/or passed in via the    vector \texttt{Q}.
  \item For symbolic operations that involve use of the value $\pi$, make sure you    define it first in the workspace: $\pi$ = sym(\textquotesingle $\pi$\textquotesingle );
\end{itemize}

\subsection*{See also}


\hyperlink{trchain2}{\color{blue} trchain2}, \hyperlink{trotx}{\color{blue} trotx}, \hyperlink{troty}{\color{blue} troty}, \hyperlink{trotz}{\color{blue} trotz}, \hyperlink{transl}{\color{blue} transl}, \hyperlink{SerialLink.trchain}{\color{blue} SerialLink.trchain}, \hyperlink{ets}{\color{blue} ets}

\vspace{1.5ex}\rule{\textwidth}{1mm}

%---------------------- trchain2
\hypertarget{trchain2}{\section*{trchain2}}
\subsection*{Compound $\mbox{SE}(2)$ transforms from string}
\addcontentsline{toc}{section}{trchain2}


\texttt{T = TRCHAIN2(S, Q)} is a homogeneous transform ($3 \times 3$) that results from
compounding a number of elementary transformations defined by the string
\texttt{S}.  The string \texttt{S} comprises a number of tokens of the form X(ARG) where
X is one of Tx, Ty or R.  ARG is the name of a variable in
MATLAB workspace or \textquotesingle qJ\textquotesingle  where J is an integer in the range 1 to N that
selects the variable from the Jth column of the vector \texttt{Q} ($1 \times N$).



For example:

\begin{Code}
  trchain('R(q1)Tx(a1)R(q2)Ty(a3)R(q3)', [1 2 3])

\end{Code}


is equivalent to computing:

\begin{Code}
  trot2(1) * transl2(a1,0) * trot2(2) * transl2(0,a3) * trot2(3)

\end{Code}

\subsection*{Notes}
\begin{itemize}
  \item Variables list in the string must exist in the caller workspace.
  \item The string can contain spaces between elements or on either side of ARG.
  \item Works for symbolic variables in the workspace and/or passed in via the    vector \texttt{Q}.
  \item For symbolic operations that involve use of the value $\pi$, make sure you    define it first in the workspace: $\pi$ = sym(\textquotesingle $\pi$\textquotesingle );
\end{itemize}

\subsection*{See also}


\hyperlink{trchain}{\color{blue} trchain}, \hyperlink{trot2}{\color{blue} trot2}, \hyperlink{transl2}{\color{blue} transl2}

\vspace{1.5ex}\rule{\textwidth}{1mm}

%---------------------- trexp
\hypertarget{trexp}{\section*{trexp}}
\subsection*{Matrix exponential for so(3) and se(3)}
\addcontentsline{toc}{section}{trexp}

\subsection*{For so(3)}


\texttt{R = TREXP(OMEGA)} is the matrix exponential ($3 \times 3$) of the so(3) element \texttt{OMEGA} that
yields a rotation matrix ($3 \times 3$).



\texttt{R = TREXP(OMEGA, THETA)} as above, but so(3) motion of \texttt{THETA}*\texttt{OMEGA}.



\texttt{R = TREXP(S, THETA)} as above, but rotation of \texttt{THETA} about the unit vector \texttt{S}.



\texttt{R = TREXP(W)} as above, but the so(3) value is expressed as a vector \texttt{W}
($1 \times 3$) where \texttt{W} = \texttt{S} * \texttt{THETA}. Rotation by ||\texttt{W}|| about the vector \texttt{W}.


\subsection*{For se(3)}


\texttt{T = TREXP(SIGMA)} is the matrix exponential ($4 \times 4$) of the se(3) element \texttt{SIGMA} that
yields a homogeneous transformation  matrix ($4 \times 4$).



\texttt{T = TREXP(SIGMA, THETA)} as above, but se(3) motion of \texttt{SIGMA}*\texttt{THETA}, the
rotation part of \texttt{SIGMA} ($4 \times 4$) must be unit norm.



\texttt{T = TREXP(TW)} as above, but the se(3) value is expressed as a twist vector \texttt{TW}
($1 \times 6$).



\texttt{T = TREXP(TW, THETA)} as above, but se(3) motion of \texttt{TW}*\texttt{THETA}, the
rotation part of \texttt{TW} ($1 \times 6$) must be unit norm.


\subsection*{Notes}
\begin{itemize}
  \item Efficient closed-form solution of the matrix exponential for arguments that are    so(3) or se(3).
  \item If \texttt{THETA} is given then the first argument must be a unit vector or a    skew-symmetric matrix from a unit vector.
  \item Angle vector argument order is different to ANGVEC2R.
\end{itemize}

\subsection*{References}
\begin{itemize}
  \item Robotics, Vision \& Control: Second Edition, P. Corke, Springer 2016; p42-43.
  \item Mechanics, planning and control, Park \& Lynch, Cambridge, 2017.
\end{itemize}

\subsection*{See also}


\hyperlink{angvec2r}{\color{blue} angvec2r}, \hyperlink{trlog}{\color{blue} trlog}, \hyperlink{trexp2}{\color{blue} trexp2}, \hyperlink{skew}{\color{blue} skew}, \hyperlink{skewa}{\color{blue} skewa}, \hyperlink{Twist}{\color{blue} Twist}

\vspace{1.5ex}\rule{\textwidth}{1mm}

%---------------------- trexp2
\hypertarget{trexp2}{\section*{trexp2}}
\subsection*{Matrix exponential for so(2) and se(2)}
\addcontentsline{toc}{section}{trexp2}

\subsection*{$\mbox{SO}(2)$}


\texttt{R = TREXP2(OMEGA)} is the matrix exponential ($2 \times 2$) of the so(2) element \texttt{OMEGA} that
yields a rotation matrix ($2 \times 2$).



\texttt{R = TREXP2(THETA)} as above, but rotation by \texttt{THETA} ($1 \times 1$).


\subsection*{$\mbox{SE}(2)$}


\texttt{T = TREXP2(SIGMA)} is the matrix exponential ($3 \times 3$) of the se(2) element
\texttt{SIGMA} that yields a homogeneous transformation  matrix ($3 \times 3$).



\texttt{T = TREXP2(SIGMA, THETA)} as above, but se(2) rotation of \texttt{SIGMA}*\texttt{THETA}, the
rotation part of \texttt{SIGMA} ($3 \times 3$) must be unit norm.



\texttt{T = TREXP2(TW)} as above, but the se(2) value is expressed as a vector \texttt{TW}
($1 \times 3$).



\texttt{T = TREXP(TW, THETA)} as above, but se(2) rotation of \texttt{TW}*\texttt{THETA}, the
rotation part of \texttt{TW} must be unit norm.


\subsection*{Notes}
\begin{itemize}
  \item Efficient closed-form solution of the matrix exponential for arguments that are    so(2) or se(2).
  \item If \texttt{THETA} is given then the first argument must be a unit vector or a    skew-symmetric matrix from a unit vector.
\end{itemize}

\subsection*{References}
\begin{itemize}
  \item Robotics, Vision \& Control: Second Edition, P. Corke, Springer 2016; p25-26.
  \item Mechanics, planning and control, Park \& Lynch, Cambridge, 2017.
\end{itemize}

\subsection*{See also}


\hyperlink{trexp}{\color{blue} trexp}, \hyperlink{skew}{\color{blue} skew}, \hyperlink{skewa}{\color{blue} skewa}, \hyperlink{Twist}{\color{blue} Twist}

\vspace{1.5ex}\rule{\textwidth}{1mm}

%---------------------- trinterp
\hypertarget{trinterp}{\section*{trinterp}}
\subsection*{Interpolate $\mbox{SE}(3)$ homogeneous transformations}
\addcontentsline{toc}{section}{trinterp}


\texttt{TRINTERP(T0, T1, S)} is a homogeneous transform ($4 \times 4$) interpolated
between \texttt{T0} when \texttt{S}=0 and \texttt{T1} when \texttt{S}=1.  \texttt{T0} and \texttt{T1} are both homogeneous
transforms ($4 \times 4$).  If \texttt{S} ($N \times 1$) then T ($4 \times 4 \times N$) is a sequence of
homogeneous transforms corresponding to the interpolation values in \texttt{S}.



\texttt{TRINTERP(T1, S)} as above but interpolated between the identity matrix
when \texttt{S}=0 to \texttt{T1} when \texttt{S}=1.



\texttt{TRINTERP(T0, T1, M)} as above but \texttt{M} is a positive integer and return a
sequence ($4 \times 4 \times \texttt{M}$) of homogeneous transforms linearly interpolating between
\texttt{T0} and \texttt{T1} in \texttt{M} steps.



\texttt{TRINTERP(T1, M)} as above but return a sequence ($4 \times 4 \times \texttt{M}$) of
homogeneous interpolating between identity matrix and \texttt{T1} in \texttt{M} steps.


\subsection*{Notes}
\begin{itemize}
  \item \texttt{T0} or \texttt{T1} can also be an $\mbox{SO}(3)$ rotation matrix ($3 \times 3$) in which case the    result is ($3 \times 3 \times N$).
  \item Rotation is interpolated using quaternion spherical linear interpolation (slerp).
  \item To obtain smooth continuous motion \texttt{S} should also be smooth and continuous,    such as computed by tpoly or lspb.
\end{itemize}

\subsection*{See also}


\hyperlink{trinterp2}{\color{blue} trinterp2}, \hyperlink{ctraj}{\color{blue} ctraj}, \hyperlink{SE3.interp}{\color{blue} SE3.interp}, \hyperlink{UnitQuaternion}{\color{blue} UnitQuaternion}, \hyperlink{tpoly}{\color{blue} tpoly}, \hyperlink{lspb}{\color{blue} lspb}

\vspace{1.5ex}\rule{\textwidth}{1mm}

%---------------------- trinterp2
\hypertarget{trinterp2}{\section*{trinterp2}}
\subsection*{Interpolate $\mbox{SE}(2)$ homogeneous transformations}
\addcontentsline{toc}{section}{trinterp2}


\texttt{TRINTERP2(T0, T1, S)} is a homogeneous transform ($3 \times 3$) interpolated
between \texttt{T0} when \texttt{S}=0 and \texttt{T1} when \texttt{S}=1.  \texttt{T0} and \texttt{T1} are both homogeneous
transforms ($4 \times 4$).  If \texttt{S} ($N \times 1$) then T ($3 \times 3 \times N$) is a sequence of
homogeneous transforms corresponding to the interpolation values in \texttt{S}.



\texttt{TRINTERP2(T1, S)} as above but interpolated between the identity matrix
when \texttt{S}=0 to \texttt{T1} when \texttt{S}=1.



\texttt{TRINTERP2(T0, T1, M)} as above but \texttt{M} is a positive integer and return a
sequence ($4 \times 4 \times \texttt{M}$) of homogeneous transforms linearly interpolating between
\texttt{T0} and \texttt{T1} in \texttt{M} steps.



\texttt{TRINTERP2(T1, M)} as above but return a sequence ($4 \times 4 \times \texttt{M}$) of
homogeneous interpolating between identity matrix and \texttt{T1} in \texttt{M} steps.


\subsection*{Notes}
\begin{itemize}
  \item \texttt{T0} or \texttt{T1} can also be an $\mbox{SO}(2)$ rotation matrix ($2 \times 2$).
  \item Rotation angle is linearly interpolated.
  \item To obtain smooth continuous motion \texttt{S} should also be smooth and continuous,    such as computed by tpoly or lspb.
\end{itemize}

\subsection*{See also}


\hyperlink{trinterp}{\color{blue} trinterp}, \hyperlink{SE3.interp}{\color{blue} SE3.interp}, \hyperlink{UnitQuaternion}{\color{blue} UnitQuaternion}, \hyperlink{tpoly}{\color{blue} tpoly}, \hyperlink{lspb}{\color{blue} lspb}

\vspace{1.5ex}\rule{\textwidth}{1mm}

%---------------------- trlog
\hypertarget{trlog}{\section*{trlog}}
\subsection*{Logarithm of $\mbox{SO}(3)$ or $\mbox{SE}(3)$ matrix}
\addcontentsline{toc}{section}{trlog}


\texttt{S = trlog(R)} is the matrix logarithm ($3 \times 3$) of \texttt{R} ($3 \times 3$) which is a skew
symmetric matrix corresponding to the vector theta*w where theta is the
rotation angle and w ($3 \times 1$) is a unit-vector indicating the rotation axis.



\texttt{[theta,w] = trlog(R)} as above but returns directly \texttt{theta} the rotation
angle and \texttt{w} ($3 \times 1$) the unit-vector indicating the rotation axis.



\texttt{S = trlog(T)} is the matrix logarithm ($4 \times 4$) of \texttt{T} ($4 \times 4$) which has a
skew-symmetric upper-left $3 \times 3$ submatrix corresponding to the vector
\texttt{theta}*\texttt{w} where \texttt{theta} is the rotation angle and \texttt{w} ($3 \times 1$) is a unit-vector
indicating the rotation axis, and a translation component.



\texttt{[theta,twist] = trlog(T)} as above but returns directly \texttt{theta} the rotation
angle and a \texttt{twist} vector ($6 \times 1$) comprising [v \texttt{w}].


\subsection*{Notes}
\begin{itemize}
  \item Efficient closed-form solution of the matrix logarithm for arguments that are    $\mbox{SO}(3)$ or $\mbox{SE}(3)$.
  \item Special cases of rotation by odd multiples of $\pi$ are handled.
  \item Angle is always in the interval [0,$\pi$].
  \item There is no Toolbox function for $\mbox{SO}(2)$ or $\mbox{SE}(2)$, use LOGM instead.
\end{itemize}

\subsection*{References}
\begin{itemize}
  \item Robotics, Vision \& Control: Second Edition, P. Corke, Springer 2016; p43.
  \item Mechanics, planning and control, Park \& Lynch, Cambridge, 2016.
\end{itemize}

\subsection*{See also}


\hyperlink{trexp}{\color{blue} trexp}, \hyperlink{trexp2}{\color{blue} trexp2}, \hyperlink{Twist}{\color{blue} Twist}, \hyperlink{logm}{\color{blue} logm}

\vspace{1.5ex}\rule{\textwidth}{1mm}

%---------------------- trnorm
\hypertarget{trnorm}{\section*{trnorm}}
\subsection*{Normalize an $\mbox{SO}(3)$ or $\mbox{SE}(3)$ matrix}
\addcontentsline{toc}{section}{trnorm}


\texttt{TRNORM(R)} is guaranteed to be a proper orthogonal matrix rotation
matrix ($3 \times 3$) which is ``close'' to the input matrix \texttt{R} ($3 \times 3$). If \texttt{R}
= [N,O,A] the O and A vectors are made unit length and the normal vector
is formed from N = O x A, and then we ensure that O and A are orthogonal
by O = A x N.



\texttt{TRNORM(T)} as above but the rotational submatrix of the homogeneous
transformation \texttt{T} ($4 \times 4$) is normalised while the translational part is
unchanged.



If \texttt{R} ($3 \times 3 \times K$) or \texttt{T} ($4 \times 4 \times K$) representing a sequence then the normalisation
is performed on each of the K planes.


\subsection*{Notes}
\begin{itemize}
  \item Only the direction of A (the z-axis) is unchanged.
  \item Used to prevent finite word length arithmetic causing transforms to    become `unnormalized\textquotesingle .
  \item There is no Toolbox function for $\mbox{SO}(2)$ or $\mbox{SE}(2)$.
\end{itemize}

\subsection*{See also}


\hyperlink{oa2tr}{\color{blue} oa2tr}, \hyperlink{SO3.trnorm}{\color{blue} SO3.trnorm}, \hyperlink{SE3.trnorm}{\color{blue} SE3.trnorm}

\vspace{1.5ex}\rule{\textwidth}{1mm}

%---------------------- trot2
\hypertarget{trot2}{\section*{trot2}}
\subsection*{$\mbox{SE}(2)$ rotation matrix}
\addcontentsline{toc}{section}{trot2}


\texttt{T = TROT2(THETA)} is a homogeneous transformation ($3 \times 3$) representing a rotation
of \texttt{THETA} radians.



\texttt{T = TROT2(THETA, 'deg')} as above but \texttt{THETA} is in degrees.


\subsection*{Notes}
\begin{itemize}
  \item Translational component is zero.
\end{itemize}

\subsection*{See also}


\hyperlink{rot2}{\color{blue} rot2}, \hyperlink{transl2}{\color{blue} transl2}, \hyperlink{ishomog2}{\color{blue} ishomog2}, \hyperlink{trplot2}{\color{blue} trplot2}, \hyperlink{trotx}{\color{blue} trotx}, \hyperlink{troty}{\color{blue} troty}, \hyperlink{trotz}{\color{blue} trotz}, \hyperlink{SE2}{\color{blue} SE2}

\vspace{1.5ex}\rule{\textwidth}{1mm}

%---------------------- trotx
\hypertarget{trotx}{\section*{trotx}}
\subsection*{$\mbox{SE}(3)$ rotation about X axis}
\addcontentsline{toc}{section}{trotx}


\texttt{T = TROTX(THETA)} is a homogeneous transformation ($4 \times 4$) representing a rotation
of \texttt{THETA} radians about the x-axis.



\texttt{T = TROTX(THETA, 'deg')} as above but \texttt{THETA} is in degrees.


\subsection*{Notes}
\begin{itemize}
  \item Translational component is zero.
\end{itemize}

\subsection*{See also}


\hyperlink{rotx}{\color{blue} rotx}, \hyperlink{troty}{\color{blue} troty}, \hyperlink{trotz}{\color{blue} trotz}, \hyperlink{trot2}{\color{blue} trot2}, \hyperlink{SE3.Rx}{\color{blue} SE3.Rx}

\vspace{1.5ex}\rule{\textwidth}{1mm}

%---------------------- troty
\hypertarget{troty}{\section*{troty}}
\subsection*{$\mbox{SE}(3)$ rotation about Y axis}
\addcontentsline{toc}{section}{troty}


\texttt{T = troty(THETA)} is a homogeneous transformation ($4 \times 4$) representing a rotation
of \texttt{THETA} radians about the y-axis.



\texttt{T = troty(THETA, 'deg')} as above but \texttt{THETA} is in degrees.


\subsection*{Notes}
\begin{itemize}
  \item Translational component is zero.
\end{itemize}

\subsection*{See also}


\hyperlink{roty}{\color{blue} roty}, \hyperlink{trotx}{\color{blue} trotx}, \hyperlink{trotz}{\color{blue} trotz}, \hyperlink{trot2}{\color{blue} trot2}, \hyperlink{SE3.Ry}{\color{blue} SE3.Ry}

\vspace{1.5ex}\rule{\textwidth}{1mm}

%---------------------- trotz
\hypertarget{trotz}{\section*{trotz}}
\subsection*{$\mbox{SE}(3)$ rotation about Z axis}
\addcontentsline{toc}{section}{trotz}


\texttt{T = trotz(THETA)} is a homogeneous transformation ($4 \times 4$) representing a rotation
of \texttt{THETA} radians about the z-axis.



\texttt{T = trotz(THETA, 'deg')} as above but \texttt{THETA} is in degrees.


\subsection*{Notes}
\begin{itemize}
  \item Translational component is zero.
\end{itemize}

\subsection*{See also}


\hyperlink{rotz}{\color{blue} rotz}, \hyperlink{trotx}{\color{blue} trotx}, \hyperlink{troty}{\color{blue} troty}, \hyperlink{trot2}{\color{blue} trot2}, \hyperlink{SE3.Rz}{\color{blue} SE3.Rz}

\vspace{1.5ex}\rule{\textwidth}{1mm}

%---------------------- trplot
\hypertarget{trplot}{\section*{trplot}}
\subsection*{Plot a 3D coordinate frame}
\addcontentsline{toc}{section}{trplot}


\texttt{TRPLOT(T, OPTIONS)} draws a 3D coordinate frame represented by the $\mbox{SE}(3)$ homogeneous
transform \texttt{T} ($4 \times 4$).



\texttt{H = TRPLOT(T, OPTIONS)} as above but returns a handle.



\texttt{TRPLOT(R, OPTIONS)} as above but the coordinate frame is rotated about the
origin according to the orthonormal rotation matrix \texttt{R} ($3 \times 3$).



\texttt{H = TRPLOT(R, OPTIONS)} as above but returns a handle.



\texttt{H = TRPLOT()} creates a default frame EYE(3,3) at the origin and returns a
handle.


\subsection*{Animation}


Firstly, create a plot and keep the the handle as per above.



\texttt{TRPLOT(H, T)} moves the coordinate frame described by the handle \texttt{H} to
the pose \texttt{T} ($4 \times 4$).


\subsection*{Options}
\begin{longtable}{lp{120mm}}
\textquotesingle handle\textquotesingle ,h & Update the specified handle\\ 
\textquotesingle axhandle\textquotesingle ,A & Draw in the MATLAB axes specified by the axis handle A\\ 
 & \\ 
\textquotesingle color\textquotesingle ,C & The color to draw the axes, MATLAB ColorSpec\\ 
\textquotesingle axes\textquotesingle  & Show the MATLAB axes, box and ticks (default true)\\ 
\textquotesingle axis\textquotesingle ,A & Set dimensions of the MATLAB axes to A=[xmin xmax ymin ymax zmin zmax]\\ 
\textquotesingle frame\textquotesingle ,F & The coordinate frame is named $\{$F$\}$ and the subscript on the axis labels is F.\\ 
\textquotesingle framelabel\textquotesingle ,F & The coordinate frame is named $\{$F$\}$, axes have no subscripts.\\ 
\textquotesingle framelabeloffset\textquotesingle ,O & Offset O=[DX DY] frame labels in units of text box height\\ 
\textquotesingle text\_opts\textquotesingle , opt & A cell array of MATLAB text properties\\ 
\textquotesingle length\textquotesingle ,s & Length of the coordinate frame arms (default 1)\\ 
\textquotesingle thick\textquotesingle ,t & Thickness of lines (default 0.5)\\ 
\textquotesingle text\textquotesingle  & Enable display of X,Y,Z labels on the frame (default true)\\ 
\textquotesingle labels\textquotesingle ,L & Label the X,Y,Z axes with the 1st, 2nd, 3rd character of the string L\\ 
\textquotesingle rgb\textquotesingle  & Display X,Y,Z axes in colors red, green, blue respectively\\ 
\textquotesingle rviz\textquotesingle  & Display chunky rviz style axes\%\\ 
\textquotesingle arrow\textquotesingle  & Use arrows rather than line segments for the axes\\ 
\textquotesingle width\textquotesingle , w & Width of arrow tips (default 1)\\ 
 & \\ 
\textquotesingle perspective\textquotesingle  & Display the axes with perspective projection (default off)\\ 
\textquotesingle 3d\textquotesingle  & Plot in 3D using anaglyph graphics\\ 
\textquotesingle anaglyph\textquotesingle ,A                         left and right (default colors \textquotesingle rc\textquotesingle ): chosen from & Specify anaglyph colors for \textquotesingle 3d\textquotesingle  as 2 characters for\\ 
 & r)ed, g)reen, b)lue, c)yan, m)agenta.\\ 
\textquotesingle dispar\textquotesingle ,D & Disparity for 3d display (default 0.1)\\ 
\textquotesingle view\textquotesingle ,V                         for view toward origin of coordinate frame & Set plot view parameters V=[az el] angles, or \textquotesingle auto\textquotesingle \\ 
\textquotesingle lefty\textquotesingle  & Draw left-handed frame (dangerous)\\ 
\end{longtable}\vspace{1ex}

\subsection*{Examples}


\texttt{trplot(T, 'frame', 'A')}
trplot(\texttt{T}, \textquotesingle frame\textquotesingle , \textquotesingle A\textquotesingle , \textquotesingle color\textquotesingle , \textquotesingle b\textquotesingle )
trplot(T1, \textquotesingle frame\textquotesingle , \textquotesingle A\textquotesingle , \textquotesingle text\_opts\textquotesingle , $\{$\textquotesingle FontSize\textquotesingle , 10, \textquotesingle FontWeight\textquotesingle , \textquotesingle bold\textquotesingle $\}$)
trplot(T1, \textquotesingle labels\textquotesingle , \textquotesingle NOA\textquotesingle );



\texttt{h = trplot(T, 'frame', 'A', 'color', 'b')};
trplot(\texttt{h}, T2);



3D anaglyph plot



\texttt{trplot(T, '3d')};


\subsection*{Notes}
\begin{itemize}
  \item Multiple frames can be added using the HOLD command
  \item When animating a coordinate frame it is best to set the axis bounds initially.
  \item The \textquotesingle rviz\textquotesingle  option is equivalent to \textquotesingle rgb\textquotesingle , \textquotesingle notext\textquotesingle , \textquotesingle noarrow\textquotesingle ,    \textquotesingle thick\textquotesingle , 5.
  \item The \textquotesingle arrow\textquotesingle  option requires \url{https://www.mathworks.com/matlabcentral/fileexchange/14056-arrow3}
\end{itemize}
\vspace{1.5ex}\rule{\textwidth}{1mm}

%---------------------- trplot2
\hypertarget{trplot2}{\section*{trplot2}}
\subsection*{Plot a 2D coordinate frame}
\addcontentsline{toc}{section}{trplot2}


\texttt{TRPLOT2(T, OPTIONS)} draws a 2D coordinate frame represented by the $\mbox{SE}(2)$
homogeneous transform \texttt{T} ($3 \times 3$).



\texttt{H = TRPLOT2(T, OPTIONS)} as above but returns a handle.



\texttt{TRPLOT(R, OPTIONS)} as above but the coordinate frame is rotated about the
origin according to the orthonormal rotation matrix \texttt{R} ($2 \times 2$).



\texttt{H = TRPLOT(R, OPTIONS)} as above but returns a handle.



\texttt{H = TRPLOT2()} creates a default frame EYE(2,2) at the origin and returns a
handle.


\subsection*{Animation}


Firstly, create a plot and keep the the handle as per above.



\texttt{TRPLOT2(H, T)} moves the coordinate frame described by the handle \texttt{H} to
the $\mbox{SE}(2)$ pose \texttt{T} ($3 \times 3$).


\subsection*{Options}
\begin{longtable}{lp{120mm}}
\textquotesingle handle\textquotesingle ,h & Update the specified handle\\ 
\textquotesingle axhandle\textquotesingle ,A & Draw in the MATLAB axes specified by the axis handle A\\ 
 & \\ 
\textquotesingle color\textquotesingle , c & The color to draw the axes, MATLAB ColorSpec\\ 
\textquotesingle axes\textquotesingle  & Show the MATLAB axes, box and ticks (default true)\\ 
\textquotesingle axis\textquotesingle ,A & Set dimensions of the MATLAB axes to A=[xmin xmax ymin ymax]\\ 
\textquotesingle frame\textquotesingle ,F & The frame is named $\{$F$\}$ and the subscript on the axis labels is F.\\ 
\textquotesingle framelabel\textquotesingle ,F & The coordinate frame is named $\{$F$\}$, axes have no subscripts.\\ 
\textquotesingle framelabeloffset\textquotesingle ,O & Offset O=[DX DY] frame labels in units of text box height\\ 
\textquotesingle text\_opts\textquotesingle , opt & A cell array of Matlab text properties\\ 
\textquotesingle length\textquotesingle ,s & Length of the coordinate frame arms (default 1)\\ 
\textquotesingle thick\textquotesingle ,t & Thickness of lines (default 0.5)\\ 
\textquotesingle text\textquotesingle  & Enable display of X,Y,Z labels on the frame (default true)\\ 
\textquotesingle labels\textquotesingle ,L & Label the X,Y,Z axes with the 1st and 2nd character of the string L\\ 
\textquotesingle arrow\textquotesingle  & Use arrows rather than line segments for the axes\\ 
\textquotesingle width\textquotesingle , w & Width of arrow tips\\ 
\textquotesingle lefty\textquotesingle  & Draw left-handed frame (dangerous)\\ 
\end{longtable}\vspace{1ex}

\subsection*{Examples}


\texttt{trplot2(T, 'frame', 'A')}
trplot2(\texttt{T}, \textquotesingle frame\textquotesingle , \textquotesingle A\textquotesingle , \textquotesingle color\textquotesingle , \textquotesingle b\textquotesingle )
trplot2(T1, \textquotesingle frame\textquotesingle , \textquotesingle A\textquotesingle , \textquotesingle text\_opts\textquotesingle , $\{$\textquotesingle FontSize\textquotesingle , 10, \textquotesingle FontWeight\textquotesingle , \textquotesingle bold\textquotesingle $\}$)


\subsection*{Notes}
\begin{itemize}
  \item Multiple frames can be added using the HOLD command
  \item When animating a coordinate frame it is best to set the axis bounds initially.
  \item The \textquotesingle arrow\textquotesingle  option requires \url{https://www.mathworks.com/matlabcentral/fileexchange/14056-arrow3}
\end{itemize}

\subsection*{See also}


\hyperlink{trplot}{\color{blue} trplot}

\vspace{1.5ex}\rule{\textwidth}{1mm}

%---------------------- trprint
\hypertarget{trprint}{\section*{trprint}}
\subsection*{Compact display of $\mbox{SE}(3)$ homogeneous transformation}
\addcontentsline{toc}{section}{trprint}


\texttt{TRPRINT(T, OPTIONS)} displays the homogoneous transform ($4 \times 4$) in a compact
single-line format.  If \texttt{T} is a homogeneous transform sequence then each
element is printed on a separate line.



\texttt{TRPRINT(R, OPTIONS)} as above but displays the $\mbox{SO}(3)$ rotation matrix ($3 \times 3$).



\texttt{S = TRPRINT(T, OPTIONS)} as above but returns the string.



TRPRINT \texttt{T}  is the command line form of above, and displays in RPY format.


\subsection*{Options}
\begin{longtable}{lp{120mm}}
\textquotesingle rpy\textquotesingle  & display with rotation in ZYX roll/pitch/yaw angles (default)\\ 
\textquotesingle xyz\textquotesingle  & change RPY angle sequence to XYZ\\ 
\textquotesingle yxz\textquotesingle  & change RPY angle sequence to YXZ\\ 
\textquotesingle euler\textquotesingle  & display with rotation in ZYZ Euler angles\\ 
\textquotesingle angvec\textquotesingle  & display with rotation in angle/vector format\\ 
\textquotesingle radian\textquotesingle  & display angle in radians (default is degrees)\\ 
\textquotesingle fmt\textquotesingle , f & use format string f for all numbers, (default \%g)\\ 
\textquotesingle label\textquotesingle ,l & display the text before the transform\\ 
\end{longtable}\vspace{1ex}

\subsection*{Examples}
\begin{Code}
  >> trprint(T2)
  t = (0,0,0), RPY/zyx = (-122.704,65.4084,-8.11266) deg

  >> trprint(T1, 'label', 'A')
\end{Code}
\begin{Code}
         A:t = (0,0,0), RPY/zyx = (-0,0,-0) deg

\end{Code}

\subsection*{Notes}
\begin{itemize}
  \item If the \textquotesingle rpy\textquotesingle  option is selected, then the particular angle sequence can be    specified with the options \textquotesingle xyz\textquotesingle  or \textquotesingle yxz\textquotesingle  which are passed through to TR2RPY.
\end{itemize}


\textquotesingle zyx\textquotesingle  is the default.


\subsection*{See also}


\hyperlink{tr2eul}{\color{blue} tr2eul}, \hyperlink{tr2rpy}{\color{blue} tr2rpy}, \hyperlink{tr2angvec}{\color{blue} tr2angvec}

\vspace{1.5ex}\rule{\textwidth}{1mm}

%---------------------- trprint2
\hypertarget{trprint2}{\section*{trprint2}}
\subsection*{Compact display of $\mbox{SE}(2)$ homogeneous transformation}
\addcontentsline{toc}{section}{trprint2}


\texttt{TRPRINT2(T, OPTIONS)} displays the homogoneous transform ($3 \times 3$) in a compact
single-line format.  If \texttt{T} is a homogeneous transform sequence then each
element is printed on a separate line.



\texttt{TRPRINT2(R, OPTIONS)} as above but displays the $\mbox{SO}(2)$ rotation matrix ($3 \times 3$).



\texttt{S = TRPRINT2(T, OPTIONS)} as above but returns the string.



TRPRINT2 \texttt{T}  is the command line form of above, and displays in RPY format.


\subsection*{Options}
\begin{longtable}{lp{120mm}}
\textquotesingle radian\textquotesingle  & display angle in radians (default is degrees)\\ 
\textquotesingle fmt\textquotesingle , f & use format string f for all numbers, (default \%g)\\ 
\textquotesingle label\textquotesingle ,l & display the text before the transform\\ 
\end{longtable}\vspace{1ex}

\subsection*{Examples}
\begin{Code}
  >> trprint2(T2)
  t = (0,0), theta = -122.704 deg

\end{Code}

\subsection*{See also}


\hyperlink{trprint}{\color{blue} trprint}

\vspace{1.5ex}\rule{\textwidth}{1mm}

%---------------------- trscale
\hypertarget{trscale}{\section*{trscale}}
\subsection*{Homogeneous transformation for pure scale}
\addcontentsline{toc}{section}{trscale}


\texttt{T = TRSCALE(S)} is a homogeneous transform ($4 \times 4$) corresponding to a pure
scale change.  If \texttt{S} is a scalar the same scale factor is used for x,y,z,
else it can be a 3-vector specifying scale in the x-, y- and
z-directions.


\subsection*{Note}
\begin{itemize}
  \item This matrix does not belong to $\mbox{SE}(3)$ and should not be compounded with    any $\mbox{SE}(3)$ matrix.
\end{itemize}
\vspace{1.5ex}\rule{\textwidth}{1mm}

%---------------------- Twist
\hypertarget{Twist}{\section*{Twist}}
\subsection*{$\mbox{SE}(2)$ and $\mbox{SE}(3)$ Twist class}
\addcontentsline{toc}{section}{Twist}


A Twist class holds the parameters of a twist, a representation of a
rigid body displacement in $\mbox{SE}(2)$ or $\mbox{SE}(3)$.


\subsection*{Methods}
\begin{longtable}{lp{120mm}}
S & twist vector ($1 \times 3$ or $1 \times 6$)\\ 
se & twist as (augmented) skew-symmetric matrix ($3 \times 3$ or $4 \times 4$)\\ 
T & convert to homogeneous transformation ($3 \times 3$ or $4 \times 4$)\\ 
R & convert rotational part to matrix ($2 \times 2$ or $3 \times 3$)\\ 
exp & synonym for T\\ 
ad & logarithm of adjoint\\ 
pitch & pitch of the screw, $\mbox{SE}(3)$ only\\ 
pole & a point on the line of the screw\\ 
prod & product of a vector of Twists\\ 
theta & rotation about the screw\\ 
line & Plucker line object representing line of the screw\\ 
display & print the Twist parameters in human readable form\\ 
char & convert to string\\ 
\end{longtable}\vspace{1ex}

\subsection*{Conversion methods}
\begin{longtable}{lp{120mm}}
SE & convert to SE2 or SE3 object\\ 
double & convert to real vector\\ 
\end{longtable}\vspace{1ex}

\subsection*{Overloaded operators}
\begin{longtable}{lp{120mm}}
\textasteriskcentered  & compose two Twists\\ 
\textasteriskcentered  & multiply Twist by a scalar\\ 
\end{longtable}\vspace{1ex}

\subsection*{Properties (read only)}
\begin{longtable}{lp{120mm}}
v & moment part of twist ($2 \times 1$ or $3 \times 1$)\\ 
w & direction part of twist ($1 \times 1$ or $3 \times 1$)\\ 
\end{longtable}\vspace{1ex}

\subsection*{References}
\begin{itemize}
  \item ``Mechanics, planning and control''    Park \& Lynch, Cambridge, 2016.
\end{itemize}

\subsection*{See also}


\hyperlink{trexp}{\color{blue} trexp}, \hyperlink{trexp2}{\color{blue} trexp2}, \hyperlink{trlog}{\color{blue} trlog}

\vspace{1.5ex}\hrule

%---------------------- Twist.Twist
\hypertarget{Twist.Twist}{\section*{Twist.Twist}}
\subsection*{Create Twist object}
\addcontentsline{tom}{section}{Twist.Twist}


\texttt{TW = Twist(T)} is a \textbf{\color{red} Twist} object representing the $\mbox{SE}(2)$ or $\mbox{SE}(3)$
homogeneous transformation matrix \texttt{T} ($3 \times 3$ or $4 \times 4$).



\texttt{TW = Twist(V)} is a twist object where the vector is specified directly.



3D CASE::



\texttt{TW = Twist('R', A, Q)} is a \textbf{\color{red} Twist} object representing rotation about the
axis of direction \texttt{A} ($3 \times 1$) and passing through the point \texttt{Q} ($3 \times 1$).



\texttt{TW = Twist('R', A, Q, P)} as above but with a pitch of \texttt{P} (distance/angle).



\texttt{TW = Twist('T', A)} is a \textbf{\color{red} Twist} object representing translation in the
direction of \texttt{A} ($3 \times 1$).



2D CASE::



\texttt{TW = Twist('R', Q)} is a \textbf{\color{red} Twist} object representing rotation about the point \texttt{Q} ($2 \times 1$).



\texttt{TW = Twist('T', A)} is a \textbf{\color{red} Twist} object representing translation in the
direction of \texttt{A} ($2 \times 1$).


\subsection*{Notes}


The argument \textquotesingle \texttt{P}\textquotesingle  for prismatic is synonymous with \textquotesingle \texttt{T}\textquotesingle .

\vspace{1.5ex}\hrule

%---------------------- Twist.ad
\hypertarget{Twist.ad}{\section*{Twist.ad}}
\subsection*{Logarithm of adjoint}
\addcontentsline{tom}{section}{Twist.ad}


\texttt{TW.ad} is the logarithm of the adjoint matrix of the corresponding
homogeneous transformation.


\subsection*{See also}


\hyperlink{SE3.Ad}{\color{blue} SE3.Ad}

\vspace{1.5ex}\hrule

%---------------------- Twist.Ad
\hypertarget{Twist.Ad}{\section*{Twist.Ad}}
\subsection*{Adjoint}
\addcontentsline{tom}{section}{Twist.Ad}


\texttt{TW.Ad} is the adjoint matrix of the corresponding
homogeneous transformation.


\subsection*{See also}


\hyperlink{SE3.Ad}{\color{blue} SE3.Ad}

\vspace{1.5ex}\hrule

%---------------------- Twist.char
\hypertarget{Twist.char}{\section*{Twist.char}}
\subsection*{Convert to string}
\addcontentsline{tom}{section}{Twist.char}


\texttt{s = TW.char()} is a string showing \textbf{\color{red} Twist} parameters in a compact single line format.
If TW is a vector of Twist objects return a string with one line per Twist.


\subsection*{See also}


\hyperlink{Twist.display}{\color{blue} Twist.display}

\vspace{1.5ex}\hrule

%---------------------- Twist.display
\hypertarget{Twist.display}{\section*{Twist.display}}
\subsection*{Display parameters}
\addcontentsline{tom}{section}{Twist.display}


\texttt{L.display()} displays the twist parameters in compact single line format.  If L is a
vector of Twist objects displays one line per element.


\subsection*{Notes}
\begin{itemize}
  \item This method is invoked implicitly at the command line when the result    of an expression is a Twist object and the command has no trailing
  \item semicolon.
\end{itemize}

\subsection*{See also}


\hyperlink{Twist.char}{\color{blue} Twist.char}

\vspace{1.5ex}\hrule

%---------------------- Twist.double
\hypertarget{Twist.double}{\section*{Twist.double}}
\subsection*{Return the twist vector}
\addcontentsline{tom}{section}{Twist.double}


\texttt{double(TW)} is the twist vector in se(2) or se(3) as a vector ($3 \times 1$ or
$6 \times 1$). If \texttt{TW} is a vector ($1 \times N$) of Twists the result is a matrix ($6 \times N$) with
one column per twist.


\subsection*{Notes}
\begin{itemize}
  \item Sometimes referred to as the twist coordinate vector.
\end{itemize}
\vspace{1.5ex}\hrule

%---------------------- Twist.exp
\hypertarget{Twist.exp}{\section*{Twist.exp}}
\subsection*{Convert twist to homogeneous transformation}
\addcontentsline{tom}{section}{Twist.exp}


\texttt{TW.exp} is the homogeneous transformation equivalent to the twist (SE2 or SE3).



\texttt{TW.exp(THETA)} as above but with a rotation of \texttt{THETA} about the twist.


\subsection*{Notes}
\begin{itemize}
  \item For the second form the twist must, if rotational, have a unit rotational component.
\end{itemize}

\subsection*{See also}


\hyperlink{Twist.T}{\color{blue} Twist.T}, \hyperlink{trexp}{\color{blue} trexp}, \hyperlink{trexp2}{\color{blue} trexp2}

\vspace{1.5ex}\hrule

%---------------------- Twist.line
\hypertarget{Twist.line}{\section*{Twist.line}}
\subsection*{Line of twist axis in Plucker form}
\addcontentsline{tom}{section}{Twist.line}


\texttt{TW.line} is a Plucker object representing the \texttt{line} of the twist axis.


\subsection*{Notes}
\begin{itemize}
  \item For 3D case only.
\end{itemize}

\subsection*{See also}


\hyperlink{Plucker}{\color{blue} Plucker}

\vspace{1.5ex}\hrule

%---------------------- Twist.mtimes
\hypertarget{Twist.mtimes}{\section*{Twist.mtimes}}
\subsection*{Multiply twist by twist or scalar}
\addcontentsline{tom}{section}{Twist.mtimes}


\texttt{TW1 * TW2} is a new \textbf{\color{red} Twist} representing the composition of twists \texttt{TW1} and
\texttt{TW2}.



\texttt{TW * T} is an SE2 or SE3 that is the composition of the twist \texttt{TW} and the
homogeneous transformation object \texttt{T}.



\texttt{TW * S} with its twist coordinates scaled by scalar \texttt{S}.



\texttt{TW * T} compounds a twist with an SE2/3 transformation

\vspace{1.5ex}\hrule

%---------------------- Twist.pitch
\hypertarget{Twist.pitch}{\section*{Twist.pitch}}
\subsection*{Pitch of the twist}
\addcontentsline{tom}{section}{Twist.pitch}


\texttt{TW.pitch} is the \texttt{pitch} of the \textbf{\color{red} Twist} as a scalar in units of distance per radian.


\subsection*{Notes}
\begin{itemize}
  \item For 3D case only.
\end{itemize}
\vspace{1.5ex}\hrule

%---------------------- Twist.pole
\hypertarget{Twist.pole}{\section*{Twist.pole}}
\subsection*{Point on the twist axis}
\addcontentsline{tom}{section}{Twist.pole}


\texttt{TW.pole} is a point on the twist axis ($2 \times 1$ or $3 \times 1$).


\subsection*{Notes}
\begin{itemize}
  \item For pure translation this point is at infinity.
\end{itemize}
\vspace{1.5ex}\hrule

%---------------------- Twist.prod
\hypertarget{Twist.prod}{\section*{Twist.prod}}
\subsection*{Compound array of twists}
\addcontentsline{tom}{section}{Twist.prod}


\texttt{TW.prod} is a twist representing the product (composition) of the
successive elements of \texttt{TW} ($1 \times N$), an array of Twists.


\subsection*{See also}


\hyperlink{RTBPose.prod}{\color{blue} RTBPose.prod}, \hyperlink{Twist.mtimes}{\color{blue} Twist.mtimes}

\vspace{1.5ex}\hrule

%---------------------- Twist.S
\hypertarget{Twist.S}{\section*{Twist.S}}
\subsection*{Return the twist vector}
\addcontentsline{tom}{section}{Twist.S}


\texttt{TW.S} is the twist vector in se(2) or se(3) as a vector ($3 \times 1$ or $6 \times 1$).


\subsection*{Notes}
\begin{itemize}
  \item Sometimes referred to as the twist coordinate vector.
\end{itemize}
\vspace{1.5ex}\hrule

%---------------------- Twist.SE
\hypertarget{Twist.SE}{\section*{Twist.SE}}
\subsection*{Convert twist to SE2 or SE3 object}
\addcontentsline{tom}{section}{Twist.SE}


\texttt{TW.SE} is an SE2 or SE3 object representing the homogeneous transformation equivalent to the twist.


\subsection*{See also}


\hyperlink{Twist.T}{\color{blue} Twist.T}, \hyperlink{SE2}{\color{blue} SE2}, \hyperlink{SE3}{\color{blue} SE3}

\vspace{1.5ex}\hrule

%---------------------- Twist.se
\hypertarget{Twist.se}{\section*{Twist.se}}
\subsection*{Return the twist matrix}
\addcontentsline{tom}{section}{Twist.se}


\texttt{TW.se} is the twist matrix in \texttt{se}(2) or \texttt{se}(3) which is an augmented
skew-symmetric matrix ($3 \times 3$ or $4 \times 4$).

\vspace{1.5ex}\hrule

%---------------------- Twist.T
\hypertarget{Twist.T}{\section*{Twist.T}}
\subsection*{Convert twist to homogeneous transformation}
\addcontentsline{tom}{section}{Twist.T}


\texttt{TW.T} is the homogeneous transformation equivalent to the twist ($3 \times 3$ or $4 \times 4$).



\texttt{TW.T(THETA)} as above but with a rotation of \texttt{THETA} about the twist.


\subsection*{Notes}
\begin{itemize}
  \item For the second form the twist must, if rotational, have a unit rotational component.
\end{itemize}

\subsection*{See also}


\hyperlink{Twist.exp}{\color{blue} Twist.exp}, \hyperlink{trexp}{\color{blue} trexp}, \hyperlink{trexp2}{\color{blue} trexp2}, \hyperlink{trinterp}{\color{blue} trinterp}, \hyperlink{trinterp2}{\color{blue} trinterp2}

\vspace{1.5ex}\hrule

%---------------------- Twist.theta
\hypertarget{Twist.theta}{\section*{Twist.theta}}
\subsection*{Twist rotation}
\addcontentsline{tom}{section}{Twist.theta}


\texttt{TW.theta} is the rotation ($1 \times 1$) about the twist axis in radians.

\vspace{1.5ex}\hrule

%---------------------- Twist.unit
\hypertarget{Twist.unit}{\section*{Twist.unit}}
\subsection*{Return a unit twist}
\addcontentsline{tom}{section}{Twist.unit}


\texttt{TW.unit()} is a \textbf{\color{red} Twist} object representing a unit aligned with the \textbf{\color{red} Twist}
TW.

\vspace{1.5ex}\rule{\textwidth}{1mm}

%---------------------- unit
\hypertarget{unit}{\section*{unit}}
\subsection*{Unitize a vector}
\addcontentsline{toc}{section}{unit}


\texttt{VN = UNIT(V)} is a unit-vector parallel to \texttt{V}.


\subsection*{Note}
\begin{itemize}
  \item Reports error for the case where \texttt{V} is non-symbolic and norm(\texttt{V}) is zero
\end{itemize}
\vspace{1.5ex}\rule{\textwidth}{1mm}

%---------------------- UnitQuaternion
\hypertarget{UnitQuaternion}{\section*{UnitQuaternion}}
\subsection*{Unit quaternion class}
\addcontentsline{toc}{section}{UnitQuaternion}


A UnitQuaternion is a compact method of representing a 3D rotation that has
computational advantages including speed and numerical robustness.
A quaternion has 2 parts, a scalar s, and a vector v and is typically
written: q = s $<$vx, vy, vz$>$.



A UnitQuaternion is one for which s${}^{2}$+vx${}^{2}$+vy${}^{2}$+vz${}^{2}$ = 1.  It can be
considered as a rotation by an angle theta about a unit-vector V in space where

\begin{Code}
   q = cos (theta/2) < v sin(theta/2)>

\end{Code}

\subsection*{Constructors}
\begin{longtable}{lp{120mm}}
UnitQuaternion & general constructor\\ 
UnitQuaternion.angvec & constructor, from (angle and vector)\\ 
UnitQuaternion.eul & constructor, from Euler angles\\ 
UnitQuaternion.omega & constructor for angle*vector\\ 
UnitQuaternion.rpy & constructor, from roll-pitch-yaw angles\\ 
UnitQuaternion.Rx & constructor, from x-axis rotation\\ 
UnitQuaternion.Ry & constructor, from y-axis rotation\\ 
UnitQuaternion.Rz & constructor, from z-axis rotation\\ 
UnitQuaternion.vec & constructor, from 3-vector\\ 
\end{longtable}\vspace{1ex}

\subsection*{Display and print methods}
\begin{longtable}{lp{120mm}}
animate & animates a coordinate frame\\ 
display & print in human readable form\\ 
plot & plot a coordinate frame representing orientation of quaternion\\ 
\end{longtable}\vspace{1ex}

\subsection*{Group operations}
\begin{longtable}{lp{120mm}}
\textasteriskcentered  & \textasciicircum quaternion (Hamilton) product\\ 
.\textasteriskcentered  & quaternion (Hamilton) product and renormalize\\ 
/ & \textasciicircum multiply by inverse\\ 
./ & multiply by inverse and renormalize\\ 
\textasciicircum  & \textasciicircum exponentiate (integer only)\\ 
exp & \textasciicircum exponential\\ 
inv & \textasciicircum inverse\\ 
log & \textasciicircum logarithm\\ 
prod & product of elements\\ 
\end{longtable}\vspace{1ex}

\subsection*{Methods}
\begin{longtable}{lp{120mm}}
angle & angle between two quaternions\\ 
conj & \textasciicircum conjugate\\ 
dot & derivative of quaternion with angular velocity\\ 
inner & \textasciicircum inner product\\ 
interp & interpolation (slerp) between two quaternions\\ 
norm & \textasciicircum norm, or length\\ 
unit & unitized quaternion\\ 
UnitQuaternion.qvmul & multiply unit-quaternions in 3-vector form\\ 
\end{longtable}\vspace{1ex}

\subsection*{Conversion methods}
\begin{longtable}{lp{120mm}}
char & convert to string\\ 
double & \textasciicircum convert to 4-vector\\ 
matrix & convert to $4 \times 4$ matrix\\ 
R & convert to $3 \times 3$ rotation matrix\\ 
SE3 & convert to SE3 object\\ 
SO3 & convert to SO3 object\\ 
T & convert to $4 \times 4$ homogeneous transform matrix\\ 
toangvec & convert to angle vector form\\ 
toeul & convert to Euler angles\\ 
torpy & convert to roll-pitch-yaw angles\\ 
tovec & convert to 3-vector\\ 
\end{longtable}\vspace{1ex}

\subsection*{Operators}
\begin{longtable}{lp{120mm}}
+ & elementwise sum of quaternion elements (result is a Quaternion)\\ 
- & elementwise difference of quaternion elements (result is a Quaternion)\\ 
== & test for equality\\ 
$\sim=$ & \textasciicircum test for inequality\\ 
\end{longtable}\vspace{1ex}


\textasciicircum  means inherited from Quaternion class.


\subsection*{Properties (read only)}
\begin{longtable}{lp{120mm}}
s & real part\\ 
v & vector part\\ 
\end{longtable}\vspace{1ex}

\subsection*{Notes}
\begin{itemize}
  \item A subclass of Quaternion
  \item Many methods and operators are inherited from the Quaternion superclass.
  \item UnitQuaternion objects can be used in vectors and arrays.
  \item The + and - operators return a Quaternion object not a UnitQuaternion    since these are not group operators.
  \item For display purposes a Quaternion differs from a UnitQuaternion by    using $<$$<$ $>$$>$ notation rather than $<$ $>$.
  \item To a large extent polymorphic with the SO3 class.
\end{itemize}

\subsection*{References}
\begin{itemize}
  \item Animating rotation with quaternion curves,    K. Shoemake,
  \item in Proceedings of ACM SIGGRAPH, (San Fran cisco), pp. 245-254, 1985.
  \item On homogeneous transforms, quaternions, and computational efficiency,    J. Funda, R. Taylor, and R. Paul,
  \item IEEE Transactions on Robotics and Automation, vol. 6, pp. 382-388, June 1990.
  \item Quaternions for Computer Graphics, J. Vince, Springer 2011.
  \item Robotics, Vision \& Control: Second Edition, P. Corke, Springer 2016; p44-45.
\end{itemize}

\subsection*{See also}


\hyperlink{Quaternion}{\color{blue} Quaternion}, \hyperlink{SO3}{\color{blue} SO3}

\vspace{1.5ex}\hrule

%---------------------- UnitQuaternion.UnitQuaternion
\hypertarget{UnitQuaternion.UnitQuaternion}{\section*{UnitQuaternion.UnitQuaternion}}
\subsection*{Construct a unit quaternion object}
\addcontentsline{tom}{section}{UnitQuaternion.UnitQuaternion}


Construct a \textbf{\color{red} UnitQuaternion} from various other orientation representations.



\texttt{Q = UnitQuaternion()} is the identitity \textbf{\color{red} UnitQuaternion} 1$<$0,0,0$>$ representing a null rotation.



\texttt{Q = UnitQuaternion(Q1)} is a copy of the \textbf{\color{red} UnitQuaternion} \texttt{Q1}, if \texttt{Q1} is a
Quaternion it is normalised.



\texttt{Q = UnitQuaternion(S, V)} is a \textbf{\color{red} UnitQuaternion} formed by specifying directly
its scalar and vector parts which are normalised.



\texttt{Q = UnitQuaternion([S, V1, V2, V3])} is a \textbf{\color{red} UnitQuaternion} formed by specifying
directly its 4 elements which are normalised.



\texttt{Q = Quaternion(R)} is a \textbf{\color{red} UnitQuaternion} corresponding to the $\mbox{SO}(3)$
orthonormal rotation matrix \texttt{R} ($3 \times 3$).  If \texttt{R} ($3 \times 3 \times N$) is a sequence then \texttt{Q}
($N \times 1$) is a vector of Quaternions corresponding to the elements of \texttt{R}.



\texttt{Q = Quaternion(T)} is a \textbf{\color{red} UnitQuaternion} equivalent to the rotational part
of the $\mbox{SE}(3)$ homogeneous transform \texttt{T} ($4 \times 4$). If \texttt{T} ($4 \times 4 \times N$) is a sequence
then \texttt{Q} ($N \times 1$) is a vector of Quaternions corresponding to the elements of
\texttt{T}.


\subsection*{Notes}
\begin{itemize}
  \item Only the \texttt{R} and \texttt{T} forms are vectorised.
  \item To convert an SO3 or SE3 object to a UnitQuaternion use their    UnitQuaternion conversion methods.
\end{itemize}


See also \textbf{\color{red} UnitQuaternion}.eul, \textbf{\color{red} UnitQuaternion}.rpy, \textbf{\color{red} UnitQuaternion}.angvec,
UnitQuaternion.omega, UnitQuaternion.Rx, UnitQuaternion.Ry,
UnitQuaternion.Rz, SE3.UnitQuaternion, SO3.UnitQuaternion.

\vspace{1.5ex}\hrule

%---------------------- UnitQuaternion.angle
\hypertarget{UnitQuaternion.angle}{\section*{UnitQuaternion.angle}}
\subsection*{Angle between two UnitQuaternions}
\addcontentsline{tom}{section}{UnitQuaternion.angle}


\texttt{A = Q1.angle(Q2)} is the angle (in radians) between two UnitQuaternions Q1 and \texttt{Q2}.


\subsection*{Notes}
\begin{itemize}
  \item If either, or both, of Q1 or \texttt{Q2} are vectors, then the result is a vector.
\begin{itemize}
  \item if Q1 is a vector ($1 \times N$) then \texttt{A} is a vector ($1 \times N$) such that \texttt{A}(i) = P1(i).angle(\texttt{Q2}).
  \item if \texttt{Q2} is a vector ($1 \times N$) then \texttt{A} is a vector ($1 \times N$) such that \texttt{A}(i) = P1.angle(P2(i)).
  \item if both Q1 and \texttt{Q2} are vectors ($1 \times N$) then \texttt{A} is a vector ($1 \times N$) such     that \texttt{A}(i) = P1(i).angle(\texttt{Q2}(i)).
\end{itemize}
\end{itemize}

\subsection*{References}
\begin{itemize}
  \item Metrics for 3D rotations: comparison and analysis, Du Q. Huynh,    J.Math Imaging Vis. DOFI 10.1007/s10851-009-0161-2.
\end{itemize}

\subsection*{See also}


\hyperlink{Quaternion.angvec}{\color{blue} Quaternion.angvec}

\vspace{1.5ex}\hrule

%---------------------- UnitQuaternion.angvec
\hypertarget{UnitQuaternion.angvec}{\section*{UnitQuaternion.angvec}}
\subsection*{Construct UnitQuaternion from angle and rotation vector}
\addcontentsline{tom}{section}{UnitQuaternion.angvec}


\texttt{Q = UnitQuaternion.angvec(TH, V)} is a \textbf{\color{red} UnitQuaternion} representing rotation of \texttt{TH} about the vector \texttt{V} ($3 \times 1$).


\subsection*{See also}


\hyperlink{UnitQuaternion.omega}{\color{blue} UnitQuaternion.omega}

\vspace{1.5ex}\hrule

%---------------------- UnitQuaternion.animate
\hypertarget{UnitQuaternion.animate}{\section*{UnitQuaternion.animate}}
\subsection*{Animate UnitQuaternion object}
\addcontentsline{tom}{section}{UnitQuaternion.animate}


\texttt{Q.animate(options)} animates a \textbf{\color{red} UnitQuaternion} array Q ($1 \times N$) as a 3D coordinate frame.



\texttt{Q.animate(QF, options)} animates a 3D coordinate frame moving from
orientation Q to orientation \texttt{QF}.


\subsection*{Options}


Options are passed to tranimate and include:

\begin{longtable}{lp{120mm}}
\textquotesingle fps\textquotesingle , fps & Number of frames per second to display (default 10)\\ 
\textquotesingle nsteps\textquotesingle , n & The number of steps along the path (default 50)\\ 
\textquotesingle axis\textquotesingle ,A & Axis bounds [xmin, xmax, ymin, ymax, zmin, zmax]\\ 
\textquotesingle movie\textquotesingle ,M & Save frames as files in the folder M\\ 
\textquotesingle cleanup\textquotesingle  & Remove the frame at end of animation\\ 
\textquotesingle noxyz\textquotesingle  & Don\textquotesingle t label the axes\\ 
\textquotesingle rgb\textquotesingle  & Color the axes in the order x=red, y=green, z=blue\\ 
\textquotesingle retain\textquotesingle  & Retain frames, don\textquotesingle t animate\\ 
\end{longtable}\vspace{1ex}


Additional \texttt{options} are passed through to TRPLOT.


\subsection*{See also}


\hyperlink{tranimate}{\color{blue} tranimate}, \hyperlink{trplot}{\color{blue} trplot}

\vspace{1.5ex}\hrule

%---------------------- UnitQuaternion.char
\hypertarget{UnitQuaternion.char}{\section*{UnitQuaternion.char}}
\subsection*{Convert to string}
\addcontentsline{tom}{section}{UnitQuaternion.char}


\texttt{S = Q.char()} is a compact string representation of the \textbf{\color{red} UnitQuaternion}\textquotesingle s value
as a 4-tuple.  If Q is a vector then \texttt{S} has one line per element.


\subsection*{Notes}
\begin{itemize}
  \item The vector part is delimited by single angle brackets, to differentiate    from a Quaternion which is delimited by double angle brackets.
\end{itemize}

\subsection*{See also}


\hyperlink{Quaternion.char}{\color{blue} Quaternion.char}

\vspace{1.5ex}\hrule

%---------------------- UnitQuaternion.dot
\hypertarget{UnitQuaternion.dot}{\section*{UnitQuaternion.dot}}
\subsection*{UnitQuaternion derivative in world frame}
\addcontentsline{tom}{section}{UnitQuaternion.dot}


\texttt{QD = Q.dot(omega)} is the rate of change of the \textbf{\color{red} UnitQuaternion} Q expressed
as a Quaternion in the world frame. Q represents the orientation of a body
frame with angular velocity OMEGA ($1 \times 3$).


\subsection*{Notes}
\begin{itemize}
  \item This is not a group operator, but it is useful to have the result as a    Quaternion.
\end{itemize}

\subsection*{Reference}
\begin{itemize}
  \item Robotics, Vision \& Control, 2nd edition, Peter Corke, pp.64.
\end{itemize}

\subsection*{See also}


\hyperlink{UnitQuaternion.dotb}{\color{blue} UnitQuaternion.dotb}

\vspace{1.5ex}\hrule

%---------------------- UnitQuaternion.dotb
\hypertarget{UnitQuaternion.dotb}{\section*{UnitQuaternion.dotb}}
\subsection*{UnitQuaternion derivative in body frame}
\addcontentsline{tom}{section}{UnitQuaternion.dotb}


\texttt{QD = Q.dotb(omega)} is the rate of change of the \textbf{\color{red} UnitQuaternion} Q expressed
as a Quaternion in the body frame. Q represents the orientation of a body
frame with angular velocity OMEGA ($1 \times 3$).


\subsection*{Notes}
\begin{itemize}
  \item This is not a group operator, but it is useful to have the result as a    quaternion.
\end{itemize}

\subsection*{Reference}
\begin{itemize}
  \item Robotics, Vision \& Control, 2nd edition, Peter Corke, pp.64.
\end{itemize}

\subsection*{See also}


\hyperlink{UnitQuaternion.dot}{\color{blue} UnitQuaternion.dot}

\vspace{1.5ex}\hrule

%---------------------- UnitQuaternion.eq
\hypertarget{UnitQuaternion.eq}{\section*{UnitQuaternion.eq}}
\subsection*{Test for equality}
\addcontentsline{tom}{section}{UnitQuaternion.eq}


Q1 == Q2 is true if the two UnitQuaternions represent the same rotation.


\subsection*{Notes}
\begin{itemize}
  \item The double mapping of the UnitQuaternion is taken into account, that is,    UnitQuaternions are equal if Q1.s == -Q1.s \&\& Q1.v == -Q2.v.
  \item If Q1 is a vector of UnitQuaternions, each element is compared to    Q2 and the result is a logical array of the same length as Q1.
  \item If Q2 is a vector of UnitQuaternion, each element is compared to    Q1 and the result is a logical array of the same length as Q2.
  \item If Q1 and Q2 are equal length vectors of UnitQuaternion, then the result    is a logical array of the same length.
\end{itemize}
\vspace{1.5ex}\hrule

%---------------------- UnitQuaternion.eul
\hypertarget{UnitQuaternion.eul}{\section*{UnitQuaternion.eul}}
\subsection*{Construct UnitQuaternion from Euler angles}
\addcontentsline{tom}{section}{UnitQuaternion.eul}


\texttt{Q = UnitQuaternion.eul(PHI, THETA, PSI, OPTIONS)} is a \textbf{\color{red} UnitQuaternion}
representing rotation equivalent to the specified Euler angles
angles. These correspond to rotations about the Z, Y, Z axes
respectively.



\texttt{Q = UnitQuaternion.eul(EUL, OPTIONS)} as above but the Euler angles are
taken from the vector ($1 \times 3$) \texttt{EUL} = [\texttt{PHI} \texttt{THETA} \texttt{PSI}]. If \texttt{EUL} is a matrix
($N \times 3$) then \texttt{Q} is a vector ($1 \times N$) of UnitQuaternion objects where the index
corresponds to rows of \texttt{EUL} which are assumed to be [\texttt{PHI},\texttt{THETA},\texttt{PSI}].


\subsection*{Options}
\begin{longtable}{lp{120mm}}
\textquotesingle deg\textquotesingle  & Compute angles in degrees (default radians)\\ 
\end{longtable}\vspace{1ex}

\subsection*{Notes}
\begin{itemize}
  \item Is vectorised, see eul2r for details.
\end{itemize}

\subsection*{See also}


\hyperlink{UnitQuaternion.rpy}{\color{blue} UnitQuaternion.rpy}, \hyperlink{eul2r}{\color{blue} eul2r}

\vspace{1.5ex}\hrule

%---------------------- UnitQuaternion.increment
\hypertarget{UnitQuaternion.increment}{\section*{UnitQuaternion.increment}}
\subsection*{Update UnitQuaternion by angular displacement}
\addcontentsline{tom}{section}{UnitQuaternion.increment}


\texttt{QU = Q.increment(OMEGA)} updates Q by an infinitessimal rotation which is given
as a spatial displacement \texttt{OMEGA} ($3 \times 1$) whose direction is the rotation axis and
magnitude is the amount of rotation.


\subsection*{Notes}
\begin{itemize}
  \item \texttt{OMEGA} is an approximation to the instantaneous spatial velocity multiplied by    time step.
\end{itemize}

\subsection*{See also}


\hyperlink{tr2delta}{\color{blue} tr2delta}

\vspace{1.5ex}\hrule

%---------------------- UnitQuaternion.interp
\hypertarget{UnitQuaternion.interp}{\section*{UnitQuaternion.interp}}
\subsection*{Interpolate UnitQuaternion}
\addcontentsline{tom}{section}{UnitQuaternion.interp}


\texttt{QI = Q.scale(S, OPTIONS)} is a \textbf{\color{red} UnitQuaternion} that interpolates between a null
rotation (identity UnitQuaternion) for \texttt{S}=0 to Q for \texttt{S}=1.



\texttt{QI = Q1.interp(Q2, S, OPTIONS)} as above but interpolates a rotation
between Q1 for \texttt{S}=0 and \texttt{Q2} for \texttt{S}=1.



If \texttt{S} is a vector \texttt{QI} is a vector of UnitQuaternions, each element
corresponding to sequential elements of \texttt{S}.


\subsection*{Options}
\begin{longtable}{lp{120mm}}
\textquotesingle shortest\textquotesingle  & Take the shortest path along the great circle\\ 
\end{longtable}\vspace{1ex}

\subsection*{Notes}
\begin{itemize}
  \item This is a spherical linear interpolation (slerp) that can be interpretted    as interpolation along a great circle arc on a sphere.
  \item It is an error if any element of \texttt{S} is outside the interval 0 to 1.
\end{itemize}

\subsection*{References}
\begin{itemize}
  \item Animating rotation with quaternion curves, K. Shoemake,    in Proceedings of ACM SIGGRAPH, (San Francisco), pp. 245-254, 1985.
\end{itemize}

\subsection*{See also}


\hyperlink{ctraj}{\color{blue} ctraj}

\vspace{1.5ex}\hrule

%---------------------- UnitQuaternion.inv
\hypertarget{UnitQuaternion.inv}{\section*{UnitQuaternion.inv}}
\subsection*{Invert a UnitQuaternion}
\addcontentsline{tom}{section}{UnitQuaternion.inv}


\texttt{Q.inv()} is a \textbf{\color{red} UnitQuaternion} object representing the inverse of Q.  If
Q is a vector ($1 \times N$) the result is a vector of elementwise inverses.


\subsection*{See also}


\hyperlink{Quaternion.conj}{\color{blue} Quaternion.conj}

\vspace{1.5ex}\hrule

%---------------------- UnitQuaternion.mrdivide
\hypertarget{UnitQuaternion.mrdivide}{\section*{UnitQuaternion.mrdivide}}
\subsection*{Divide unit quaternions}
\addcontentsline{tom}{section}{UnitQuaternion.mrdivide}


\texttt{R = Q1/Q2} is a \textbf{\color{red} UnitQuaternion} object formed by Hamilton product of \texttt{Q1} and
inv(\texttt{Q2}) where \texttt{Q1} and \texttt{Q2} are both UnitQuaternion objects.


\subsection*{Notes}
\begin{itemize}
  \item Overloaded operator \textquotesingle /\textquotesingle .
  \item If either, or both, of \texttt{Q1} or \texttt{Q2} are vectors, then the result is a vector.
\begin{itemize}
  \item if \texttt{Q1} is a vector ($1 \times N$) then \texttt{R} is a vector ($1 \times N$) such that \texttt{R}(i) = \texttt{Q1}(i)/\texttt{Q2}.
  \item if \texttt{Q2} is a vector ($1 \times N$) then \texttt{R} is a vector ($1 \times N$) such that \texttt{R}(i) = \texttt{Q1}/\texttt{Q2}(i).
  \item if both \texttt{Q1} and \texttt{Q2} are vectors ($1 \times N$) then \texttt{R} is a vector ($1 \times N$) such
\end{itemize}
\end{itemize}


that \texttt{R}(i) = \texttt{Q1}(i)/\texttt{Q2}(i).


\subsection*{See also}


\hyperlink{Quaternion.mtimes}{\color{blue} Quaternion.mtimes}, \hyperlink{Quaternion.mpower}{\color{blue} Quaternion.mpower}, \hyperlink{Quaternion.plus}{\color{blue} Quaternion.plus}, \hyperlink{Quaternion.minus}{\color{blue} Quaternion.minus}

\vspace{1.5ex}\hrule

%---------------------- UnitQuaternion.mtimes
\hypertarget{UnitQuaternion.mtimes}{\section*{UnitQuaternion.mtimes}}
\subsection*{Multiply UnitQuaternion\textquotesingle s}
\addcontentsline{tom}{section}{UnitQuaternion.mtimes}


\texttt{R = Q1*Q2} is a \textbf{\color{red} UnitQuaternion} object formed by Hamilton product
of \texttt{Q1} and \texttt{Q2} where \texttt{Q1} and \texttt{Q2} are both UnitQuaternion objects.

\begin{longtable}{lp{120mm}}
Q\textasteriskcentered V & is a vector ($3 \times 1$) formed by rotating the vector V ($3 \times 1$)by the UnitQuaternion Q.\\ 
\end{longtable}\vspace{1ex}

\subsection*{Notes}
\begin{itemize}
  \item Overloaded operator \textquotesingle *\textquotesingle 
  \item If either, or both, of \texttt{Q1} or \texttt{Q2} are vectors, then the result is a vector.
\begin{itemize}
  \item if \texttt{Q1} is a vector ($1 \times N$) then \texttt{R} is a vector ($1 \times N$) such that \texttt{R}(i) = \texttt{Q1}(i)*\texttt{Q2}.
  \item if \texttt{Q2} is a vector ($1 \times N$) then \texttt{R} is a vector ($1 \times N$) such that \texttt{R}(i) = \texttt{Q1}*\texttt{Q2}(i).
  \item if both \texttt{Q1} and \texttt{Q2} are vectors ($1 \times N$) then \texttt{R} is a vector ($1 \times N$) such
\end{itemize}
\end{itemize}


that \texttt{R}(i) = \texttt{Q1}(i)*\texttt{Q2}(i).


\subsection*{See also}


\hyperlink{Quaternion.mrdivide}{\color{blue} Quaternion.mrdivide}, \hyperlink{Quaternion.mpower}{\color{blue} Quaternion.mpower}, \hyperlink{Quaternion.plus}{\color{blue} Quaternion.plus}, \hyperlink{Quaternion.minus}{\color{blue} Quaternion.minus}

\vspace{1.5ex}\hrule

%---------------------- UnitQuaternion.new
\hypertarget{UnitQuaternion.new}{\section*{UnitQuaternion.new}}
\subsection*{Construct a new UnitQuaternion}
\addcontentsline{tom}{section}{UnitQuaternion.new}


\texttt{QN = Q.new()} constructs a new \textbf{\color{red} UnitQuaternion} object of the same type as Q.



\texttt{QN = Q.new([S, V1, V2, V3])} as above but specified directly by its 4 elements.



\texttt{QN = Q.new(S, V)} as above but specified directly by the scalar \texttt{S} and vector
part \texttt{V} ($1 \times 3$)


\subsection*{Notes}
\begin{itemize}
  \item Polymorphic with Quaternion and RTBPose derived classes.  For any of these    instance objects the new method creates a new instance object of the same type.
\end{itemize}
\vspace{1.5ex}\hrule

%---------------------- UnitQuaternion.omega
\hypertarget{UnitQuaternion.omega}{\section*{UnitQuaternion.omega}}
\subsection*{Construct UnitQuaternion from angle times rotation vector}
\addcontentsline{tom}{section}{UnitQuaternion.omega}


\texttt{Q = UnitQuaternion.omega(W)} is a \textbf{\color{red} UnitQuaternion} representing rotation of ||\texttt{W}|| about the vector \texttt{W} ($3 \times 1$).


\subsection*{Notes}
\begin{itemize}
  \item The input representation is known as exponential coordinates.
\end{itemize}

\subsection*{See also}


\hyperlink{UnitQuaternion.angvec}{\color{blue} UnitQuaternion.angvec}

\vspace{1.5ex}\hrule

%---------------------- UnitQuaternion.plot
\hypertarget{UnitQuaternion.plot}{\section*{UnitQuaternion.plot}}
\subsection*{Plot a quaternion object}
\addcontentsline{tom}{section}{UnitQuaternion.plot}


\texttt{Q.plot(options)} plots the \textbf{\color{red} UnitQuaternion} as an oriented coordinate frame.



\texttt{H = Q.plot(options)} as above but returns a handle which can be used for animation.


\subsection*{Animation}


Firstly, create a plot and keep the the handle as per above.



\texttt{Q.plot('handle', H)} updates the coordinate frame described by the handle \texttt{H} to
the orientation of Q.


\subsection*{Options}
\begin{longtable}{lp{120mm}}
\textquotesingle color\textquotesingle ,C & The color to draw the axes, MATLAB colorspec C\\ 
\textquotesingle frame\textquotesingle ,F & The frame is named $\{$F$\}$ and the subscript on the axis labels is F.\\ 
\textquotesingle view\textquotesingle ,V                     for view toward origin of coordinate frame & Set plot view parameters V=[az el] angles, or \textquotesingle auto\textquotesingle \\ 
\textquotesingle handle\textquotesingle ,h & Update the specified handle\\ 
\end{longtable}\vspace{1ex}


These \texttt{options} are passed to trplot, see trplot for more \texttt{options}.


\subsection*{See also}


\hyperlink{trplot}{\color{blue} trplot}

\vspace{1.5ex}\hrule

%---------------------- UnitQuaternion.prod
\hypertarget{UnitQuaternion.prod}{\section*{UnitQuaternion.prod}}
\subsection*{Product of unit quaternions}
\addcontentsline{tom}{section}{UnitQuaternion.prod}


\texttt{prod(Q)} is the product of the elements of the vector of \textbf{\color{red} UnitQuaternion} objects \texttt{Q}.


\subsection*{Note}
\begin{itemize}
  \item Multiplication is performed with the .* operator, ie. the product is    renormalized at every step.
\end{itemize}

\subsection*{See also}


\hyperlink{UnitQuaternion.times}{\color{blue} UnitQuaternion.times}, \hyperlink{RTBPose.prod}{\color{blue} RTBPose.prod}

\vspace{1.5ex}\hrule

%---------------------- UnitQuaternion.q2r
\hypertarget{UnitQuaternion.q2r}{\section*{UnitQuaternion.q2r}}
\subsection*{Convert unit quaternion as vector to $\mbox{SO}(3)$ rotation matrix}
\addcontentsline{tom}{section}{UnitQuaternion.q2r}


\texttt{UnitQuaternion.q2r(V)} is an $\mbox{SO}(3)$ orthonormal rotation matrix ($3 \times 3$) representing the
same 3D orientation as the elements of the unit quaternion \texttt{V} ($1 \times 4$).


\subsection*{Notes}
\begin{itemize}
  \item Is a static class method.
\end{itemize}

\subsection*{Reference}
\begin{itemize}
  \item Funda, Taylor, IEEE Trans. Robotics and Automation, 6(3), June 1990, pp.382-388.
\end{itemize}


See also \textbf{\color{red} UnitQuaternion}.tr2q

\vspace{1.5ex}\hrule

%---------------------- UnitQuaternion.qvmul
\hypertarget{UnitQuaternion.qvmul}{\section*{UnitQuaternion.qvmul}}
\subsection*{Multiply unit quaternions defined by vector part}
\addcontentsline{tom}{section}{UnitQuaternion.qvmul}


\texttt{QV = UnitQuaternion.QVMUL(QV1, QV2)} multiplies two unit-quaternions
defined only by their vector components \texttt{QV1} and \texttt{QV2} ($3 \times 1$).  The result is
similarly the vector component of the Hamilton product ($3 \times 1$).


\subsection*{Notes}
\begin{itemize}
  \item Is a static class method.
\end{itemize}

\subsection*{See also}


\hyperlink{UnitQuaternion.tovec}{\color{blue} UnitQuaternion.tovec}, \hyperlink{UnitQuaternion.vec}{\color{blue} UnitQuaternion.vec}

\vspace{1.5ex}\hrule

%---------------------- UnitQuaternion.R
\hypertarget{UnitQuaternion.R}{\section*{UnitQuaternion.R}}
\subsection*{Convert to $\mbox{SO}(3)$ rotation matrix}
\addcontentsline{tom}{section}{UnitQuaternion.R}


\texttt{R = Q.R()} is the equivalent $\mbox{SO}(3)$ orthonormal rotation matrix ($3 \times 3$).  If
Q represents a sequence ($N \times 1$) then \texttt{R} is $3 \times 3 \times N$.


\subsection*{See also}


\hyperlink{UnitQuaternion.T}{\color{blue} UnitQuaternion.T}, \hyperlink{UnitQuaternion.SO3}{\color{blue} UnitQuaternion.SO3}

\vspace{1.5ex}\hrule

%---------------------- UnitQuaternion.rand
\hypertarget{UnitQuaternion.rand}{\section*{UnitQuaternion.rand}}
\subsection*{Construct a random UnitQuaternion}
\addcontentsline{tom}{section}{UnitQuaternion.rand}


\texttt{UnitQuaternion.rand()} is a \textbf{\color{red} UnitQuaternion} representing a random 3D rotation.


\subsection*{References}
\begin{itemize}
  \item Planning Algorithms, Steve LaValle, p164.
\end{itemize}

\subsection*{See also}


\hyperlink{SO3.rand}{\color{blue} SO3.rand}, \hyperlink{SE3.rand}{\color{blue} SE3.rand}

\vspace{1.5ex}\hrule

%---------------------- UnitQuaternion.rdivide
\hypertarget{UnitQuaternion.rdivide}{\section*{UnitQuaternion.rdivide}}
\subsection*{Divide unit quaternions and unitize}
\addcontentsline{tom}{section}{UnitQuaternion.rdivide}
\begin{longtable}{lp{120mm}}
Q1./Q2 & is a UnitQuaternion object formed by Hamilton product of Q1 and\\ 
\end{longtable}\vspace{1ex}


\texttt{inv(Q2)} where Q1 and \texttt{Q2} are both \textbf{\color{red} UnitQuaternion} objects.  The result is
explicitly unitized.


\subsection*{Notes}
\begin{itemize}
  \item Overloaded operator \textquotesingle ./\textquotesingle .
  \item If either, or both, of Q1 or \texttt{Q2} are vectors, then the result is a vector.
\begin{itemize}
  \item if Q1 is a vector ($1 \times N$) then R is a vector ($1 \times N$) such that R(i) = Q1(i)./\texttt{Q2}.
  \item if \texttt{Q2} is a vector ($1 \times N$) then R is a vector ($1 \times N$) such that R(i) = Q1./\texttt{Q2}(i).
  \item if both Q1 and \texttt{Q2} are vectors ($1 \times N$) then R is a vector ($1 \times N$) such
\end{itemize}
\end{itemize}


that R(i) = Q1(i)./\texttt{Q2}(i).


\subsection*{See also}


\hyperlink{Quaternion.mtimes}{\color{blue} Quaternion.mtimes}

\vspace{1.5ex}\hrule

%---------------------- UnitQuaternion.rpy
\hypertarget{UnitQuaternion.rpy}{\section*{UnitQuaternion.rpy}}
\subsection*{Construct UnitQuaternion from roll-pitch-yaw angles}
\addcontentsline{tom}{section}{UnitQuaternion.rpy}


\texttt{Q = UnitQuaternion.rpy(ROLL, PITCH, YAW, OPTIONS)} is a \textbf{\color{red} UnitQuaternion}
representing rotation equivalent to the specified roll, pitch, yaw angles
angles. These correspond to rotations about the Z, Y, X axes
respectively.



\texttt{Q = UnitQuaternion.rpy(RPY, OPTIONS)} as above but the angles are given by
the passed vector \texttt{RPY} = [\texttt{ROLL}, \texttt{PITCH}, \texttt{YAW}].  If \texttt{RPY} is a matrix ($N \times 3$)
then \texttt{Q} is a vector ($1 \times N$) of UnitQuaternion objects where the index
corresponds to rows of \texttt{RPY} which are assumed to be [\texttt{ROLL},\texttt{PITCH},\texttt{YAW}].


\subsection*{Options}
\begin{longtable}{lp{120mm}}
\textquotesingle deg\textquotesingle  & Compute angles in degrees (default radians)\\ 
\textquotesingle zyx\textquotesingle  & Return solution for sequential rotations about Z, Y, X axes (default)\\ 
\textquotesingle xyz\textquotesingle  & Return solution for sequential rotations about X, Y, Z axes\\ 
\textquotesingle yxz\textquotesingle  & Return solution for sequential rotations about Y, X, Z axes\\ 
\end{longtable}\vspace{1ex}

\subsection*{Notes}
\begin{itemize}
  \item Is vectorised, see rpy2r for details.
\end{itemize}

\subsection*{See also}


\hyperlink{UnitQuaternion.eul}{\color{blue} UnitQuaternion.eul}, \hyperlink{rpy2r}{\color{blue} rpy2r}

\vspace{1.5ex}\hrule

%---------------------- UnitQuaternion.Rx
\hypertarget{UnitQuaternion.Rx}{\section*{UnitQuaternion.Rx}}
\subsection*{Construct UnitQuaternion from rotation about x-axis}
\addcontentsline{tom}{section}{UnitQuaternion.Rx}


\texttt{Q = UnitQuaternion.Rx(ANGLE)} is a \textbf{\color{red} UnitQuaternion} representing rotation of \texttt{ANGLE} about the x-axis.



\texttt{Q = UnitQuaternion.Rx(ANGLE, 'deg')} as above but THETA is in degrees.


\subsection*{See also}


\hyperlink{UnitQuaternion.Ry}{\color{blue} UnitQuaternion.Ry}, \hyperlink{UnitQuaternion.Rz}{\color{blue} UnitQuaternion.Rz}

\vspace{1.5ex}\hrule

%---------------------- UnitQuaternion.Ry
\hypertarget{UnitQuaternion.Ry}{\section*{UnitQuaternion.Ry}}
\subsection*{Construct UnitQuaternion from rotation about y-axis}
\addcontentsline{tom}{section}{UnitQuaternion.Ry}


\texttt{Q = UnitQuaternion.Ry(ANGLE)} is a \textbf{\color{red} UnitQuaternion} representing rotation of \texttt{ANGLE} about the y-axis.



\texttt{Q = UnitQuaternion.Ry(ANGLE, 'deg')} as above but THETA is in degrees.


\subsection*{See also}


\hyperlink{UnitQuaternion.Rx}{\color{blue} UnitQuaternion.Rx}, \hyperlink{UnitQuaternion.Rz}{\color{blue} UnitQuaternion.Rz}

\vspace{1.5ex}\hrule

%---------------------- UnitQuaternion.Rz
\hypertarget{UnitQuaternion.Rz}{\section*{UnitQuaternion.Rz}}
\subsection*{Construct UnitQuaternion from rotation about z-axis}
\addcontentsline{tom}{section}{UnitQuaternion.Rz}


\texttt{Q = UnitQuaternion.Rz(ANGLE)} is a \textbf{\color{red} UnitQuaternion} representing rotation of \texttt{ANGLE} about the z-axis.



\texttt{Q = UnitQuaternion.Rz(ANGLE, 'deg')} as above but THETA is in degrees.


\subsection*{See also}


\hyperlink{UnitQuaternion.Rx}{\color{blue} UnitQuaternion.Rx}, \hyperlink{UnitQuaternion.Ry}{\color{blue} UnitQuaternion.Ry}

\vspace{1.5ex}\hrule

%---------------------- UnitQuaternion.SE3
\hypertarget{UnitQuaternion.SE3}{\section*{UnitQuaternion.SE3}}
\subsection*{Convert to SE3 object}
\addcontentsline{tom}{section}{UnitQuaternion.SE3}


\texttt{Q.SE3()} is an SE3 object with equivalent rotation and zero translation.


\subsection*{Notes}
\begin{itemize}
  \item The translational part of the SE3 object is zero
  \item If Q is a vector then an equivalent vector of SE3 objects is created.
\end{itemize}

\subsection*{See also}


\hyperlink{UnitQuaternion.SE3}{\color{blue} UnitQuaternion.SE3}, \hyperlink{SE3}{\color{blue} SE3}

\vspace{1.5ex}\hrule

%---------------------- UnitQuaternion.SO3
\hypertarget{UnitQuaternion.SO3}{\section*{UnitQuaternion.SO3}}
\subsection*{Convert to SO3 object}
\addcontentsline{tom}{section}{UnitQuaternion.SO3}


\texttt{Q.SO3()} is an SO3 object with equivalent rotation.


\subsection*{Notes}
\begin{itemize}
  \item If Q is a vector then an equivalent vector of SO3 objects is created.
\end{itemize}

\subsection*{See also}


\hyperlink{UnitQuaternion.SE3}{\color{blue} UnitQuaternion.SE3}, \hyperlink{SO3}{\color{blue} SO3}

\vspace{1.5ex}\hrule

%---------------------- UnitQuaternion.T
\hypertarget{UnitQuaternion.T}{\section*{UnitQuaternion.T}}
\subsection*{Convert to homogeneous transformation matrix}
\addcontentsline{tom}{section}{UnitQuaternion.T}


\texttt{T = Q.T()} is the equivalent $\mbox{SE}(3)$ homogeneous transformation
matrix ($4 \times 4$).  If Q is a sequence ($N \times 1$) then \texttt{T} is $4 \times 4 \times N$.



Notes:

\begin{itemize}
  \item Has a zero translational component.
\end{itemize}

\subsection*{See also}


\hyperlink{UnitQuaternion.R}{\color{blue} UnitQuaternion.R}, \hyperlink{UnitQuaternion.SE3}{\color{blue} UnitQuaternion.SE3}

\vspace{1.5ex}\hrule

%---------------------- UnitQuaternion.times
\hypertarget{UnitQuaternion.times}{\section*{UnitQuaternion.times}}
\subsection*{Multiply UnitQuaternion\textquotesingle s and unitize}
\addcontentsline{tom}{section}{UnitQuaternion.times}


\texttt{R = Q1.*Q2} is a \textbf{\color{red} UnitQuaternion} object formed by Hamilton product of \texttt{Q1} and
\texttt{Q2}. The result is explicitly unitized.


\subsection*{Notes}
\begin{itemize}
  \item Overloaded operator \textquotesingle .*\textquotesingle 
  \item If either, or both, of \texttt{Q1} or \texttt{Q2} are vectors, then the result is a vector.
\begin{itemize}
  \item if \texttt{Q1} is a vector ($1 \times N$) then \texttt{R} is a vector ($1 \times N$) such that \texttt{R}(i) = \texttt{Q1}(i).*\texttt{Q2}.
  \item if \texttt{Q2} is a vector ($1 \times N$) then \texttt{R} is a vector ($1 \times N$) such that \texttt{R}(i) = \texttt{Q1}.*\texttt{Q2}(i).
  \item if both \texttt{Q1} and \texttt{Q2} are vectors ($1 \times N$) then \texttt{R} is a vector ($1 \times N$) such
\end{itemize}
\end{itemize}


that \texttt{R}(i) = \texttt{Q1}(i).*\texttt{Q2}(i).


\subsection*{See also}


\hyperlink{Quaternion.mtimes}{\color{blue} Quaternion.mtimes}

\vspace{1.5ex}\hrule

%---------------------- UnitQuaternion.toangvec
\hypertarget{UnitQuaternion.toangvec}{\section*{UnitQuaternion.toangvec}}
\subsection*{Convert to angle-vector form}
\addcontentsline{tom}{section}{UnitQuaternion.toangvec}


\texttt{TH = Q.toangvec(OPTIONS)} is the rotational angle, about some vector,
corresponding to this UnitQuaternion. If Q is a UnitQuaternion
vector ($1 \times N$) then \texttt{TH} ($1 \times N$) and V ($N \times 3$).



\texttt{[TH,V] = Q.toangvec(OPTIONS)} as above but also returns a unit vector
parallel to the rotation axis.



\texttt{Q.toangvec(OPTIONS)} prints a compact single line representation of the
rotational angle and rotation vector corresponding to this UnitQuaternion.
If Q is a UnitQuaternion vector then print one line per element.


\subsection*{Options}
\begin{longtable}{lp{120mm}}
\textquotesingle deg\textquotesingle  & Display/return angle in degrees rather than radians\\ 
\end{longtable}\vspace{1ex}

\subsection*{Notes}
\begin{itemize}
  \item Due to the double cover of the UnitQuaternion, the returned rotation angles    will be in the interval [-$2\pi$, $2\pi$).
\end{itemize}

\subsection*{See also}


\hyperlink{UnitQuaternion.angvec}{\color{blue} UnitQuaternion.angvec}

\vspace{1.5ex}\hrule

%---------------------- UnitQuaternion.toeul
\hypertarget{UnitQuaternion.toeul}{\section*{UnitQuaternion.toeul}}
\subsection*{Convert to roll-pitch-yaw angle form.}
\addcontentsline{tom}{section}{UnitQuaternion.toeul}


\texttt{EUL = Q.toeul(OPTIONS)} are the Euler angles ($1 \times 3$) corresponding to
the UnitQuaternion Q.  These correspond to rotations about the Z, Y, Z axes
respectively. \texttt{EUL} = [PHI,THETA,PSI].



If Q is a vector ($1 \times N$) then each row of \texttt{EUL} corresponds to an element of
the vector.


\subsection*{Options}
\begin{longtable}{lp{120mm}}
\textquotesingle deg\textquotesingle  & Compute angles in degrees (radians default)\\ 
\end{longtable}\vspace{1ex}

\subsection*{Notes}
\begin{itemize}
  \item There is a singularity for the case where THETA=0 in which case PHI is arbitrarily    set to zero and PSI is the sum (PHI+PSI).
\end{itemize}

\subsection*{See also}


\hyperlink{UnitQuaternion.torpy}{\color{blue} UnitQuaternion.torpy}, \hyperlink{tr2eul}{\color{blue} tr2eul}

\vspace{1.5ex}\hrule

%---------------------- UnitQuaternion.torpy
\hypertarget{UnitQuaternion.torpy}{\section*{UnitQuaternion.torpy}}
\subsection*{Convert to roll-pitch-yaw angle form.}
\addcontentsline{tom}{section}{UnitQuaternion.torpy}


\texttt{RPY = Q.torpy(OPTIONS)} are the roll-pitch-yaw angles ($1 \times 3$) corresponding to
the UnitQuaternion Q.  These correspond to rotations about the Z, Y, X axes
respectively. \texttt{RPY} = [ROLL, PITCH, YAW].



If Q is a vector ($1 \times N$) then each row of \texttt{RPY} corresponds to an element of
the vector.


\subsection*{Options}
\begin{longtable}{lp{120mm}}
\textquotesingle deg\textquotesingle  & Compute angles in degrees (radians default)\\ 
\textquotesingle xyz\textquotesingle  & Return solution for sequential rotations about X, Y, Z axes\\ 
\textquotesingle yxz\textquotesingle  & Return solution for sequential rotations about Y, X, Z axes\\ 
\end{longtable}\vspace{1ex}

\subsection*{Notes}
\begin{itemize}
  \item There is a singularity for the case where P=$\pi/2$ in which case R is arbitrarily    set to zero and Y is the sum (R+Y).
\end{itemize}

\subsection*{See also}


\hyperlink{UnitQuaternion.toeul}{\color{blue} UnitQuaternion.toeul}, \hyperlink{tr2rpy}{\color{blue} tr2rpy}

\vspace{1.5ex}\hrule

%---------------------- UnitQuaternion.tovec
\hypertarget{UnitQuaternion.tovec}{\section*{UnitQuaternion.tovec}}
\subsection*{Convert to unique 3-vector}
\addcontentsline{tom}{section}{UnitQuaternion.tovec}


\texttt{V = Q.tovec()} is a vector ($1 \times 3$) that uniquely represents the \textbf{\color{red} UnitQuaternion}.  The scalar
component can be recovered by 1 - norm(\texttt{V}) and will always be positive.


\subsection*{Notes}
\begin{itemize}
  \item UnitQuaternions have double cover of $\mbox{SO}(3)$ so the vector is derived    from the UnitQuaternion with positive scalar component.
  \item This unique and concise vector representation of a UnitQuaternion is often used    in bundle adjustment problems.
\end{itemize}

\subsection*{See also}


\hyperlink{UnitQuaternion.vec}{\color{blue} UnitQuaternion.vec}, \hyperlink{UnitQuaternion.qvmul}{\color{blue} UnitQuaternion.qvmul}

\vspace{1.5ex}\hrule

%---------------------- UnitQuaternion.tr2q
\hypertarget{UnitQuaternion.tr2q}{\section*{UnitQuaternion.tr2q}}
\subsection*{Convert $\mbox{SO}(3)$ or $\mbox{SE}(3)$ matrix to unit quaternion as vector}
\addcontentsline{tom}{section}{UnitQuaternion.tr2q}


\texttt{[S,V] = UnitQuaternion.tr2q(R)} is the scalar \texttt{S} and vector \texttt{V} ($1 \times 3$) elements of a
unit quaternion equivalent to the $\mbox{SO}(3)$ rotation matrix \texttt{R} ($3 \times 3$).



\texttt{[S,V] = UnitQuaternion.tr2q(T)} as above but for the rotational part of the $\mbox{SE}(3)$ matrix \texttt{T} ($4 \times 4$).


\subsection*{Notes}
\begin{itemize}
  \item Is a static class method.
\end{itemize}

\subsection*{Reference}
\begin{itemize}
  \item Funda, Taylor, IEEE Trans. Robotics and Automation, 6(3), June 1990, pp.382-388.
\end{itemize}
\vspace{1.5ex}\hrule

%---------------------- UnitQuaternion.unit
\hypertarget{UnitQuaternion.unit}{\section*{UnitQuaternion.unit}}
\subsection*{Unitize unit-quaternion}
\addcontentsline{tom}{section}{UnitQuaternion.unit}


\texttt{QU = Q.unit()} is a \textbf{\color{red} UnitQuaternion} with a norm of 1.  If Q is a vector ($1 \times N$) then
\texttt{QU} is also a vector ($1 \times N$).


\subsection*{Notes}
\begin{itemize}
  \item This is UnitQuaternion of unit norm, not a Quaternion of unit norm.
\end{itemize}

\subsection*{See also}


\hyperlink{Quaternion.norm}{\color{blue} Quaternion.norm}

\vspace{1.5ex}\hrule

%---------------------- UnitQuaternion.vec
\hypertarget{UnitQuaternion.vec}{\section*{UnitQuaternion.vec}}
\subsection*{Construct UnitQuaternion from 3-vector}
\addcontentsline{tom}{section}{UnitQuaternion.vec}


\texttt{Q = UnitQuaternion.vec(V)} is a \textbf{\color{red} UnitQuaternion} constructed from just its vector
component ($1 \times 3$) and the scalar part is 1 - norm(\texttt{V}) and will always be positive.


\subsection*{Notes}
\begin{itemize}
  \item This unique and concise vector representation of a UnitQuaternion is often used    in bundle adjustment problems.
\end{itemize}

\subsection*{See also}


\hyperlink{UnitQuaternion.tovec}{\color{blue} UnitQuaternion.tovec}, \hyperlink{UnitVector.qvmul}{\color{blue} UnitVector.qvmul}

\vspace{1.5ex}\rule{\textwidth}{1mm}

%---------------------- vex
\hypertarget{vex}{\section*{vex}}
\subsection*{Convert skew-symmetric matrix to vector}
\addcontentsline{toc}{section}{vex}


\texttt{V = VEX(S)} is the vector which has the corresponding skew-symmetric
matrix \texttt{S}.



In the case that \texttt{S} ($2 \times 2$) =

\begin{Code}
     | 0  -v |
     | v   0 |

\end{Code}


then \texttt{V} = [v].  In the case that \texttt{S} ($3 \times 3$) =

\begin{Code}
     |  0  -vz   vy |
     | vz    0  -vx |
     |-vy   vx    0 |

\end{Code}


then \texttt{V} = [vx; vy; vz].


\subsection*{Notes}
\begin{itemize}
  \item This is the inverse of the function SKEW().
  \item Only rudimentary checking (zero diagonal) is done to ensure that the    matrix is actually skew-symmetric.
  \item The function takes the mean of the two elements that correspond to    each unique element of the matrix.
  \item The matrices are the generator matrices for so(2) and so(3).
\end{itemize}

\subsection*{References}
\begin{itemize}
  \item Robotics, Vision \& Control: Second Edition, P. Corke, Springer 2016; p25+43.
\end{itemize}

\subsection*{See also}


\hyperlink{skew}{\color{blue} skew}, \hyperlink{vexa}{\color{blue} vexa}

\vspace{1.5ex}\rule{\textwidth}{1mm}

%---------------------- vexa
\hypertarget{vexa}{\section*{vexa}}
\subsection*{Convert augmented skew-symmetric matrix to vector}
\addcontentsline{toc}{section}{vexa}


\texttt{V = VEXA(S)} is the vector which has the corresponding augmented skew-symmetric
matrix \texttt{S}.



In the case that \texttt{S} ($3 \times 3$) =

\begin{Code}
         |  0  -v3  v1 |
         | v3    0  v2 |
         |  0    0   0 |

\end{Code}


then \texttt{V} = [v1; v2; v3].  In the case that \texttt{S} ($6 \times 6$) =

\begin{Code}
         |  0  -v6   v5  v1 |
         | v6    0  -v4  v2 |
         |-v5   v4    0  v3 |
         |  0    0    0   0 |

\end{Code}


then \texttt{V} = [v1; v2; v3; v4; v5; v6].


\subsection*{Notes}
\begin{itemize}
  \item This is the inverse of the function SKEWA().
  \item The matrices are the generator matrices for se(2) and se(3).  The elements    comprise the equivalent twist vector.
\end{itemize}

\subsection*{References}
\begin{itemize}
  \item Robotics, Vision \& Control: Second Edition, Chap 2,    P. Corke, Springer 2016.
\end{itemize}

\subsection*{See also}


\hyperlink{skewa}{\color{blue} skewa}, \hyperlink{vex}{\color{blue} vex}, \hyperlink{Twist}{\color{blue} Twist}

\vspace{1.5ex}\rule{\textwidth}{1mm}

%---------------------- xyzlabel
\hypertarget{xyzlabel}{\section*{xyzlabel}}
\subsection*{Label X, Y and Z axes}
\addcontentsline{toc}{section}{xyzlabel}


\texttt{XYZLABEL()} label the x-, y- and z-axes with \textquotesingle X\textquotesingle , \textquotesingle Y\textquotesingle , and \textquotesingle Z\textquotesingle 
respectiveley.



\texttt{XYZLABEL(FMT)} as above but pass in a format string where \%s is substituted
for the axis label, eg.

\begin{Code}
    xyzlabel('This is the %s axis')

\end{Code}

\subsection*{See also}


\hyperlink{xlabel}{\color{blue} xlabel}, \hyperlink{ylabel}{\color{blue} ylabel}, \hyperlink{zlabel}{\color{blue} zlabel}, \hyperlink{sprintf}{\color{blue} sprintf}

\vspace{1.5ex}\rule{\textwidth}{1mm}
